[
  {
    "name": "cursorrules-brainstorming",
    "description": "Cursor rules version of brainstorming skill - ---",
    "content": "# Brainstorming - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Brainstorming\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this brainstorming methodology:\n\n1. [ ] Phase 1: Understanding (purpose, constraints, criteria gathered)\n2. [ ] Phase 2: Exploration (2-3 approaches proposed and evaluated)\n3. [ ] Phase 3: Design Presentation (design validated in sections)\n4. [ ] Phase 4: Design Documentation (design written to docs/plans/)\n5. [ ] Phase 5: Worktree Setup (if implementing)\n6. [ ] Phase 6: Planning Handoff (if implementing)\n7. Check current project state in working directory\n8. Ask ONE question at a time to refine the idea\n9. **Use AskUserQuestion tool** when you have multiple choice options\n10. Gather: Purpose, constraints, success criteria\n11. *Example using AskUserQuestion:**\n12. \"Session storage\" (clears on tab close, more secure)\n13. \"Local storage\" (persists across sessions, more convenient)\n14. \"Cookies\" (works with SSR, compatible with older approach)\n15. Propose 2-3 different approaches\n16. For each: Core architecture, trade-offs, complexity assessment\n17. **Use AskUserQuestion tool** to present approaches as structured choices\n18. Ask your human partner which approach resonates\n19. *Example using AskUserQuestion:**\n20. \"Event-driven with message queue\" (scalable, complex setup, eventual consistency)\n21. \"Direct API calls with retry logic\" (simple, synchronous, easier to debug)\n22. \"Hybrid with background jobs\" (balanced, moderate complexity, best of both)\n23. Present in 200-300 word sections\n24. Cover: Architecture, components, data flow, error handling, testing\n25. Ask after each section: \"Does this look right so far?\" (open-ended)\n26. Use open-ended questions here to allow freeform feedback\n27. **File location:** `docs/plans/YYYY-MM-DD-<topic>-design.md` (use actual date and descriptive topic)\n28. **RECOMMENDED SUB-SKILL:** Use elements-of-style:writing-clearly-and-concisely (if available) for documentation quality\n29. **Content:** Capture the design as discussed and validated in Phase 3, organized into the sections that emerged from the conversation\n30. Commit the design document to git before proceeding\n31. Announce: \"I'm using the using-git-worktrees skill to set up an isolated workspace.\"\n32. **REQUIRED SUB-SKILL:** Use superpowers:using-git-worktrees\n33. Follow that skill's process for directory selection, safety verification, and setup\n34. Return here when worktree ready\n35. Announce: \"I'm using the writing-plans skill to create the implementation plan.\"\n36. **REQUIRED SUB-SKILL:** Use superpowers:writing-plans\n37. Create detailed plan in the worktree\n38. *Use AskUserQuestion for:**\n39. Phase 1: Clarifying questions with 2-4 clear options\n40. Phase 2: Architectural approach selection (2-3 alternatives)\n41. Any decision with distinct, mutually exclusive choices\n42. When options have clear trade-offs to explain\n43. *Benefits:**\n44. Structured presentation of options with descriptions\n45. Clear trade-off visibility for partner\n46. Forces explicit choice (prevents vague \"maybe both\" responses)\n47. *Use open-ended questions for:**\n48. Phase 3: Design validation (\"Does this look right so far?\")\n49. When you need detailed feedback or explanation\n50. When partner should describe their own requirements\n51. When structured options would limit creative input\n52. *Example decision flow:**\n53. \"What authentication method?\" → Use AskUserQuestion (2-4 options)\n54. \"Does this design handle your use case?\" → Open-ended (validation)\n55. *You can and should go backward when:**\n56. Partner reveals new constraint during Phase 2 or 3 → Return to Phase 1\n57. Validation shows fundamental gap in requirements → Return to Phase 1\n58. Partner questions approach during Phase 3 → Return to Phase 2\n59. Something doesn't make sense → Go back and clarify\n60. *Don't force forward linearly** when going backward would give better results.\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── brainstorming.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: brainstorming\ndescription: Use when creating or developing anything, before writing code or implementation plans - refines rough ideas into fully-formed designs through structured Socratic questioning, alternative exploration, and incremental validation\n---\n\n# Brainstorming Ideas Into Designs\n\n## Overview\n\nTransform rough ideas into fully-formed designs through structured questioning and alternative exploration.\n\n**Core principle:** Ask questions to understand, explore alternatives, present design incrementally for validation.\n\n**Announce at start:** \"I'm using the brainstorming skill to refine your idea into a design.\"\n\n## Quick Reference\n\n| Phase | Key Activities | Tool Usage | Output |\n|-------|---------------|------------|--------|\n| **1. Understanding** | Ask questions (one at a time) | AskUserQuestion for choices | Purpose, constraints, criteria |\n| **2. Exploration** | Propose 2-3 approaches | AskUserQuestion for approach selection | Architecture options with trade-offs |\n| **3. Design Presentation** | Present in 200-300 word sections | Open-ended questions | Complete design with validation |\n| **4. Design Documentation** | Write design document | writing-clearly-and-concisely skill | Design doc in docs/plans/ |\n| **5. Worktree Setup** | Set up isolated workspace | using-git-worktrees skill | Ready development environment |\n| **6. Planning Handoff** | Create implementation plan | writing-plans skill | Detailed task breakdown |\n\n## The Process\n\nCopy this checklist to track progress:\n\n```\nBrainstorming Progress:\n- [ ] Phase 1: Understanding (purpose, constraints, criteria gathered)\n- [ ] Phase 2: Exploration (2-3 approaches proposed and evaluated)\n- [ ] Phase 3: Design Presentation (design validated in sections)\n- [ ] Phase 4: Design Documentation (design written to docs/plans/)\n- [ ] Phase 5: Worktree Setup (if implementing)\n- [ ] Phase 6: Planning Handoff (if implementing)\n```\n\n### Phase 1: Understanding\n- Check current project state in working directory\n- Ask ONE question at a time to refine the idea\n- **Use AskUserQuestion tool** when you have multiple choice options\n- Gather: Purpose, constraints, success criteria\n\n**Example using AskUserQuestion:**\n```\nQuestion: \"Where should the authentication data be stored?\"\nOptions:\n  - \"Session storage\" (clears on tab close, more secure)\n  - \"Local storage\" (persists across sessions, more convenient)\n  - \"Cookies\" (works with SSR, compatible with older approach)\n```\n\n### Phase 2: Exploration\n- Propose 2-3 different approaches\n- For each: Core architecture, trade-offs, complexity assessment\n- **Use AskUserQuestion tool** to present approaches as structured choices\n- Ask your human partner which approach resonates\n\n**Example using AskUserQuestion:**\n```\nQuestion: \"Which architectural approach should we use?\"\nOptions:\n  - \"Event-driven with message queue\" (scalable, complex setup, eventual consistency)\n  - \"Direct API calls with retry logic\" (simple, synchronous, easier to debug)\n  - \"Hybrid with background jobs\" (balanced, moderate complexity, best of both)\n```\n\n### Phase 3: Design Presentation\n- Present in 200-300 word sections\n- Cover: Architecture, components, data flow, error handling, testing\n- Ask after each section: \"Does this look right so far?\" (open-ended)\n- Use open-ended questions here to allow freeform feedback\n\n### Phase 4: Design Documentation\nAfter design is validated, write it to a permanent document:\n- **File location:** `docs/plans/YYYY-MM-DD-<topic>-design.md` (use actual date and descriptive topic)\n- **RECOMMENDED SUB-SKILL:** Use elements-of-style:writing-clearly-and-concisely (if available) for documentation quality\n- **Content:** Capture the design as discussed and validated in Phase 3, organized into the sections that emerged from the conversation\n- Commit the design document to git before proceeding\n\n### Phase 5: Worktree Setup (for implementation)\nWhen design is approved and implementation will follow:\n- Announce: \"I'm using the using-git-worktrees skill to set up an isolated workspace.\"\n- **REQUIRED SUB-SKILL:** Use superpowers:using-git-worktrees\n- Follow that skill's process for directory selection, safety verification, and setup\n- Return here when worktree ready\n\n### Phase 6: Planning Handoff\nAsk: \"Ready to create the implementation plan?\"\n\nWhen your human partner confirms (any affirmative response):\n- Announce: \"I'm using the writing-plans skill to create the implementation plan.\"\n- **REQUIRED SUB-SKILL:** Use superpowers:writing-plans\n- Create detailed plan in the worktree\n\n## Question Patterns\n\n### When to Use AskUserQuestion Tool\n\n**Use AskUserQuestion for:**\n- Phase 1: Clarifying questions with 2-4 clear options\n- Phase 2: Architectural approach selection (2-3 alternatives)\n- Any decision with distinct, mutually exclusive choices\n- When options have clear trade-offs to explain\n\n**Benefits:**\n- Structured presentation of options with descriptions\n- Clear trade-off visibility for partner\n- Forces explicit choice (prevents vague \"maybe both\" responses)\n\n### When to Use Open-Ended Questions\n\n**Use open-ended questions for:**\n- Phase 3: Design validation (\"Does this look right so far?\")\n- When you need detailed feedback or explanation\n- When partner should describe their own requirements\n- When structured options would limit creative input\n\n**Example decision flow:**\n- \"What authentication method?\" → Use AskUserQuestion (2-4 options)\n- \"Does this design handle your use case?\" → Open-ended (validation)\n\n## When to Revisit Earlier Phases\n\n```dot\ndigraph revisit_phases {\n    rankdir=LR;\n    \"New constraint revealed?\" [shape=diamond];\n    \"Partner questions approach?\" [shape=diamond];\n    \"Requirements unclear?\" [shape=diamond];\n    \"Return to Phase 1\" [shape=box, style=filled, fillcolor=\"#ffcccc\"];\n    \"Return to Phase 2\" [shape=box, style=filled, fillcolor=\"#ffffcc\"];\n    \"Continue forward\" [shape=box, style=filled, fillcolor=\"#ccffcc\"];\n\n    \"New constraint revealed?\" -> \"Return to Phase 1\" [label=\"yes\"];\n    \"New constraint revealed?\" -> \"Partner questions approach?\" [label=\"no\"];\n    \"Partner questions approach?\" -> \"Return to Phase 2\" [label=\"yes\"];\n    \"Partner questions approach?\" -> \"Requirements unclear?\" [label=\"no\"];\n    \"Requirements unclear?\" -> \"Return to Phase 1\" [label=\"yes\"];\n    \"Requirements unclear?\" -> \"Continue forward\" [label=\"no\"];\n}\n```\n\n**You can and should go backward when:**\n- Partner reveals new constraint during Phase 2 or 3 → Return to Phase 1\n- Validation shows fundamental gap in requirements → Return to Phase 1\n- Partner questions approach during Phase 3 → Return to Phase 2\n- Something doesn't make sense → Go back and clarify\n\n**Don't force forward linearly** when going backward would give better results.\n\n## Key Principles\n\n| Principle | Application |\n|-----------|-------------|\n| **One question at a time** | Phase 1: Single question per message, use AskUserQuestion for choices |\n| **Structured choices** | Use AskUserQuestion tool for 2-4 options with trade-offs |\n| **YAGNI ruthlessly** | Remove unnecessary features from all designs |\n| **Explore alternatives** | Always propose 2-3 approaches before settling |\n| **Incremental validation** | Present design in sections, validate each |\n| **Flexible progression** | Go backward when needed - flexibility > rigidity |\n| **Announce usage** | State skill usage at start of session |\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the brainstorming approach\n\n---\n*Converted from Claude Code Skill: brainstorming*\n*Source: brainstorming skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/brainstorming",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "brainstorming"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-brainstorming"
  },
  {
    "name": "cursorrules-condition-based-waiting",
    "description": "Cursor rules version of condition-based-waiting skill - ---",
    "content": "# Condition Based Waiting - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Condition Based Waiting\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this condition based waiting methodology:\n\nFollow the principles outlined below.\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── condition-based-waiting.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: condition-based-waiting\ndescription: Use when tests have race conditions, timing dependencies, or inconsistent pass/fail behavior - replaces arbitrary timeouts with condition polling to wait for actual state changes, eliminating flaky tests from timing guesses\n---\n\n# Condition-Based Waiting\n\n## Overview\n\nFlaky tests often guess at timing with arbitrary delays. This creates race conditions where tests pass on fast machines but fail under load or in CI.\n\n**Core principle:** Wait for the actual condition you care about, not a guess about how long it takes.\n\n## When to Use\n\n```dot\ndigraph when_to_use {\n    \"Test uses setTimeout/sleep?\" [shape=diamond];\n    \"Testing timing behavior?\" [shape=diamond];\n    \"Document WHY timeout needed\" [shape=box];\n    \"Use condition-based waiting\" [shape=box];\n\n    \"Test uses setTimeout/sleep?\" -> \"Testing timing behavior?\" [label=\"yes\"];\n    \"Testing timing behavior?\" -> \"Document WHY timeout needed\" [label=\"yes\"];\n    \"Testing timing behavior?\" -> \"Use condition-based waiting\" [label=\"no\"];\n}\n```\n\n**Use when:**\n- Tests have arbitrary delays (`setTimeout`, `sleep`, `time.sleep()`)\n- Tests are flaky (pass sometimes, fail under load)\n- Tests timeout when run in parallel\n- Waiting for async operations to complete\n\n**Don't use when:**\n- Testing actual timing behavior (debounce, throttle intervals)\n- Always document WHY if using arbitrary timeout\n\n## Core Pattern\n\n```typescript\n// ❌ BEFORE: Guessing at timing\nawait new Promise(r => setTimeout(r, 50));\nconst result = getResult();\nexpect(result).toBeDefined();\n\n// ✅ AFTER: Waiting for condition\nawait waitFor(() => getResult() !== undefined);\nconst result = getResult();\nexpect(result).toBeDefined();\n```\n\n## Quick Patterns\n\n| Scenario | Pattern |\n|----------|---------|\n| Wait for event | `waitFor(() => events.find(e => e.type === 'DONE'))` |\n| Wait for state | `waitFor(() => machine.state === 'ready')` |\n| Wait for count | `waitFor(() => items.length >= 5)` |\n| Wait for file | `waitFor(() => fs.existsSync(path))` |\n| Complex condition | `waitFor(() => obj.ready && obj.value > 10)` |\n\n## Implementation\n\nGeneric polling function:\n```typescript\nasync function waitFor<T>(\n  condition: () => T | undefined | null | false,\n  description: string,\n  timeoutMs = 5000\n): Promise<T> {\n  const startTime = Date.now();\n\n  while (true) {\n    const result = condition();\n    if (result) return result;\n\n    if (Date.now() - startTime > timeoutMs) {\n      throw new Error(`Timeout waiting for ${description} after ${timeoutMs}ms`);\n    }\n\n    await new Promise(r => setTimeout(r, 10)); // Poll every 10ms\n  }\n}\n```\n\nSee @example.ts for complete implementation with domain-specific helpers (`waitForEvent`, `waitForEventCount`, `waitForEventMatch`) from actual debugging session.\n\n## Common Mistakes\n\n**❌ Polling too fast:** `setTimeout(check, 1)` - wastes CPU\n**✅ Fix:** Poll every 10ms\n\n**❌ No timeout:** Loop forever if condition never met\n**✅ Fix:** Always include timeout with clear error\n\n**❌ Stale data:** Cache state before loop\n**✅ Fix:** Call getter inside loop for fresh data\n\n## When Arbitrary Timeout IS Correct\n\n```typescript\n// Tool ticks every 100ms - need 2 ticks to verify partial output\nawait waitForEvent(manager, 'TOOL_STARTED'); // First: wait for condition\nawait new Promise(r => setTimeout(r, 200));   // Then: wait for timed behavior\n// 200ms = 2 ticks at 100ms intervals - documented and justified\n```\n\n**Requirements:**\n1. First wait for triggering condition\n2. Based on known timing (not guessing)\n3. Comment explaining WHY\n\n## Real-World Impact\n\nFrom debugging session (2025-10-03):\n- Fixed 15 flaky tests across 3 files\n- Pass rate: 60% → 100%\n- Execution time: 40% faster\n- No more race conditions\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the condition based waiting approach\n\n---\n*Converted from Claude Code Skill: condition-based-waiting*\n*Source: condition based waiting skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/condition-based-waiting",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "condition",
      "based",
      "waiting"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-condition-based-waiting"
  },
  {
    "name": "cursorrules-defense-in-depth",
    "description": "Cursor rules version of defense-in-depth skill - ---",
    "content": "# Defense In Depth - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Defense In Depth\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this defense in depth methodology:\n\nFollow the principles outlined below.\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Entry validation catches most bugs\n- Business logic catches edge cases\n- Environment guards prevent context-specific dangers\n- Debug logging helps when other layers fail\n- *Purpose:** Reject obviously invalid input at API boundary\n- *Purpose:** Ensure data makes sense for this operation\n- *Purpose:** Prevent dangerous operations in specific contexts\n- *Purpose:** Capture context for forensics\n\n\n## Examples\n\n- *Data flow:**\n- *Four layers added:**\n- Layer 1: `Project.create()` validates not empty/exists/writable\n- Layer 2: `WorkspaceManager` validates projectDir not empty\n- Layer 3: `WorktreeManager` refuses git init outside tmpdir in tests\n- Layer 4: Stack trace logging before git init\n- *Result:** All 1847 tests passed, bug impossible to reproduce\n- Different code paths bypassed entry validation\n- Mocks bypassed business logic checks\n- Edge cases on different platforms needed environment guards\n- Debug logging identified structural misuse\n- *Don't stop at one validation point.** Add checks at every layer.\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── defense-in-depth.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: defense-in-depth\ndescription: Use when invalid data causes failures deep in execution, requiring validation at multiple system layers - validates at every layer data passes through to make bugs structurally impossible\n---\n\n# Defense-in-Depth Validation\n\n## Overview\n\nWhen you fix a bug caused by invalid data, adding validation at one place feels sufficient. But that single check can be bypassed by different code paths, refactoring, or mocks.\n\n**Core principle:** Validate at EVERY layer data passes through. Make the bug structurally impossible.\n\n## Why Multiple Layers\n\nSingle validation: \"We fixed the bug\"\nMultiple layers: \"We made the bug impossible\"\n\nDifferent layers catch different cases:\n- Entry validation catches most bugs\n- Business logic catches edge cases\n- Environment guards prevent context-specific dangers\n- Debug logging helps when other layers fail\n\n## The Four Layers\n\n### Layer 1: Entry Point Validation\n**Purpose:** Reject obviously invalid input at API boundary\n\n```typescript\nfunction createProject(name: string, workingDirectory: string) {\n  if (!workingDirectory || workingDirectory.trim() === '') {\n    throw new Error('workingDirectory cannot be empty');\n  }\n  if (!existsSync(workingDirectory)) {\n    throw new Error(`workingDirectory does not exist: ${workingDirectory}`);\n  }\n  if (!statSync(workingDirectory).isDirectory()) {\n    throw new Error(`workingDirectory is not a directory: ${workingDirectory}`);\n  }\n  // ... proceed\n}\n```\n\n### Layer 2: Business Logic Validation\n**Purpose:** Ensure data makes sense for this operation\n\n```typescript\nfunction initializeWorkspace(projectDir: string, sessionId: string) {\n  if (!projectDir) {\n    throw new Error('projectDir required for workspace initialization');\n  }\n  // ... proceed\n}\n```\n\n### Layer 3: Environment Guards\n**Purpose:** Prevent dangerous operations in specific contexts\n\n```typescript\nasync function gitInit(directory: string) {\n  // In tests, refuse git init outside temp directories\n  if (process.env.NODE_ENV === 'test') {\n    const normalized = normalize(resolve(directory));\n    const tmpDir = normalize(resolve(tmpdir()));\n\n    if (!normalized.startsWith(tmpDir)) {\n      throw new Error(\n        `Refusing git init outside temp dir during tests: ${directory}`\n      );\n    }\n  }\n  // ... proceed\n}\n```\n\n### Layer 4: Debug Instrumentation\n**Purpose:** Capture context for forensics\n\n```typescript\nasync function gitInit(directory: string) {\n  const stack = new Error().stack;\n  logger.debug('About to git init', {\n    directory,\n    cwd: process.cwd(),\n    stack,\n  });\n  // ... proceed\n}\n```\n\n## Applying the Pattern\n\nWhen you find a bug:\n\n1. **Trace the data flow** - Where does bad value originate? Where used?\n2. **Map all checkpoints** - List every point data passes through\n3. **Add validation at each layer** - Entry, business, environment, debug\n4. **Test each layer** - Try to bypass layer 1, verify layer 2 catches it\n\n## Example from Session\n\nBug: Empty `projectDir` caused `git init` in source code\n\n**Data flow:**\n1. Test setup → empty string\n2. `Project.create(name, '')`\n3. `WorkspaceManager.createWorkspace('')`\n4. `git init` runs in `process.cwd()`\n\n**Four layers added:**\n- Layer 1: `Project.create()` validates not empty/exists/writable\n- Layer 2: `WorkspaceManager` validates projectDir not empty\n- Layer 3: `WorktreeManager` refuses git init outside tmpdir in tests\n- Layer 4: Stack trace logging before git init\n\n**Result:** All 1847 tests passed, bug impossible to reproduce\n\n## Key Insight\n\nAll four layers were necessary. During testing, each layer caught bugs the others missed:\n- Different code paths bypassed entry validation\n- Mocks bypassed business logic checks\n- Edge cases on different platforms needed environment guards\n- Debug logging identified structural misuse\n\n**Don't stop at one validation point.** Add checks at every layer.\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the defense in depth approach\n\n---\n*Converted from Claude Code Skill: defense-in-depth*\n*Source: defense in depth skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/defense-in-depth",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "defense",
      "in",
      "depth"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-defense-in-depth"
  },
  {
    "name": "cursorrules-dispatching-parallel-agents",
    "description": "Cursor rules version of dispatching-parallel-agents skill - ---",
    "content": "# Dispatching Parallel Agents - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Dispatching Parallel Agents\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this dispatching parallel agents methodology:\n\nFollow the principles outlined below.\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n## Examples\n\n- *Scenario:** 6 test failures across 3 files after major refactoring\n- *Failures:**\n- agent-tool-abort.test.ts: 3 failures (timing issues)\n- batch-completion-behavior.test.ts: 2 failures (tools not executing)\n- tool-approval-race-conditions.test.ts: 1 failure (execution count = 0)\n- *Decision:** Independent domains - abort logic separate from batch completion separate from race conditions\n- *Dispatch:**\n- *Results:**\n- Agent 1: Replaced timeouts with event-based waiting\n- Agent 2: Fixed event structure bug (threadId in wrong place)\n- Agent 3: Added wait for async tool execution to complete\n- *Integration:** All fixes independent, no conflicts, full suite green\n- *Time saved:** 3 problems solved in parallel vs sequentially\n- 6 failures across 3 files\n- 3 agents dispatched in parallel\n- All investigations completed concurrently\n- All fixes integrated successfully\n- Zero conflicts between agent changes\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── dispatching-parallel-agents.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: dispatching-parallel-agents\ndescription: Use when facing 3+ independent failures that can be investigated without shared state or dependencies - dispatches multiple Claude agents to investigate and fix independent problems concurrently\n---\n\n# Dispatching Parallel Agents\n\n## Overview\n\nWhen you have multiple unrelated failures (different test files, different subsystems, different bugs), investigating them sequentially wastes time. Each investigation is independent and can happen in parallel.\n\n**Core principle:** Dispatch one agent per independent problem domain. Let them work concurrently.\n\n## When to Use\n\n```dot\ndigraph when_to_use {\n    \"Multiple failures?\" [shape=diamond];\n    \"Are they independent?\" [shape=diamond];\n    \"Single agent investigates all\" [shape=box];\n    \"One agent per problem domain\" [shape=box];\n    \"Can they work in parallel?\" [shape=diamond];\n    \"Sequential agents\" [shape=box];\n    \"Parallel dispatch\" [shape=box];\n\n    \"Multiple failures?\" -> \"Are they independent?\" [label=\"yes\"];\n    \"Are they independent?\" -> \"Single agent investigates all\" [label=\"no - related\"];\n    \"Are they independent?\" -> \"Can they work in parallel?\" [label=\"yes\"];\n    \"Can they work in parallel?\" -> \"Parallel dispatch\" [label=\"yes\"];\n    \"Can they work in parallel?\" -> \"Sequential agents\" [label=\"no - shared state\"];\n}\n```\n\n**Use when:**\n- 3+ test files failing with different root causes\n- Multiple subsystems broken independently\n- Each problem can be understood without context from others\n- No shared state between investigations\n\n**Don't use when:**\n- Failures are related (fix one might fix others)\n- Need to understand full system state\n- Agents would interfere with each other\n\n## The Pattern\n\n### 1. Identify Independent Domains\n\nGroup failures by what's broken:\n- File A tests: Tool approval flow\n- File B tests: Batch completion behavior\n- File C tests: Abort functionality\n\nEach domain is independent - fixing tool approval doesn't affect abort tests.\n\n### 2. Create Focused Agent Tasks\n\nEach agent gets:\n- **Specific scope:** One test file or subsystem\n- **Clear goal:** Make these tests pass\n- **Constraints:** Don't change other code\n- **Expected output:** Summary of what you found and fixed\n\n### 3. Dispatch in Parallel\n\n```typescript\n// In Claude Code / AI environment\nTask(\"Fix agent-tool-abort.test.ts failures\")\nTask(\"Fix batch-completion-behavior.test.ts failures\")\nTask(\"Fix tool-approval-race-conditions.test.ts failures\")\n// All three run concurrently\n```\n\n### 4. Review and Integrate\n\nWhen agents return:\n- Read each summary\n- Verify fixes don't conflict\n- Run full test suite\n- Integrate all changes\n\n## Agent Prompt Structure\n\nGood agent prompts are:\n1. **Focused** - One clear problem domain\n2. **Self-contained** - All context needed to understand the problem\n3. **Specific about output** - What should the agent return?\n\n```markdown\nFix the 3 failing tests in src/agents/agent-tool-abort.test.ts:\n\n1. \"should abort tool with partial output capture\" - expects 'interrupted at' in message\n2. \"should handle mixed completed and aborted tools\" - fast tool aborted instead of completed\n3. \"should properly track pendingToolCount\" - expects 3 results but gets 0\n\nThese are timing/race condition issues. Your task:\n\n1. Read the test file and understand what each test verifies\n2. Identify root cause - timing issues or actual bugs?\n3. Fix by:\n   - Replacing arbitrary timeouts with event-based waiting\n   - Fixing bugs in abort implementation if found\n   - Adjusting test expectations if testing changed behavior\n\nDo NOT just increase timeouts - find the real issue.\n\nReturn: Summary of what you found and what you fixed.\n```\n\n## Common Mistakes\n\n**❌ Too broad:** \"Fix all the tests\" - agent gets lost\n**✅ Specific:** \"Fix agent-tool-abort.test.ts\" - focused scope\n\n**❌ No context:** \"Fix the race condition\" - agent doesn't know where\n**✅ Context:** Paste the error messages and test names\n\n**❌ No constraints:** Agent might refactor everything\n**✅ Constraints:** \"Do NOT change production code\" or \"Fix tests only\"\n\n**❌ Vague output:** \"Fix it\" - you don't know what changed\n**✅ Specific:** \"Return summary of root cause and changes\"\n\n## When NOT to Use\n\n**Related failures:** Fixing one might fix others - investigate together first\n**Need full context:** Understanding requires seeing entire system\n**Exploratory debugging:** You don't know what's broken yet\n**Shared state:** Agents would interfere (editing same files, using same resources)\n\n## Real Example from Session\n\n**Scenario:** 6 test failures across 3 files after major refactoring\n\n**Failures:**\n- agent-tool-abort.test.ts: 3 failures (timing issues)\n- batch-completion-behavior.test.ts: 2 failures (tools not executing)\n- tool-approval-race-conditions.test.ts: 1 failure (execution count = 0)\n\n**Decision:** Independent domains - abort logic separate from batch completion separate from race conditions\n\n**Dispatch:**\n```\nAgent 1 → Fix agent-tool-abort.test.ts\nAgent 2 → Fix batch-completion-behavior.test.ts\nAgent 3 → Fix tool-approval-race-conditions.test.ts\n```\n\n**Results:**\n- Agent 1: Replaced timeouts with event-based waiting\n- Agent 2: Fixed event structure bug (threadId in wrong place)\n- Agent 3: Added wait for async tool execution to complete\n\n**Integration:** All fixes independent, no conflicts, full suite green\n\n**Time saved:** 3 problems solved in parallel vs sequentially\n\n## Key Benefits\n\n1. **Parallelization** - Multiple investigations happen simultaneously\n2. **Focus** - Each agent has narrow scope, less context to track\n3. **Independence** - Agents don't interfere with each other\n4. **Speed** - 3 problems solved in time of 1\n\n## Verification\n\nAfter agents return:\n1. **Review each summary** - Understand what changed\n2. **Check for conflicts** - Did agents edit same code?\n3. **Run full suite** - Verify all fixes work together\n4. **Spot check** - Agents can make systematic errors\n\n## Real-World Impact\n\nFrom debugging session (2025-10-03):\n- 6 failures across 3 files\n- 3 agents dispatched in parallel\n- All investigations completed concurrently\n- All fixes integrated successfully\n- Zero conflicts between agent changes\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the dispatching parallel agents approach\n\n---\n*Converted from Claude Code Skill: dispatching-parallel-agents*\n*Source: dispatching parallel agents skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/dispatching-parallel-agents",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "dispatching",
      "parallel",
      "agents"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-dispatching-parallel-agents"
  },
  {
    "name": "cursorrules-executing-plans",
    "description": "Cursor rules version of executing-plans skill - ---",
    "content": "# Executing Plans - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Executing Plans\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this executing plans methodology:\n\n1. *Default: First 3 tasks**\n2. Show what was implemented\n3. Show verification output\n4. Say: \"Ready for feedback.\"\n5. Apply changes if needed\n6. Execute next batch\n7. Repeat until complete\n8. Announce: \"I'm using the finishing-a-development-branch skill to complete this work.\"\n9. **REQUIRED SUB-SKILL:** Use superpowers:finishing-a-development-branch\n10. Follow that skill to verify tests, present options, execute choice\n11. *STOP executing immediately when:**\n12. Hit a blocker mid-batch (missing dependency, test fails, instruction unclear)\n13. Plan has critical gaps preventing starting\n14. You don't understand an instruction\n15. Verification fails repeatedly\n16. *Ask for clarification rather than guessing.**\n17. *Return to Review (Step 1) when:**\n18. Partner updates the plan based on your feedback\n19. Fundamental approach needs rethinking\n20. *Don't force through blockers** - stop and ask.\n21. Review plan critically first\n22. Follow plan steps exactly\n23. Don't skip verifications\n24. Reference skills when plan says to\n25. Between batches: just report and wait\n26. Stop when blocked, don't guess\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── executing-plans.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: executing-plans\ndescription: Use when partner provides a complete implementation plan to execute in controlled batches with review checkpoints - loads plan, reviews critically, executes tasks in batches, reports for review between batches\n---\n\n# Executing Plans\n\n## Overview\n\nLoad plan, review critically, execute tasks in batches, report for review between batches.\n\n**Core principle:** Batch execution with checkpoints for architect review.\n\n**Announce at start:** \"I'm using the executing-plans skill to implement this plan.\"\n\n## The Process\n\n### Step 1: Load and Review Plan\n1. Read plan file\n2. Review critically - identify any questions or concerns about the plan\n3. If concerns: Raise them with your human partner before starting\n4. If no concerns: Create TodoWrite and proceed\n\n### Step 2: Execute Batch\n**Default: First 3 tasks**\n\nFor each task:\n1. Mark as in_progress\n2. Follow each step exactly (plan has bite-sized steps)\n3. Run verifications as specified\n4. Mark as completed\n\n### Step 3: Report\nWhen batch complete:\n- Show what was implemented\n- Show verification output\n- Say: \"Ready for feedback.\"\n\n### Step 4: Continue\nBased on feedback:\n- Apply changes if needed\n- Execute next batch\n- Repeat until complete\n\n### Step 5: Complete Development\n\nAfter all tasks complete and verified:\n- Announce: \"I'm using the finishing-a-development-branch skill to complete this work.\"\n- **REQUIRED SUB-SKILL:** Use superpowers:finishing-a-development-branch\n- Follow that skill to verify tests, present options, execute choice\n\n## When to Stop and Ask for Help\n\n**STOP executing immediately when:**\n- Hit a blocker mid-batch (missing dependency, test fails, instruction unclear)\n- Plan has critical gaps preventing starting\n- You don't understand an instruction\n- Verification fails repeatedly\n\n**Ask for clarification rather than guessing.**\n\n## When to Revisit Earlier Steps\n\n**Return to Review (Step 1) when:**\n- Partner updates the plan based on your feedback\n- Fundamental approach needs rethinking\n\n**Don't force through blockers** - stop and ask.\n\n## Remember\n- Review plan critically first\n- Follow plan steps exactly\n- Don't skip verifications\n- Reference skills when plan says to\n- Between batches: just report and wait\n- Stop when blocked, don't guess\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the executing plans approach\n\n---\n*Converted from Claude Code Skill: executing-plans*\n*Source: executing plans skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/executing-plans",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "executing",
      "plans"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-executing-plans"
  },
  {
    "name": "cursorrules-finishing-a-development-branch",
    "description": "Cursor rules version of finishing-a-development-branch skill - ---",
    "content": "# Finishing A Development Branch - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Finishing A Development Branch\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this finishing a development branch methodology:\n\n1. *Before presenting options, verify tests pass:**\n2. *If tests fail:**\n3. *If tests pass:** Continue to Step 2.\n4. *Don't add explanation** - keep options concise.\n5. [ ] <verification steps>\n6. *Don't cleanup worktree.**\n7. *Confirm first:**\n8. Branch <name>\n9. All commits: <commit-list>\n10. Worktree at <path>\n11. *For Options 1, 2, 4:**\n12. *For Option 3:** Keep worktree.\n13. *Skipping test verification**\n14. **Problem:** Merge broken code, create failing PR\n15. **Fix:** Always verify tests before offering options\n16. *Open-ended questions**\n17. **Problem:** \"What should I do next?\" → ambiguous\n18. **Fix:** Present exactly 4 structured options\n19. *Automatic worktree cleanup**\n20. **Problem:** Remove worktree when might need it (Option 2, 3)\n21. **Fix:** Only cleanup for Options 1 and 4\n22. *No confirmation for discard**\n23. **Problem:** Accidentally delete work\n24. **Fix:** Require typed \"discard\" confirmation\n25. *Never:**\n26. Proceed with failing tests\n27. Merge without verifying tests on result\n28. Delete work without confirmation\n29. Force-push without explicit request\n30. *Always:**\n31. Verify tests before offering options\n32. Present exactly 4 options\n33. Get typed confirmation for Option 4\n34. Clean up worktree for Options 1 & 4 only\n35. *Called by:**\n36. **subagent-driven-development** (Step 7) - After all tasks complete\n37. **executing-plans** (Step 5) - After all batches complete\n38. *Pairs with:**\n39. **using-git-worktrees** - Cleans up worktree created by that skill\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── finishing-a-development-branch.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: finishing-a-development-branch\ndescription: Use when implementation is complete, all tests pass, and you need to decide how to integrate the work - guides completion of development work by presenting structured options for merge, PR, or cleanup\n---\n\n# Finishing a Development Branch\n\n## Overview\n\nGuide completion of development work by presenting clear options and handling chosen workflow.\n\n**Core principle:** Verify tests → Present options → Execute choice → Clean up.\n\n**Announce at start:** \"I'm using the finishing-a-development-branch skill to complete this work.\"\n\n## The Process\n\n### Step 1: Verify Tests\n\n**Before presenting options, verify tests pass:**\n\n```bash\n# Run project's test suite\nnpm test / cargo test / pytest / go test ./...\n```\n\n**If tests fail:**\n```\nTests failing (<N> failures). Must fix before completing:\n\n[Show failures]\n\nCannot proceed with merge/PR until tests pass.\n```\n\nStop. Don't proceed to Step 2.\n\n**If tests pass:** Continue to Step 2.\n\n### Step 2: Determine Base Branch\n\n```bash\n# Try common base branches\ngit merge-base HEAD main 2>/dev/null || git merge-base HEAD master 2>/dev/null\n```\n\nOr ask: \"This branch split from main - is that correct?\"\n\n### Step 3: Present Options\n\nPresent exactly these 4 options:\n\n```\nImplementation complete. What would you like to do?\n\n1. Merge back to <base-branch> locally\n2. Push and create a Pull Request\n3. Keep the branch as-is (I'll handle it later)\n4. Discard this work\n\nWhich option?\n```\n\n**Don't add explanation** - keep options concise.\n\n### Step 4: Execute Choice\n\n#### Option 1: Merge Locally\n\n```bash\n# Switch to base branch\ngit checkout <base-branch>\n\n# Pull latest\ngit pull\n\n# Merge feature branch\ngit merge <feature-branch>\n\n# Verify tests on merged result\n<test command>\n\n# If tests pass\ngit branch -d <feature-branch>\n```\n\nThen: Cleanup worktree (Step 5)\n\n#### Option 2: Push and Create PR\n\n```bash\n# Push branch\ngit push -u origin <feature-branch>\n\n# Create PR\ngh pr create --title \"<title>\" --body \"$(cat <<'EOF'\n## Summary\n<2-3 bullets of what changed>\n\n## Test Plan\n- [ ] <verification steps>\nEOF\n)\"\n```\n\nThen: Cleanup worktree (Step 5)\n\n#### Option 3: Keep As-Is\n\nReport: \"Keeping branch <name>. Worktree preserved at <path>.\"\n\n**Don't cleanup worktree.**\n\n#### Option 4: Discard\n\n**Confirm first:**\n```\nThis will permanently delete:\n- Branch <name>\n- All commits: <commit-list>\n- Worktree at <path>\n\nType 'discard' to confirm.\n```\n\nWait for exact confirmation.\n\nIf confirmed:\n```bash\ngit checkout <base-branch>\ngit branch -D <feature-branch>\n```\n\nThen: Cleanup worktree (Step 5)\n\n### Step 5: Cleanup Worktree\n\n**For Options 1, 2, 4:**\n\nCheck if in worktree:\n```bash\ngit worktree list | grep $(git branch --show-current)\n```\n\nIf yes:\n```bash\ngit worktree remove <worktree-path>\n```\n\n**For Option 3:** Keep worktree.\n\n## Quick Reference\n\n| Option | Merge | Push | Keep Worktree | Cleanup Branch |\n|--------|-------|------|---------------|----------------|\n| 1. Merge locally | ✓ | - | - | ✓ |\n| 2. Create PR | - | ✓ | ✓ | - |\n| 3. Keep as-is | - | - | ✓ | - |\n| 4. Discard | - | - | - | ✓ (force) |\n\n## Common Mistakes\n\n**Skipping test verification**\n- **Problem:** Merge broken code, create failing PR\n- **Fix:** Always verify tests before offering options\n\n**Open-ended questions**\n- **Problem:** \"What should I do next?\" → ambiguous\n- **Fix:** Present exactly 4 structured options\n\n**Automatic worktree cleanup**\n- **Problem:** Remove worktree when might need it (Option 2, 3)\n- **Fix:** Only cleanup for Options 1 and 4\n\n**No confirmation for discard**\n- **Problem:** Accidentally delete work\n- **Fix:** Require typed \"discard\" confirmation\n\n## Red Flags\n\n**Never:**\n- Proceed with failing tests\n- Merge without verifying tests on result\n- Delete work without confirmation\n- Force-push without explicit request\n\n**Always:**\n- Verify tests before offering options\n- Present exactly 4 options\n- Get typed confirmation for Option 4\n- Clean up worktree for Options 1 & 4 only\n\n## Integration\n\n**Called by:**\n- **subagent-driven-development** (Step 7) - After all tasks complete\n- **executing-plans** (Step 5) - After all batches complete\n\n**Pairs with:**\n- **using-git-worktrees** - Cleans up worktree created by that skill\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the finishing a development branch approach\n\n---\n*Converted from Claude Code Skill: finishing-a-development-branch*\n*Source: finishing a development branch skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/finishing-a-development-branch",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "finishing",
      "a",
      "development"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-finishing-a-development-branch"
  },
  {
    "name": "cursorrules-receiving-code-review",
    "description": "Cursor rules version of receiving-code-review skill - ---",
    "content": "# Receiving Code Review - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Receiving Code Review\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this receiving code review methodology:\n\nFollow the principles outlined below.\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n## Examples\n\n- *Performative Agreement (Bad):**\n- *Technical Verification (Good):**\n- *YAGNI (Good):**\n- *Unclear Item (Good):**\n- *External feedback = suggestions to evaluate, not orders to follow.**\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── receiving-code-review.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: receiving-code-review\ndescription: Use when receiving code review feedback, before implementing suggestions, especially if feedback seems unclear or technically questionable - requires technical rigor and verification, not performative agreement or blind implementation\n---\n\n# Code Review Reception\n\n## Overview\n\nCode review requires technical evaluation, not emotional performance.\n\n**Core principle:** Verify before implementing. Ask before assuming. Technical correctness over social comfort.\n\n## The Response Pattern\n\n```\nWHEN receiving code review feedback:\n\n1. READ: Complete feedback without reacting\n2. UNDERSTAND: Restate requirement in own words (or ask)\n3. VERIFY: Check against codebase reality\n4. EVALUATE: Technically sound for THIS codebase?\n5. RESPOND: Technical acknowledgment or reasoned pushback\n6. IMPLEMENT: One item at a time, test each\n```\n\n## Forbidden Responses\n\n**NEVER:**\n- \"You're absolutely right!\" (explicit CLAUDE.md violation)\n- \"Great point!\" / \"Excellent feedback!\" (performative)\n- \"Let me implement that now\" (before verification)\n\n**INSTEAD:**\n- Restate the technical requirement\n- Ask clarifying questions\n- Push back with technical reasoning if wrong\n- Just start working (actions > words)\n\n## Handling Unclear Feedback\n\n```\nIF any item is unclear:\n  STOP - do not implement anything yet\n  ASK for clarification on unclear items\n\nWHY: Items may be related. Partial understanding = wrong implementation.\n```\n\n**Example:**\n```\nyour human partner: \"Fix 1-6\"\nYou understand 1,2,3,6. Unclear on 4,5.\n\n❌ WRONG: Implement 1,2,3,6 now, ask about 4,5 later\n✅ RIGHT: \"I understand items 1,2,3,6. Need clarification on 4 and 5 before proceeding.\"\n```\n\n## Source-Specific Handling\n\n### From your human partner\n- **Trusted** - implement after understanding\n- **Still ask** if scope unclear\n- **No performative agreement**\n- **Skip to action** or technical acknowledgment\n\n### From External Reviewers\n```\nBEFORE implementing:\n  1. Check: Technically correct for THIS codebase?\n  2. Check: Breaks existing functionality?\n  3. Check: Reason for current implementation?\n  4. Check: Works on all platforms/versions?\n  5. Check: Does reviewer understand full context?\n\nIF suggestion seems wrong:\n  Push back with technical reasoning\n\nIF can't easily verify:\n  Say so: \"I can't verify this without [X]. Should I [investigate/ask/proceed]?\"\n\nIF conflicts with your human partner's prior decisions:\n  Stop and discuss with your human partner first\n```\n\n**your human partner's rule:** \"External feedback - be skeptical, but check carefully\"\n\n## YAGNI Check for \"Professional\" Features\n\n```\nIF reviewer suggests \"implementing properly\":\n  grep codebase for actual usage\n\n  IF unused: \"This endpoint isn't called. Remove it (YAGNI)?\"\n  IF used: Then implement properly\n```\n\n**your human partner's rule:** \"You and reviewer both report to me. If we don't need this feature, don't add it.\"\n\n## Implementation Order\n\n```\nFOR multi-item feedback:\n  1. Clarify anything unclear FIRST\n  2. Then implement in this order:\n     - Blocking issues (breaks, security)\n     - Simple fixes (typos, imports)\n     - Complex fixes (refactoring, logic)\n  3. Test each fix individually\n  4. Verify no regressions\n```\n\n## When To Push Back\n\nPush back when:\n- Suggestion breaks existing functionality\n- Reviewer lacks full context\n- Violates YAGNI (unused feature)\n- Technically incorrect for this stack\n- Legacy/compatibility reasons exist\n- Conflicts with your human partner's architectural decisions\n\n**How to push back:**\n- Use technical reasoning, not defensiveness\n- Ask specific questions\n- Reference working tests/code\n- Involve your human partner if architectural\n\n**Signal if uncomfortable pushing back out loud:** \"Strange things are afoot at the Circle K\"\n\n## Acknowledging Correct Feedback\n\nWhen feedback IS correct:\n```\n✅ \"Fixed. [Brief description of what changed]\"\n✅ \"Good catch - [specific issue]. Fixed in [location].\"\n✅ [Just fix it and show in the code]\n\n❌ \"You're absolutely right!\"\n❌ \"Great point!\"\n❌ \"Thanks for catching that!\"\n❌ \"Thanks for [anything]\"\n❌ ANY gratitude expression\n```\n\n**Why no thanks:** Actions speak. Just fix it. The code itself shows you heard the feedback.\n\n**If you catch yourself about to write \"Thanks\":** DELETE IT. State the fix instead.\n\n## Gracefully Correcting Your Pushback\n\nIf you pushed back and were wrong:\n```\n✅ \"You were right - I checked [X] and it does [Y]. Implementing now.\"\n✅ \"Verified this and you're correct. My initial understanding was wrong because [reason]. Fixing.\"\n\n❌ Long apology\n❌ Defending why you pushed back\n❌ Over-explaining\n```\n\nState the correction factually and move on.\n\n## Common Mistakes\n\n| Mistake | Fix |\n|---------|-----|\n| Performative agreement | State requirement or just act |\n| Blind implementation | Verify against codebase first |\n| Batch without testing | One at a time, test each |\n| Assuming reviewer is right | Check if breaks things |\n| Avoiding pushback | Technical correctness > comfort |\n| Partial implementation | Clarify all items first |\n| Can't verify, proceed anyway | State limitation, ask for direction |\n\n## Real Examples\n\n**Performative Agreement (Bad):**\n```\nReviewer: \"Remove legacy code\"\n❌ \"You're absolutely right! Let me remove that...\"\n```\n\n**Technical Verification (Good):**\n```\nReviewer: \"Remove legacy code\"\n✅ \"Checking... build target is 10.15+, this API needs 13+. Need legacy for backward compat. Current impl has wrong bundle ID - fix it or drop pre-13 support?\"\n```\n\n**YAGNI (Good):**\n```\nReviewer: \"Implement proper metrics tracking with database, date filters, CSV export\"\n✅ \"Grepped codebase - nothing calls this endpoint. Remove it (YAGNI)? Or is there usage I'm missing?\"\n```\n\n**Unclear Item (Good):**\n```\nyour human partner: \"Fix items 1-6\"\nYou understand 1,2,3,6. Unclear on 4,5.\n✅ \"Understand 1,2,3,6. Need clarification on 4 and 5 before implementing.\"\n```\n\n## The Bottom Line\n\n**External feedback = suggestions to evaluate, not orders to follow.**\n\nVerify. Question. Then implement.\n\nNo performative agreement. Technical rigor always.\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the receiving code review approach\n\n---\n*Converted from Claude Code Skill: receiving-code-review*\n*Source: receiving code review skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/receiving-code-review",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "receiving",
      "code",
      "review"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-receiving-code-review"
  },
  {
    "name": "cursorrules-requesting-code-review",
    "description": "Cursor rules version of requesting-code-review skill - ---",
    "content": "# Requesting Code Review - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Requesting Code Review\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this requesting code review methodology:\n\n1. *Subagent-Driven Development:**\n2. Review after EACH task\n3. Catch issues before they compound\n4. Fix before moving to next task\n5. *Executing Plans:**\n6. Review after each batch (3 tasks)\n7. Get feedback, apply, continue\n8. *Ad-Hoc Development:**\n9. Review before merge\n10. Review when stuck\n11. *Never:**\n12. Skip review because \"it's simple\"\n13. Ignore Critical issues\n14. Proceed with unfixed Important issues\n15. Argue with valid technical feedback\n16. *If reviewer wrong:**\n17. Push back with technical reasoning\n18. Show code/tests that prove it works\n19. Request clarification\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── requesting-code-review.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: requesting-code-review\ndescription: Use when completing tasks, implementing major features, or before merging to verify work meets requirements - dispatches code-reviewer subagent to review implementation against plan or requirements before proceeding\n---\n\n# Requesting Code Review\n\nDispatch code-reviewer subagent to catch issues before they cascade.\n\n**Core principle:** Review early, review often.\n\n## When to Request Review\n\n**Mandatory:**\n- After each task in subagent-driven development\n- After completing major feature\n- Before merge to main\n\n**Optional but valuable:**\n- When stuck (fresh perspective)\n- Before refactoring (baseline check)\n- After fixing complex bug\n\n## How to Request\n\n**1. Get git SHAs:**\n```bash\nBASE_SHA=$(git rev-parse HEAD~1)  # or origin/main\nHEAD_SHA=$(git rev-parse HEAD)\n```\n\n**2. Dispatch code-reviewer subagent:**\n\nUse Task tool with code-reviewer type, fill template at `code-reviewer.md`\n\n**Placeholders:**\n- `{WHAT_WAS_IMPLEMENTED}` - What you just built\n- `{PLAN_OR_REQUIREMENTS}` - What it should do\n- `{BASE_SHA}` - Starting commit\n- `{HEAD_SHA}` - Ending commit\n- `{DESCRIPTION}` - Brief summary\n\n**3. Act on feedback:**\n- Fix Critical issues immediately\n- Fix Important issues before proceeding\n- Note Minor issues for later\n- Push back if reviewer is wrong (with reasoning)\n\n## Example\n\n```\n[Just completed Task 2: Add verification function]\n\nYou: Let me request code review before proceeding.\n\nBASE_SHA=$(git log --oneline | grep \"Task 1\" | head -1 | awk '{print $1}')\nHEAD_SHA=$(git rev-parse HEAD)\n\n[Dispatch code-reviewer subagent]\n  WHAT_WAS_IMPLEMENTED: Verification and repair functions for conversation index\n  PLAN_OR_REQUIREMENTS: Task 2 from docs/plans/deployment-plan.md\n  BASE_SHA: a7981ec\n  HEAD_SHA: 3df7661\n  DESCRIPTION: Added verifyIndex() and repairIndex() with 4 issue types\n\n[Subagent returns]:\n  Strengths: Clean architecture, real tests\n  Issues:\n    Important: Missing progress indicators\n    Minor: Magic number (100) for reporting interval\n  Assessment: Ready to proceed\n\nYou: [Fix progress indicators]\n[Continue to Task 3]\n```\n\n## Integration with Workflows\n\n**Subagent-Driven Development:**\n- Review after EACH task\n- Catch issues before they compound\n- Fix before moving to next task\n\n**Executing Plans:**\n- Review after each batch (3 tasks)\n- Get feedback, apply, continue\n\n**Ad-Hoc Development:**\n- Review before merge\n- Review when stuck\n\n## Red Flags\n\n**Never:**\n- Skip review because \"it's simple\"\n- Ignore Critical issues\n- Proceed with unfixed Important issues\n- Argue with valid technical feedback\n\n**If reviewer wrong:**\n- Push back with technical reasoning\n- Show code/tests that prove it works\n- Request clarification\n\nSee template at: requesting-code-review/code-reviewer.md\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the requesting code review approach\n\n---\n*Converted from Claude Code Skill: requesting-code-review*\n*Source: requesting code review skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/requesting-code-review",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "requesting",
      "code",
      "review"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-requesting-code-review"
  },
  {
    "name": "cursorrules-root-cause-tracing",
    "description": "Cursor rules version of root-cause-tracing skill - ---",
    "content": "# Root Cause Tracing - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Root Cause Tracing\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this root cause tracing methodology:\n\n1. *What code directly causes this?**\n2. *What value was passed?**\n3. `projectDir = ''` (empty string!)\n4. Empty string as `cwd` resolves to `process.cwd()`\n5. That's the source code directory!\n6. *Where did empty string come from?**\n7. *Critical:** Use `console.error()` in tests (not logger - may not show)\n8. *Run and capture:**\n9. *Analyze stack traces:**\n10. Look for test file names\n11. Find the line number triggering the call\n12. Identify the pattern (same test? same parameter?)\n\n## Principles\n\n- *NEVER fix just where the error appears.** Trace back to find the original trigger.\n\n## Implementation Guidelines\n\n- *In tests:** Use `console.error()` not logger - logger may be suppressed\n- *Before operation:** Log before the dangerous operation, not after it fails\n- *Include context:** Directory, cwd, environment variables, timestamps\n- *Capture stack:** `new Error().stack` shows complete call chain\n- Found root cause through 5-level trace\n- Fixed at source (getter validation)\n- Added 4 layers of defense\n- 1847 tests passed, zero pollution\n\n\n## Examples\n\n- *Symptom:** `.git` created in `packages/core/` (source code)\n- *Trace chain:**\n- *Root cause:** Top-level variable initialization accessing empty value\n- *Fix:** Made tempDir a getter that throws if accessed before beforeEach\n- *Also added defense-in-depth:**\n- Layer 1: Project.create() validates directory\n- Layer 2: WorkspaceManager validates not empty\n- Layer 3: NODE_ENV guard refuses git init outside tmpdir\n- Layer 4: Stack trace logging before git init\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── root-cause-tracing.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: root-cause-tracing\ndescription: Use when errors occur deep in execution and you need to trace back to find the original trigger - systematically traces bugs backward through call stack, adding instrumentation when needed, to identify source of invalid data or incorrect behavior\n---\n\n# Root Cause Tracing\n\n## Overview\n\nBugs often manifest deep in the call stack (git init in wrong directory, file created in wrong location, database opened with wrong path). Your instinct is to fix where the error appears, but that's treating a symptom.\n\n**Core principle:** Trace backward through the call chain until you find the original trigger, then fix at the source.\n\n## When to Use\n\n```dot\ndigraph when_to_use {\n    \"Bug appears deep in stack?\" [shape=diamond];\n    \"Can trace backwards?\" [shape=diamond];\n    \"Fix at symptom point\" [shape=box];\n    \"Trace to original trigger\" [shape=box];\n    \"BETTER: Also add defense-in-depth\" [shape=box];\n\n    \"Bug appears deep in stack?\" -> \"Can trace backwards?\" [label=\"yes\"];\n    \"Can trace backwards?\" -> \"Trace to original trigger\" [label=\"yes\"];\n    \"Can trace backwards?\" -> \"Fix at symptom point\" [label=\"no - dead end\"];\n    \"Trace to original trigger\" -> \"BETTER: Also add defense-in-depth\";\n}\n```\n\n**Use when:**\n- Error happens deep in execution (not at entry point)\n- Stack trace shows long call chain\n- Unclear where invalid data originated\n- Need to find which test/code triggers the problem\n\n## The Tracing Process\n\n### 1. Observe the Symptom\n```\nError: git init failed in /Users/jesse/project/packages/core\n```\n\n### 2. Find Immediate Cause\n**What code directly causes this?**\n```typescript\nawait execFileAsync('git', ['init'], { cwd: projectDir });\n```\n\n### 3. Ask: What Called This?\n```typescript\nWorktreeManager.createSessionWorktree(projectDir, sessionId)\n  → called by Session.initializeWorkspace()\n  → called by Session.create()\n  → called by test at Project.create()\n```\n\n### 4. Keep Tracing Up\n**What value was passed?**\n- `projectDir = ''` (empty string!)\n- Empty string as `cwd` resolves to `process.cwd()`\n- That's the source code directory!\n\n### 5. Find Original Trigger\n**Where did empty string come from?**\n```typescript\nconst context = setupCoreTest(); // Returns { tempDir: '' }\nProject.create('name', context.tempDir); // Accessed before beforeEach!\n```\n\n## Adding Stack Traces\n\nWhen you can't trace manually, add instrumentation:\n\n```typescript\n// Before the problematic operation\nasync function gitInit(directory: string) {\n  const stack = new Error().stack;\n  console.error('DEBUG git init:', {\n    directory,\n    cwd: process.cwd(),\n    nodeEnv: process.env.NODE_ENV,\n    stack,\n  });\n\n  await execFileAsync('git', ['init'], { cwd: directory });\n}\n```\n\n**Critical:** Use `console.error()` in tests (not logger - may not show)\n\n**Run and capture:**\n```bash\nnpm test 2>&1 | grep 'DEBUG git init'\n```\n\n**Analyze stack traces:**\n- Look for test file names\n- Find the line number triggering the call\n- Identify the pattern (same test? same parameter?)\n\n## Finding Which Test Causes Pollution\n\nIf something appears during tests but you don't know which test:\n\nUse the bisection script: @find-polluter.sh\n\n```bash\n./find-polluter.sh '.git' 'src/**/*.test.ts'\n```\n\nRuns tests one-by-one, stops at first polluter. See script for usage.\n\n## Real Example: Empty projectDir\n\n**Symptom:** `.git` created in `packages/core/` (source code)\n\n**Trace chain:**\n1. `git init` runs in `process.cwd()` ← empty cwd parameter\n2. WorktreeManager called with empty projectDir\n3. Session.create() passed empty string\n4. Test accessed `context.tempDir` before beforeEach\n5. setupCoreTest() returns `{ tempDir: '' }` initially\n\n**Root cause:** Top-level variable initialization accessing empty value\n\n**Fix:** Made tempDir a getter that throws if accessed before beforeEach\n\n**Also added defense-in-depth:**\n- Layer 1: Project.create() validates directory\n- Layer 2: WorkspaceManager validates not empty\n- Layer 3: NODE_ENV guard refuses git init outside tmpdir\n- Layer 4: Stack trace logging before git init\n\n## Key Principle\n\n```dot\ndigraph principle {\n    \"Found immediate cause\" [shape=ellipse];\n    \"Can trace one level up?\" [shape=diamond];\n    \"Trace backwards\" [shape=box];\n    \"Is this the source?\" [shape=diamond];\n    \"Fix at source\" [shape=box];\n    \"Add validation at each layer\" [shape=box];\n    \"Bug impossible\" [shape=doublecircle];\n    \"NEVER fix just the symptom\" [shape=octagon, style=filled, fillcolor=red, fontcolor=white];\n\n    \"Found immediate cause\" -> \"Can trace one level up?\";\n    \"Can trace one level up?\" -> \"Trace backwards\" [label=\"yes\"];\n    \"Can trace one level up?\" -> \"NEVER fix just the symptom\" [label=\"no\"];\n    \"Trace backwards\" -> \"Is this the source?\";\n    \"Is this the source?\" -> \"Trace backwards\" [label=\"no - keeps going\"];\n    \"Is this the source?\" -> \"Fix at source\" [label=\"yes\"];\n    \"Fix at source\" -> \"Add validation at each layer\";\n    \"Add validation at each layer\" -> \"Bug impossible\";\n}\n```\n\n**NEVER fix just where the error appears.** Trace back to find the original trigger.\n\n## Stack Trace Tips\n\n**In tests:** Use `console.error()` not logger - logger may be suppressed\n**Before operation:** Log before the dangerous operation, not after it fails\n**Include context:** Directory, cwd, environment variables, timestamps\n**Capture stack:** `new Error().stack` shows complete call chain\n\n## Real-World Impact\n\nFrom debugging session (2025-10-03):\n- Found root cause through 5-level trace\n- Fixed at source (getter validation)\n- Added 4 layers of defense\n- 1847 tests passed, zero pollution\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the root cause tracing approach\n\n---\n*Converted from Claude Code Skill: root-cause-tracing*\n*Source: root cause tracing skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/root-cause-tracing",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "root",
      "cause",
      "tracing"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-root-cause-tracing"
  },
  {
    "name": "cursorrules-sharing-skills",
    "description": "Cursor rules version of sharing-skills skill - ---",
    "content": "# Sharing Skills - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Sharing Skills\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this sharing skills methodology:\n\n1. -repo upstream-org/upstream-repo \\\n2. -title \"Add ${skill_name} skill\" \\\n3. -body \"$(cat <<'EOF'\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n## Examples\n\n- -repo upstream-org/upstream-repo \\\n- -title \"Add async-patterns skill\" \\\n- -body \"## Summary\n- *\"gh: command not found\"**\n- Install GitHub CLI: https://cli.github.com/\n- Authenticate: `gh auth login`\n- *\"Permission denied (publickey)\"**\n- Check SSH keys: `gh auth status`\n- Set up SSH: https://docs.github.com/en/authentication\n- *\"Skill already exists\"**\n- You're creating a modified version\n- Consider different skill name or coordinate with the skill's maintainer\n- *PR merge conflicts**\n- Rebase on latest upstream: `git fetch upstream && git rebase upstream/main`\n- Resolve conflicts\n- Force push: `git push -f origin your-branch`\n- *Do NOT batch multiple skills in one PR.**\n- Have its own feature branch\n- Have its own PR\n- Be independently reviewable\n- *Why?** Individual skills can be reviewed, iterated, and merged independently.\n- **writing-skills** - REQUIRED: How to create well-tested skills before sharing\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── sharing-skills.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: sharing-skills\ndescription: Use when you've developed a broadly useful skill and want to contribute it upstream via pull request - guides process of branching, committing, pushing, and creating PR to contribute skills back to upstream repository\n---\n\n# Sharing Skills\n\n## Overview\n\nContribute skills from your local branch back to the upstream repository.\n\n**Workflow:** Branch → Edit/Create skill → Commit → Push → PR\n\n## When to Share\n\n**Share when:**\n- Skill applies broadly (not project-specific)\n- Pattern/technique others would benefit from\n- Well-tested and documented\n- Follows writing-skills guidelines\n\n**Keep personal when:**\n- Project-specific or organization-specific\n- Experimental or unstable\n- Contains sensitive information\n- Too narrow/niche for general use\n\n## Prerequisites\n\n- `gh` CLI installed and authenticated\n- Working directory is `~/.config/superpowers/skills/` (your local clone)\n- **REQUIRED:** Skill has been tested using writing-skills TDD process\n\n## Sharing Workflow\n\n### 1. Ensure You're on Main and Synced\n\n```bash\ncd ~/.config/superpowers/skills/\ngit checkout main\ngit pull upstream main\ngit push origin main  # Push to your fork\n```\n\n### 2. Create Feature Branch\n\n```bash\n# Branch name: add-skillname-skill\nskill_name=\"your-skill-name\"\ngit checkout -b \"add-${skill_name}-skill\"\n```\n\n### 3. Create or Edit Skill\n\n```bash\n# Work on your skill in skills/\n# Create new skill or edit existing one\n# Skill should be in skills/category/skill-name/SKILL.md\n```\n\n### 4. Commit Changes\n\n```bash\n# Add and commit\ngit add skills/your-skill-name/\ngit commit -m \"Add ${skill_name} skill\n\n$(cat <<'EOF'\nBrief description of what this skill does and why it's useful.\n\nTested with: [describe testing approach]\nEOF\n)\"\n```\n\n### 5. Push to Your Fork\n\n```bash\ngit push -u origin \"add-${skill_name}-skill\"\n```\n\n### 6. Create Pull Request\n\n```bash\n# Create PR to upstream using gh CLI\ngh pr create \\\n  --repo upstream-org/upstream-repo \\\n  --title \"Add ${skill_name} skill\" \\\n  --body \"$(cat <<'EOF'\n## Summary\nBrief description of the skill and what problem it solves.\n\n## Testing\nDescribe how you tested this skill (pressure scenarios, baseline tests, etc.).\n\n## Context\nAny additional context about why this skill is needed and how it should be used.\nEOF\n)\"\n```\n\n## Complete Example\n\nHere's a complete example of sharing a skill called \"async-patterns\":\n\n```bash\n# 1. Sync with upstream\ncd ~/.config/superpowers/skills/\ngit checkout main\ngit pull upstream main\ngit push origin main\n\n# 2. Create branch\ngit checkout -b \"add-async-patterns-skill\"\n\n# 3. Create/edit the skill\n# (Work on skills/async-patterns/SKILL.md)\n\n# 4. Commit\ngit add skills/async-patterns/\ngit commit -m \"Add async-patterns skill\n\nPatterns for handling asynchronous operations in tests and application code.\n\nTested with: Multiple pressure scenarios testing agent compliance.\"\n\n# 5. Push\ngit push -u origin \"add-async-patterns-skill\"\n\n# 6. Create PR\ngh pr create \\\n  --repo upstream-org/upstream-repo \\\n  --title \"Add async-patterns skill\" \\\n  --body \"## Summary\nPatterns for handling asynchronous operations correctly in tests and application code.\n\n## Testing\nTested with multiple application scenarios. Agents successfully apply patterns to new code.\n\n## Context\nAddresses common async pitfalls like race conditions, improper error handling, and timing issues.\"\n```\n\n## After PR is Merged\n\nOnce your PR is merged:\n\n1. Sync your local main branch:\n```bash\ncd ~/.config/superpowers/skills/\ngit checkout main\ngit pull upstream main\ngit push origin main\n```\n\n2. Delete the feature branch:\n```bash\ngit branch -d \"add-${skill_name}-skill\"\ngit push origin --delete \"add-${skill_name}-skill\"\n```\n\n## Troubleshooting\n\n**\"gh: command not found\"**\n- Install GitHub CLI: https://cli.github.com/\n- Authenticate: `gh auth login`\n\n**\"Permission denied (publickey)\"**\n- Check SSH keys: `gh auth status`\n- Set up SSH: https://docs.github.com/en/authentication\n\n**\"Skill already exists\"**\n- You're creating a modified version\n- Consider different skill name or coordinate with the skill's maintainer\n\n**PR merge conflicts**\n- Rebase on latest upstream: `git fetch upstream && git rebase upstream/main`\n- Resolve conflicts\n- Force push: `git push -f origin your-branch`\n\n## Multi-Skill Contributions\n\n**Do NOT batch multiple skills in one PR.**\n\nEach skill should:\n- Have its own feature branch\n- Have its own PR\n- Be independently reviewable\n\n**Why?** Individual skills can be reviewed, iterated, and merged independently.\n\n## Related Skills\n\n- **writing-skills** - REQUIRED: How to create well-tested skills before sharing\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the sharing skills approach\n\n---\n*Converted from Claude Code Skill: sharing-skills*\n*Source: sharing skills skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/sharing-skills",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "sharing",
      "skills"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-sharing-skills"
  },
  {
    "name": "cursorrules-subagent-driven-development",
    "description": "Cursor rules version of subagent-driven-development skill - ---",
    "content": "# Subagent Driven Development - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Subagent Driven Development\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this subagent driven development methodology:\n\n1. *Dispatch fresh subagent:**\n2. *Subagent reports back** with summary of work.\n3. *Dispatch code-reviewer subagent:**\n4. *Code reviewer returns:** Strengths, Issues (Critical/Important/Minor), Assessment\n5. *If issues found:**\n6. Fix Critical issues immediately\n7. Fix Important issues before next task\n8. Note Minor issues\n9. *Dispatch follow-up subagent if needed:**\n10. Mark task as completed in TodoWrite\n11. Move to next task\n12. Repeat steps 2-5\n13. Reviews entire implementation\n14. Checks all plan requirements met\n15. Validates overall architecture\n16. Announce: \"I'm using the finishing-a-development-branch skill to complete this work.\"\n17. **REQUIRED SUB-SKILL:** Use superpowers:finishing-a-development-branch\n18. Follow that skill to verify tests, present options, execute choice\n19. *vs. Manual execution:**\n20. Subagents follow TDD naturally\n21. Fresh context per task (no confusion)\n22. Parallel-safe (subagents don't interfere)\n23. *vs. Executing Plans:**\n24. Same session (no handoff)\n25. Continuous progress (no waiting)\n26. Review checkpoints automatic\n27. *Cost:**\n28. More subagent invocations\n29. But catches issues early (cheaper than debugging later)\n30. *Never:**\n31. Skip code review between tasks\n32. Proceed with unfixed Critical issues\n33. Dispatch multiple implementation subagents in parallel (conflicts)\n34. Implement without reading plan task\n35. *If subagent fails task:**\n36. Dispatch fix subagent with specific instructions\n37. Don't try to fix manually (context pollution)\n38. *Required workflow skills:**\n39. **writing-plans** - REQUIRED: Creates the plan that this skill executes\n40. **requesting-code-review** - REQUIRED: Review after each task (see Step 3)\n41. **finishing-a-development-branch** - REQUIRED: Complete development after all tasks (see Step 7)\n42. *Subagents must use:**\n43. **test-driven-development** - Subagents follow TDD for each task\n44. *Alternative workflow:**\n45. **executing-plans** - Use for parallel session instead of same-session execution\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── subagent-driven-development.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: subagent-driven-development\ndescription: Use when executing implementation plans with independent tasks in the current session - dispatches fresh subagent for each task with code review between tasks, enabling fast iteration with quality gates\n---\n\n# Subagent-Driven Development\n\nExecute plan by dispatching fresh subagent per task, with code review after each.\n\n**Core principle:** Fresh subagent per task + review between tasks = high quality, fast iteration\n\n## Overview\n\n**vs. Executing Plans (parallel session):**\n- Same session (no context switch)\n- Fresh subagent per task (no context pollution)\n- Code review after each task (catch issues early)\n- Faster iteration (no human-in-loop between tasks)\n\n**When to use:**\n- Staying in this session\n- Tasks are mostly independent\n- Want continuous progress with quality gates\n\n**When NOT to use:**\n- Need to review plan first (use executing-plans)\n- Tasks are tightly coupled (manual execution better)\n- Plan needs revision (brainstorm first)\n\n## The Process\n\n### 1. Load Plan\n\nRead plan file, create TodoWrite with all tasks.\n\n### 2. Execute Task with Subagent\n\nFor each task:\n\n**Dispatch fresh subagent:**\n```\nTask tool (general-purpose):\n  description: \"Implement Task N: [task name]\"\n  prompt: |\n    You are implementing Task N from [plan-file].\n\n    Read that task carefully. Your job is to:\n    1. Implement exactly what the task specifies\n    2. Write tests (following TDD if task says to)\n    3. Verify implementation works\n    4. Commit your work\n    5. Report back\n\n    Work from: [directory]\n\n    Report: What you implemented, what you tested, test results, files changed, any issues\n```\n\n**Subagent reports back** with summary of work.\n\n### 3. Review Subagent's Work\n\n**Dispatch code-reviewer subagent:**\n```\nTask tool (code-reviewer):\n  Use template at requesting-code-review/code-reviewer.md\n\n  WHAT_WAS_IMPLEMENTED: [from subagent's report]\n  PLAN_OR_REQUIREMENTS: Task N from [plan-file]\n  BASE_SHA: [commit before task]\n  HEAD_SHA: [current commit]\n  DESCRIPTION: [task summary]\n```\n\n**Code reviewer returns:** Strengths, Issues (Critical/Important/Minor), Assessment\n\n### 4. Apply Review Feedback\n\n**If issues found:**\n- Fix Critical issues immediately\n- Fix Important issues before next task\n- Note Minor issues\n\n**Dispatch follow-up subagent if needed:**\n```\n\"Fix issues from code review: [list issues]\"\n```\n\n### 5. Mark Complete, Next Task\n\n- Mark task as completed in TodoWrite\n- Move to next task\n- Repeat steps 2-5\n\n### 6. Final Review\n\nAfter all tasks complete, dispatch final code-reviewer:\n- Reviews entire implementation\n- Checks all plan requirements met\n- Validates overall architecture\n\n### 7. Complete Development\n\nAfter final review passes:\n- Announce: \"I'm using the finishing-a-development-branch skill to complete this work.\"\n- **REQUIRED SUB-SKILL:** Use superpowers:finishing-a-development-branch\n- Follow that skill to verify tests, present options, execute choice\n\n## Example Workflow\n\n```\nYou: I'm using Subagent-Driven Development to execute this plan.\n\n[Load plan, create TodoWrite]\n\nTask 1: Hook installation script\n\n[Dispatch implementation subagent]\nSubagent: Implemented install-hook with tests, 5/5 passing\n\n[Get git SHAs, dispatch code-reviewer]\nReviewer: Strengths: Good test coverage. Issues: None. Ready.\n\n[Mark Task 1 complete]\n\nTask 2: Recovery modes\n\n[Dispatch implementation subagent]\nSubagent: Added verify/repair, 8/8 tests passing\n\n[Dispatch code-reviewer]\nReviewer: Strengths: Solid. Issues (Important): Missing progress reporting\n\n[Dispatch fix subagent]\nFix subagent: Added progress every 100 conversations\n\n[Verify fix, mark Task 2 complete]\n\n...\n\n[After all tasks]\n[Dispatch final code-reviewer]\nFinal reviewer: All requirements met, ready to merge\n\nDone!\n```\n\n## Advantages\n\n**vs. Manual execution:**\n- Subagents follow TDD naturally\n- Fresh context per task (no confusion)\n- Parallel-safe (subagents don't interfere)\n\n**vs. Executing Plans:**\n- Same session (no handoff)\n- Continuous progress (no waiting)\n- Review checkpoints automatic\n\n**Cost:**\n- More subagent invocations\n- But catches issues early (cheaper than debugging later)\n\n## Red Flags\n\n**Never:**\n- Skip code review between tasks\n- Proceed with unfixed Critical issues\n- Dispatch multiple implementation subagents in parallel (conflicts)\n- Implement without reading plan task\n\n**If subagent fails task:**\n- Dispatch fix subagent with specific instructions\n- Don't try to fix manually (context pollution)\n\n## Integration\n\n**Required workflow skills:**\n- **writing-plans** - REQUIRED: Creates the plan that this skill executes\n- **requesting-code-review** - REQUIRED: Review after each task (see Step 3)\n- **finishing-a-development-branch** - REQUIRED: Complete development after all tasks (see Step 7)\n\n**Subagents must use:**\n- **test-driven-development** - Subagents follow TDD for each task\n\n**Alternative workflow:**\n- **executing-plans** - Use for parallel session instead of same-session execution\n\nSee code-reviewer template: requesting-code-review/code-reviewer.md\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the subagent driven development approach\n\n---\n*Converted from Claude Code Skill: subagent-driven-development*\n*Source: subagent driven development skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/subagent-driven-development",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "subagent",
      "driven",
      "development"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-subagent-driven-development"
  },
  {
    "name": "cursorrules-systematic-debugging",
    "description": "Cursor rules version of systematic-debugging skill - ---",
    "content": "# Systematic Debugging - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Systematic Debugging\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this systematic debugging methodology:\n\n1. \"Quick fix for now, investigate later\"\n2. \"Just try changing X and see if it works\"\n3. \"Add multiple changes, run tests\"\n4. \"Skip the test, I'll manually verify\"\n5. \"It's probably X, let me fix that\"\n6. \"I don't fully understand but this might work\"\n7. \"Pattern says X but I'll adapt it differently\"\n8. \"Here are the main problems: [lists fixes without investigation]\"\n9. Proposing solutions before tracing data flow\n10. **\"One more fix attempt\" (when already tried 2+)**\n11. **Each fix reveals new problem in different place**\n12. *ALL of these mean: STOP. Return to Phase 1.**\n13. *If 3+ fixes failed:** Question the architecture (see Phase 4.5)\n14. *Watch for these redirections:**\n15. \"Is that not happening?\" - You assumed without verifying\n16. \"Will it show us...?\" - You should have added evidence gathering\n17. \"Stop guessing\" - You're proposing fixes without understanding\n18. \"Ultrathink this\" - Question fundamentals, not just symptoms\n19. \"We're stuck?\" (frustrated) - Your approach isn't working\n20. *When you see these:** STOP. Return to Phase 1.\n21. *But:** 95% of \"no root cause\" cases are incomplete investigation.\n22. *This skill requires using:**\n23. **root-cause-tracing** - REQUIRED when error is deep in call stack (see Phase 1, Step 5)\n24. **test-driven-development** - REQUIRED for creating failing test case (see Phase 4, Step 1)\n25. *Complementary skills:**\n26. **defense-in-depth** - Add validation at multiple layers after finding root cause\n27. **condition-based-waiting** - Replace arbitrary timeouts identified in Phase 2\n28. **verification-before-completion** - Verify fix worked before claiming success\n29. Systematic approach: 15-30 minutes to fix\n30. Random fixes approach: 2-3 hours of thrashing\n31. First-time fix rate: 95% vs 40%\n32. New bugs introduced: Near zero vs common\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── systematic-debugging.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: systematic-debugging\ndescription: Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes - four-phase framework (root cause investigation, pattern analysis, hypothesis testing, implementation) that ensures understanding before attempting solutions\n---\n\n# Systematic Debugging\n\n## Overview\n\nRandom fixes waste time and create new bugs. Quick patches mask underlying issues.\n\n**Core principle:** ALWAYS find root cause before attempting fixes. Symptom fixes are failure.\n\n**Violating the letter of this process is violating the spirit of debugging.**\n\n## The Iron Law\n\n```\nNO FIXES WITHOUT ROOT CAUSE INVESTIGATION FIRST\n```\n\nIf you haven't completed Phase 1, you cannot propose fixes.\n\n## When to Use\n\nUse for ANY technical issue:\n- Test failures\n- Bugs in production\n- Unexpected behavior\n- Performance problems\n- Build failures\n- Integration issues\n\n**Use this ESPECIALLY when:**\n- Under time pressure (emergencies make guessing tempting)\n- \"Just one quick fix\" seems obvious\n- You've already tried multiple fixes\n- Previous fix didn't work\n- You don't fully understand the issue\n\n**Don't skip when:**\n- Issue seems simple (simple bugs have root causes too)\n- You're in a hurry (rushing guarantees rework)\n- Manager wants it fixed NOW (systematic is faster than thrashing)\n\n## The Four Phases\n\nYou MUST complete each phase before proceeding to the next.\n\n### Phase 1: Root Cause Investigation\n\n**BEFORE attempting ANY fix:**\n\n1. **Read Error Messages Carefully**\n   - Don't skip past errors or warnings\n   - They often contain the exact solution\n   - Read stack traces completely\n   - Note line numbers, file paths, error codes\n\n2. **Reproduce Consistently**\n   - Can you trigger it reliably?\n   - What are the exact steps?\n   - Does it happen every time?\n   - If not reproducible → gather more data, don't guess\n\n3. **Check Recent Changes**\n   - What changed that could cause this?\n   - Git diff, recent commits\n   - New dependencies, config changes\n   - Environmental differences\n\n4. **Gather Evidence in Multi-Component Systems**\n\n   **WHEN system has multiple components (CI → build → signing, API → service → database):**\n\n   **BEFORE proposing fixes, add diagnostic instrumentation:**\n   ```\n   For EACH component boundary:\n     - Log what data enters component\n     - Log what data exits component\n     - Verify environment/config propagation\n     - Check state at each layer\n\n   Run once to gather evidence showing WHERE it breaks\n   THEN analyze evidence to identify failing component\n   THEN investigate that specific component\n   ```\n\n   **Example (multi-layer system):**\n   ```bash\n   # Layer 1: Workflow\n   echo \"=== Secrets available in workflow: ===\"\n   echo \"IDENTITY: ${IDENTITY:+SET}${IDENTITY:-UNSET}\"\n\n   # Layer 2: Build script\n   echo \"=== Env vars in build script: ===\"\n   env | grep IDENTITY || echo \"IDENTITY not in environment\"\n\n   # Layer 3: Signing script\n   echo \"=== Keychain state: ===\"\n   security list-keychains\n   security find-identity -v\n\n   # Layer 4: Actual signing\n   codesign --sign \"$IDENTITY\" --verbose=4 \"$APP\"\n   ```\n\n   **This reveals:** Which layer fails (secrets → workflow ✓, workflow → build ✗)\n\n5. **Trace Data Flow**\n\n   **WHEN error is deep in call stack:**\n\n   **REQUIRED SUB-SKILL:** Use superpowers:root-cause-tracing for backward tracing technique\n\n   **Quick version:**\n   - Where does bad value originate?\n   - What called this with bad value?\n   - Keep tracing up until you find the source\n   - Fix at source, not at symptom\n\n### Phase 2: Pattern Analysis\n\n**Find the pattern before fixing:**\n\n1. **Find Working Examples**\n   - Locate similar working code in same codebase\n   - What works that's similar to what's broken?\n\n2. **Compare Against References**\n   - If implementing pattern, read reference implementation COMPLETELY\n   - Don't skim - read every line\n   - Understand the pattern fully before applying\n\n3. **Identify Differences**\n   - What's different between working and broken?\n   - List every difference, however small\n   - Don't assume \"that can't matter\"\n\n4. **Understand Dependencies**\n   - What other components does this need?\n   - What settings, config, environment?\n   - What assumptions does it make?\n\n### Phase 3: Hypothesis and Testing\n\n**Scientific method:**\n\n1. **Form Single Hypothesis**\n   - State clearly: \"I think X is the root cause because Y\"\n   - Write it down\n   - Be specific, not vague\n\n2. **Test Minimally**\n   - Make the SMALLEST possible change to test hypothesis\n   - One variable at a time\n   - Don't fix multiple things at once\n\n3. **Verify Before Continuing**\n   - Did it work? Yes → Phase 4\n   - Didn't work? Form NEW hypothesis\n   - DON'T add more fixes on top\n\n4. **When You Don't Know**\n   - Say \"I don't understand X\"\n   - Don't pretend to know\n   - Ask for help\n   - Research more\n\n### Phase 4: Implementation\n\n**Fix the root cause, not the symptom:**\n\n1. **Create Failing Test Case**\n   - Simplest possible reproduction\n   - Automated test if possible\n   - One-off test script if no framework\n   - MUST have before fixing\n   - **REQUIRED SUB-SKILL:** Use superpowers:test-driven-development for writing proper failing tests\n\n2. **Implement Single Fix**\n   - Address the root cause identified\n   - ONE change at a time\n   - No \"while I'm here\" improvements\n   - No bundled refactoring\n\n3. **Verify Fix**\n   - Test passes now?\n   - No other tests broken?\n   - Issue actually resolved?\n\n4. **If Fix Doesn't Work**\n   - STOP\n   - Count: How many fixes have you tried?\n   - If < 3: Return to Phase 1, re-analyze with new information\n   - **If ≥ 3: STOP and question the architecture (step 5 below)**\n   - DON'T attempt Fix #4 without architectural discussion\n\n5. **If 3+ Fixes Failed: Question Architecture**\n\n   **Pattern indicating architectural problem:**\n   - Each fix reveals new shared state/coupling/problem in different place\n   - Fixes require \"massive refactoring\" to implement\n   - Each fix creates new symptoms elsewhere\n\n   **STOP and question fundamentals:**\n   - Is this pattern fundamentally sound?\n   - Are we \"sticking with it through sheer inertia\"?\n   - Should we refactor architecture vs. continue fixing symptoms?\n\n   **Discuss with your human partner before attempting more fixes**\n\n   This is NOT a failed hypothesis - this is a wrong architecture.\n\n## Red Flags - STOP and Follow Process\n\nIf you catch yourself thinking:\n- \"Quick fix for now, investigate later\"\n- \"Just try changing X and see if it works\"\n- \"Add multiple changes, run tests\"\n- \"Skip the test, I'll manually verify\"\n- \"It's probably X, let me fix that\"\n- \"I don't fully understand but this might work\"\n- \"Pattern says X but I'll adapt it differently\"\n- \"Here are the main problems: [lists fixes without investigation]\"\n- Proposing solutions before tracing data flow\n- **\"One more fix attempt\" (when already tried 2+)**\n- **Each fix reveals new problem in different place**\n\n**ALL of these mean: STOP. Return to Phase 1.**\n\n**If 3+ fixes failed:** Question the architecture (see Phase 4.5)\n\n## your human partner's Signals You're Doing It Wrong\n\n**Watch for these redirections:**\n- \"Is that not happening?\" - You assumed without verifying\n- \"Will it show us...?\" - You should have added evidence gathering\n- \"Stop guessing\" - You're proposing fixes without understanding\n- \"Ultrathink this\" - Question fundamentals, not just symptoms\n- \"We're stuck?\" (frustrated) - Your approach isn't working\n\n**When you see these:** STOP. Return to Phase 1.\n\n## Common Rationalizations\n\n| Excuse | Reality |\n|--------|---------|\n| \"Issue is simple, don't need process\" | Simple issues have root causes too. Process is fast for simple bugs. |\n| \"Emergency, no time for process\" | Systematic debugging is FASTER than guess-and-check thrashing. |\n| \"Just try this first, then investigate\" | First fix sets the pattern. Do it right from the start. |\n| \"I'll write test after confirming fix works\" | Untested fixes don't stick. Test first proves it. |\n| \"Multiple fixes at once saves time\" | Can't isolate what worked. Causes new bugs. |\n| \"Reference too long, I'll adapt the pattern\" | Partial understanding guarantees bugs. Read it completely. |\n| \"I see the problem, let me fix it\" | Seeing symptoms ≠ understanding root cause. |\n| \"One more fix attempt\" (after 2+ failures) | 3+ failures = architectural problem. Question pattern, don't fix again. |\n\n## Quick Reference\n\n| Phase | Key Activities | Success Criteria |\n|-------|---------------|------------------|\n| **1. Root Cause** | Read errors, reproduce, check changes, gather evidence | Understand WHAT and WHY |\n| **2. Pattern** | Find working examples, compare | Identify differences |\n| **3. Hypothesis** | Form theory, test minimally | Confirmed or new hypothesis |\n| **4. Implementation** | Create test, fix, verify | Bug resolved, tests pass |\n\n## When Process Reveals \"No Root Cause\"\n\nIf systematic investigation reveals issue is truly environmental, timing-dependent, or external:\n\n1. You've completed the process\n2. Document what you investigated\n3. Implement appropriate handling (retry, timeout, error message)\n4. Add monitoring/logging for future investigation\n\n**But:** 95% of \"no root cause\" cases are incomplete investigation.\n\n## Integration with Other Skills\n\n**This skill requires using:**\n- **root-cause-tracing** - REQUIRED when error is deep in call stack (see Phase 1, Step 5)\n- **test-driven-development** - REQUIRED for creating failing test case (see Phase 4, Step 1)\n\n**Complementary skills:**\n- **defense-in-depth** - Add validation at multiple layers after finding root cause\n- **condition-based-waiting** - Replace arbitrary timeouts identified in Phase 2\n- **verification-before-completion** - Verify fix worked before claiming success\n\n## Real-World Impact\n\nFrom debugging sessions:\n- Systematic approach: 15-30 minutes to fix\n- Random fixes approach: 2-3 hours of thrashing\n- First-time fix rate: 95% vs 40%\n- New bugs introduced: Near zero vs common\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the systematic debugging approach\n\n---\n*Converted from Claude Code Skill: systematic-debugging*\n*Source: systematic debugging skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/systematic-debugging",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "systematic",
      "debugging"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-systematic-debugging"
  },
  {
    "name": "cursorrules-test-driven-development",
    "description": "Cursor rules version of test-driven-development skill - ---",
    "content": "# Test Driven Development - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Test Driven Development\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this test driven development methodology:\n\nFollow the principles outlined below.\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n## Examples\n\n- *Bug:** Empty email accepted\n- *RED**\n- *Verify RED**\n- *GREEN**\n- *Verify GREEN**\n- *REFACTOR**\n- [ ] Every new function/method has a test\n- [ ] Watched each test fail before implementing\n- [ ] Each test failed for expected reason (feature missing, not typo)\n- [ ] Wrote minimal code to pass each test\n- [ ] All tests pass\n- [ ] Output pristine (no errors, warnings)\n- [ ] Tests use real code (mocks only if unavoidable)\n- [ ] Edge cases and errors covered\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── test-driven-development.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: test-driven-development\ndescription: Use when implementing any feature or bugfix, before writing implementation code - write the test first, watch it fail, write minimal code to pass; ensures tests actually verify behavior by requiring failure first\n---\n\n# Test-Driven Development (TDD)\n\n## Overview\n\nWrite the test first. Watch it fail. Write minimal code to pass.\n\n**Core principle:** If you didn't watch the test fail, you don't know if it tests the right thing.\n\n**Violating the letter of the rules is violating the spirit of the rules.**\n\n## When to Use\n\n**Always:**\n- New features\n- Bug fixes\n- Refactoring\n- Behavior changes\n\n**Exceptions (ask your human partner):**\n- Throwaway prototypes\n- Generated code\n- Configuration files\n\nThinking \"skip TDD just this once\"? Stop. That's rationalization.\n\n## The Iron Law\n\n```\nNO PRODUCTION CODE WITHOUT A FAILING TEST FIRST\n```\n\nWrite code before the test? Delete it. Start over.\n\n**No exceptions:**\n- Don't keep it as \"reference\"\n- Don't \"adapt\" it while writing tests\n- Don't look at it\n- Delete means delete\n\nImplement fresh from tests. Period.\n\n## Red-Green-Refactor\n\n```dot\ndigraph tdd_cycle {\n    rankdir=LR;\n    red [label=\"RED\\nWrite failing test\", shape=box, style=filled, fillcolor=\"#ffcccc\"];\n    verify_red [label=\"Verify fails\\ncorrectly\", shape=diamond];\n    green [label=\"GREEN\\nMinimal code\", shape=box, style=filled, fillcolor=\"#ccffcc\"];\n    verify_green [label=\"Verify passes\\nAll green\", shape=diamond];\n    refactor [label=\"REFACTOR\\nClean up\", shape=box, style=filled, fillcolor=\"#ccccff\"];\n    next [label=\"Next\", shape=ellipse];\n\n    red -> verify_red;\n    verify_red -> green [label=\"yes\"];\n    verify_red -> red [label=\"wrong\\nfailure\"];\n    green -> verify_green;\n    verify_green -> refactor [label=\"yes\"];\n    verify_green -> green [label=\"no\"];\n    refactor -> verify_green [label=\"stay\\ngreen\"];\n    verify_green -> next;\n    next -> red;\n}\n```\n\n### RED - Write Failing Test\n\nWrite one minimal test showing what should happen.\n\n<Good>\n```typescript\ntest('retries failed operations 3 times', async () => {\n  let attempts = 0;\n  const operation = () => {\n    attempts++;\n    if (attempts < 3) throw new Error('fail');\n    return 'success';\n  };\n\n  const result = await retryOperation(operation);\n\n  expect(result).toBe('success');\n  expect(attempts).toBe(3);\n});\n```\nClear name, tests real behavior, one thing\n</Good>\n\n<Bad>\n```typescript\ntest('retry works', async () => {\n  const mock = jest.fn()\n    .mockRejectedValueOnce(new Error())\n    .mockRejectedValueOnce(new Error())\n    .mockResolvedValueOnce('success');\n  await retryOperation(mock);\n  expect(mock).toHaveBeenCalledTimes(3);\n});\n```\nVague name, tests mock not code\n</Bad>\n\n**Requirements:**\n- One behavior\n- Clear name\n- Real code (no mocks unless unavoidable)\n\n### Verify RED - Watch It Fail\n\n**MANDATORY. Never skip.**\n\n```bash\nnpm test path/to/test.test.ts\n```\n\nConfirm:\n- Test fails (not errors)\n- Failure message is expected\n- Fails because feature missing (not typos)\n\n**Test passes?** You're testing existing behavior. Fix test.\n\n**Test errors?** Fix error, re-run until it fails correctly.\n\n### GREEN - Minimal Code\n\nWrite simplest code to pass the test.\n\n<Good>\n```typescript\nasync function retryOperation<T>(fn: () => Promise<T>): Promise<T> {\n  for (let i = 0; i < 3; i++) {\n    try {\n      return await fn();\n    } catch (e) {\n      if (i === 2) throw e;\n    }\n  }\n  throw new Error('unreachable');\n}\n```\nJust enough to pass\n</Good>\n\n<Bad>\n```typescript\nasync function retryOperation<T>(\n  fn: () => Promise<T>,\n  options?: {\n    maxRetries?: number;\n    backoff?: 'linear' | 'exponential';\n    onRetry?: (attempt: number) => void;\n  }\n): Promise<T> {\n  // YAGNI\n}\n```\nOver-engineered\n</Bad>\n\nDon't add features, refactor other code, or \"improve\" beyond the test.\n\n### Verify GREEN - Watch It Pass\n\n**MANDATORY.**\n\n```bash\nnpm test path/to/test.test.ts\n```\n\nConfirm:\n- Test passes\n- Other tests still pass\n- Output pristine (no errors, warnings)\n\n**Test fails?** Fix code, not test.\n\n**Other tests fail?** Fix now.\n\n### REFACTOR - Clean Up\n\nAfter green only:\n- Remove duplication\n- Improve names\n- Extract helpers\n\nKeep tests green. Don't add behavior.\n\n### Repeat\n\nNext failing test for next feature.\n\n## Good Tests\n\n| Quality | Good | Bad |\n|---------|------|-----|\n| **Minimal** | One thing. \"and\" in name? Split it. | `test('validates email and domain and whitespace')` |\n| **Clear** | Name describes behavior | `test('test1')` |\n| **Shows intent** | Demonstrates desired API | Obscures what code should do |\n\n## Why Order Matters\n\n**\"I'll write tests after to verify it works\"**\n\nTests written after code pass immediately. Passing immediately proves nothing:\n- Might test wrong thing\n- Might test implementation, not behavior\n- Might miss edge cases you forgot\n- You never saw it catch the bug\n\nTest-first forces you to see the test fail, proving it actually tests something.\n\n**\"I already manually tested all the edge cases\"**\n\nManual testing is ad-hoc. You think you tested everything but:\n- No record of what you tested\n- Can't re-run when code changes\n- Easy to forget cases under pressure\n- \"It worked when I tried it\" ≠ comprehensive\n\nAutomated tests are systematic. They run the same way every time.\n\n**\"Deleting X hours of work is wasteful\"**\n\nSunk cost fallacy. The time is already gone. Your choice now:\n- Delete and rewrite with TDD (X more hours, high confidence)\n- Keep it and add tests after (30 min, low confidence, likely bugs)\n\nThe \"waste\" is keeping code you can't trust. Working code without real tests is technical debt.\n\n**\"TDD is dogmatic, being pragmatic means adapting\"**\n\nTDD IS pragmatic:\n- Finds bugs before commit (faster than debugging after)\n- Prevents regressions (tests catch breaks immediately)\n- Documents behavior (tests show how to use code)\n- Enables refactoring (change freely, tests catch breaks)\n\n\"Pragmatic\" shortcuts = debugging in production = slower.\n\n**\"Tests after achieve the same goals - it's spirit not ritual\"**\n\nNo. Tests-after answer \"What does this do?\" Tests-first answer \"What should this do?\"\n\nTests-after are biased by your implementation. You test what you built, not what's required. You verify remembered edge cases, not discovered ones.\n\nTests-first force edge case discovery before implementing. Tests-after verify you remembered everything (you didn't).\n\n30 minutes of tests after ≠ TDD. You get coverage, lose proof tests work.\n\n## Common Rationalizations\n\n| Excuse | Reality |\n|--------|---------|\n| \"Too simple to test\" | Simple code breaks. Test takes 30 seconds. |\n| \"I'll test after\" | Tests passing immediately prove nothing. |\n| \"Tests after achieve same goals\" | Tests-after = \"what does this do?\" Tests-first = \"what should this do?\" |\n| \"Already manually tested\" | Ad-hoc ≠ systematic. No record, can't re-run. |\n| \"Deleting X hours is wasteful\" | Sunk cost fallacy. Keeping unverified code is technical debt. |\n| \"Keep as reference, write tests first\" | You'll adapt it. That's testing after. Delete means delete. |\n| \"Need to explore first\" | Fine. Throw away exploration, start with TDD. |\n| \"Test hard = design unclear\" | Listen to test. Hard to test = hard to use. |\n| \"TDD will slow me down\" | TDD faster than debugging. Pragmatic = test-first. |\n| \"Manual test faster\" | Manual doesn't prove edge cases. You'll re-test every change. |\n| \"Existing code has no tests\" | You're improving it. Add tests for existing code. |\n\n## Red Flags - STOP and Start Over\n\n- Code before test\n- Test after implementation\n- Test passes immediately\n- Can't explain why test failed\n- Tests added \"later\"\n- Rationalizing \"just this once\"\n- \"I already manually tested it\"\n- \"Tests after achieve the same purpose\"\n- \"It's about spirit not ritual\"\n- \"Keep as reference\" or \"adapt existing code\"\n- \"Already spent X hours, deleting is wasteful\"\n- \"TDD is dogmatic, I'm being pragmatic\"\n- \"This is different because...\"\n\n**All of these mean: Delete code. Start over with TDD.**\n\n## Example: Bug Fix\n\n**Bug:** Empty email accepted\n\n**RED**\n```typescript\ntest('rejects empty email', async () => {\n  const result = await submitForm({ email: '' });\n  expect(result.error).toBe('Email required');\n});\n```\n\n**Verify RED**\n```bash\n$ npm test\nFAIL: expected 'Email required', got undefined\n```\n\n**GREEN**\n```typescript\nfunction submitForm(data: FormData) {\n  if (!data.email?.trim()) {\n    return { error: 'Email required' };\n  }\n  // ...\n}\n```\n\n**Verify GREEN**\n```bash\n$ npm test\nPASS\n```\n\n**REFACTOR**\nExtract validation for multiple fields if needed.\n\n## Verification Checklist\n\nBefore marking work complete:\n\n- [ ] Every new function/method has a test\n- [ ] Watched each test fail before implementing\n- [ ] Each test failed for expected reason (feature missing, not typo)\n- [ ] Wrote minimal code to pass each test\n- [ ] All tests pass\n- [ ] Output pristine (no errors, warnings)\n- [ ] Tests use real code (mocks only if unavoidable)\n- [ ] Edge cases and errors covered\n\nCan't check all boxes? You skipped TDD. Start over.\n\n## When Stuck\n\n| Problem | Solution |\n|---------|----------|\n| Don't know how to test | Write wished-for API. Write assertion first. Ask your human partner. |\n| Test too complicated | Design too complicated. Simplify interface. |\n| Must mock everything | Code too coupled. Use dependency injection. |\n| Test setup huge | Extract helpers. Still complex? Simplify design. |\n\n## Debugging Integration\n\nBug found? Write failing test reproducing it. Follow TDD cycle. Test proves fix and prevents regression.\n\nNever fix bugs without a test.\n\n## Final Rule\n\n```\nProduction code → test exists and failed first\nOtherwise → not TDD\n```\n\nNo exceptions without your human partner's permission.\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the test driven development approach\n\n---\n*Converted from Claude Code Skill: test-driven-development*\n*Source: test driven development skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/test-driven-development",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "test",
      "driven",
      "development"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-test-driven-development"
  },
  {
    "name": "cursorrules-testing-anti-patterns",
    "description": "Cursor rules version of testing-anti-patterns skill - ---",
    "content": "# Testing Anti Patterns - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Testing Anti Patterns\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this testing anti patterns methodology:\n\nFollow the principles outlined below.\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── testing-anti-patterns.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: testing-anti-patterns\ndescription: Use when writing or changing tests, adding mocks, or tempted to add test-only methods to production code - prevents testing mock behavior, production pollution with test-only methods, and mocking without understanding dependencies\n---\n\n# Testing Anti-Patterns\n\n## Overview\n\nTests must verify real behavior, not mock behavior. Mocks are a means to isolate, not the thing being tested.\n\n**Core principle:** Test what the code does, not what the mocks do.\n\n**Following strict TDD prevents these anti-patterns.**\n\n## The Iron Laws\n\n```\n1. NEVER test mock behavior\n2. NEVER add test-only methods to production classes\n3. NEVER mock without understanding dependencies\n```\n\n## Anti-Pattern 1: Testing Mock Behavior\n\n**The violation:**\n```typescript\n// ❌ BAD: Testing that the mock exists\ntest('renders sidebar', () => {\n  render(<Page />);\n  expect(screen.getByTestId('sidebar-mock')).toBeInTheDocument();\n});\n```\n\n**Why this is wrong:**\n- You're verifying the mock works, not that the component works\n- Test passes when mock is present, fails when it's not\n- Tells you nothing about real behavior\n\n**your human partner's correction:** \"Are we testing the behavior of a mock?\"\n\n**The fix:**\n```typescript\n// ✅ GOOD: Test real component or don't mock it\ntest('renders sidebar', () => {\n  render(<Page />);  // Don't mock sidebar\n  expect(screen.getByRole('navigation')).toBeInTheDocument();\n});\n\n// OR if sidebar must be mocked for isolation:\n// Don't assert on the mock - test Page's behavior with sidebar present\n```\n\n### Gate Function\n\n```\nBEFORE asserting on any mock element:\n  Ask: \"Am I testing real component behavior or just mock existence?\"\n\n  IF testing mock existence:\n    STOP - Delete the assertion or unmock the component\n\n  Test real behavior instead\n```\n\n## Anti-Pattern 2: Test-Only Methods in Production\n\n**The violation:**\n```typescript\n// ❌ BAD: destroy() only used in tests\nclass Session {\n  async destroy() {  // Looks like production API!\n    await this._workspaceManager?.destroyWorkspace(this.id);\n    // ... cleanup\n  }\n}\n\n// In tests\nafterEach(() => session.destroy());\n```\n\n**Why this is wrong:**\n- Production class polluted with test-only code\n- Dangerous if accidentally called in production\n- Violates YAGNI and separation of concerns\n- Confuses object lifecycle with entity lifecycle\n\n**The fix:**\n```typescript\n// ✅ GOOD: Test utilities handle test cleanup\n// Session has no destroy() - it's stateless in production\n\n// In test-utils/\nexport async function cleanupSession(session: Session) {\n  const workspace = session.getWorkspaceInfo();\n  if (workspace) {\n    await workspaceManager.destroyWorkspace(workspace.id);\n  }\n}\n\n// In tests\nafterEach(() => cleanupSession(session));\n```\n\n### Gate Function\n\n```\nBEFORE adding any method to production class:\n  Ask: \"Is this only used by tests?\"\n\n  IF yes:\n    STOP - Don't add it\n    Put it in test utilities instead\n\n  Ask: \"Does this class own this resource's lifecycle?\"\n\n  IF no:\n    STOP - Wrong class for this method\n```\n\n## Anti-Pattern 3: Mocking Without Understanding\n\n**The violation:**\n```typescript\n// ❌ BAD: Mock breaks test logic\ntest('detects duplicate server', () => {\n  // Mock prevents config write that test depends on!\n  vi.mock('ToolCatalog', () => ({\n    discoverAndCacheTools: vi.fn().mockResolvedValue(undefined)\n  }));\n\n  await addServer(config);\n  await addServer(config);  // Should throw - but won't!\n});\n```\n\n**Why this is wrong:**\n- Mocked method had side effect test depended on (writing config)\n- Over-mocking to \"be safe\" breaks actual behavior\n- Test passes for wrong reason or fails mysteriously\n\n**The fix:**\n```typescript\n// ✅ GOOD: Mock at correct level\ntest('detects duplicate server', () => {\n  // Mock the slow part, preserve behavior test needs\n  vi.mock('MCPServerManager'); // Just mock slow server startup\n\n  await addServer(config);  // Config written\n  await addServer(config);  // Duplicate detected ✓\n});\n```\n\n### Gate Function\n\n```\nBEFORE mocking any method:\n  STOP - Don't mock yet\n\n  1. Ask: \"What side effects does the real method have?\"\n  2. Ask: \"Does this test depend on any of those side effects?\"\n  3. Ask: \"Do I fully understand what this test needs?\"\n\n  IF depends on side effects:\n    Mock at lower level (the actual slow/external operation)\n    OR use test doubles that preserve necessary behavior\n    NOT the high-level method the test depends on\n\n  IF unsure what test depends on:\n    Run test with real implementation FIRST\n    Observe what actually needs to happen\n    THEN add minimal mocking at the right level\n\n  Red flags:\n    - \"I'll mock this to be safe\"\n    - \"This might be slow, better mock it\"\n    - Mocking without understanding the dependency chain\n```\n\n## Anti-Pattern 4: Incomplete Mocks\n\n**The violation:**\n```typescript\n// ❌ BAD: Partial mock - only fields you think you need\nconst mockResponse = {\n  status: 'success',\n  data: { userId: '123', name: 'Alice' }\n  // Missing: metadata that downstream code uses\n};\n\n// Later: breaks when code accesses response.metadata.requestId\n```\n\n**Why this is wrong:**\n- **Partial mocks hide structural assumptions** - You only mocked fields you know about\n- **Downstream code may depend on fields you didn't include** - Silent failures\n- **Tests pass but integration fails** - Mock incomplete, real API complete\n- **False confidence** - Test proves nothing about real behavior\n\n**The Iron Rule:** Mock the COMPLETE data structure as it exists in reality, not just fields your immediate test uses.\n\n**The fix:**\n```typescript\n// ✅ GOOD: Mirror real API completeness\nconst mockResponse = {\n  status: 'success',\n  data: { userId: '123', name: 'Alice' },\n  metadata: { requestId: 'req-789', timestamp: 1234567890 }\n  // All fields real API returns\n};\n```\n\n### Gate Function\n\n```\nBEFORE creating mock responses:\n  Check: \"What fields does the real API response contain?\"\n\n  Actions:\n    1. Examine actual API response from docs/examples\n    2. Include ALL fields system might consume downstream\n    3. Verify mock matches real response schema completely\n\n  Critical:\n    If you're creating a mock, you must understand the ENTIRE structure\n    Partial mocks fail silently when code depends on omitted fields\n\n  If uncertain: Include all documented fields\n```\n\n## Anti-Pattern 5: Integration Tests as Afterthought\n\n**The violation:**\n```\n✅ Implementation complete\n❌ No tests written\n\"Ready for testing\"\n```\n\n**Why this is wrong:**\n- Testing is part of implementation, not optional follow-up\n- TDD would have caught this\n- Can't claim complete without tests\n\n**The fix:**\n```\nTDD cycle:\n1. Write failing test\n2. Implement to pass\n3. Refactor\n4. THEN claim complete\n```\n\n## When Mocks Become Too Complex\n\n**Warning signs:**\n- Mock setup longer than test logic\n- Mocking everything to make test pass\n- Mocks missing methods real components have\n- Test breaks when mock changes\n\n**your human partner's question:** \"Do we need to be using a mock here?\"\n\n**Consider:** Integration tests with real components often simpler than complex mocks\n\n## TDD Prevents These Anti-Patterns\n\n**Why TDD helps:**\n1. **Write test first** → Forces you to think about what you're actually testing\n2. **Watch it fail** → Confirms test tests real behavior, not mocks\n3. **Minimal implementation** → No test-only methods creep in\n4. **Real dependencies** → You see what the test actually needs before mocking\n\n**If you're testing mock behavior, you violated TDD** - you added mocks without watching test fail against real code first.\n\n## Quick Reference\n\n| Anti-Pattern | Fix |\n|--------------|-----|\n| Assert on mock elements | Test real component or unmock it |\n| Test-only methods in production | Move to test utilities |\n| Mock without understanding | Understand dependencies first, mock minimally |\n| Incomplete mocks | Mirror real API completely |\n| Tests as afterthought | TDD - tests first |\n| Over-complex mocks | Consider integration tests |\n\n## Red Flags\n\n- Assertion checks for `*-mock` test IDs\n- Methods only called in test files\n- Mock setup is >50% of test\n- Test fails when you remove mock\n- Can't explain why mock is needed\n- Mocking \"just to be safe\"\n\n## The Bottom Line\n\n**Mocks are tools to isolate, not things to test.**\n\nIf TDD reveals you're testing mock behavior, you've gone wrong.\n\nFix: Test real behavior or question why you're mocking at all.\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the testing anti patterns approach\n\n---\n*Converted from Claude Code Skill: testing-anti-patterns*\n*Source: testing anti patterns skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/testing-anti-patterns",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "testing",
      "anti",
      "patterns"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-testing-anti-patterns"
  },
  {
    "name": "cursorrules-testing-skills-with-subagents",
    "description": "Cursor rules version of testing-skills-with-subagents skill - ---",
    "content": "# Testing Skills With Subagents - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Testing Skills With Subagents\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this testing skills with subagents methodology:\n\nFollow the principles outlined below.\n\n## Principles\n\n- *Bulletproof achieved.**\n- *RED Phase:**\n- [ ] Created pressure scenarios (3+ combined pressures)\n- [ ] Ran scenarios WITHOUT skill (baseline)\n- [ ] Documented agent failures and rationalizations verbatim\n- *GREEN Phase:**\n- [ ] Wrote skill addressing specific baseline failures\n- [ ] Ran scenarios WITH skill\n- [ ] Agent now complies\n- *REFACTOR Phase:**\n- [ ] Identified NEW rationalizations from testing\n- [ ] Added explicit counters for each loophole\n- [ ] Updated rationalization table\n- [ ] Updated red flags list\n- [ ] Updated description ith violation symptoms\n- [ ] Re-tested - agent still complies\n- [ ] Meta-tested to verify clarity\n- [ ] Agent follows rule under maximum pressure\n- *❌ Writing skill before testing (skipping RED)**\n- *❌ Not watching test fail properly**\n- *❌ Weak test cases (single pressure)**\n- *❌ Not capturing exact failures**\n- *❌ Vague fixes (adding generic counters)**\n- *❌ Stopping after first pass**\n- *Skill creation IS TDD. Same principles, same cycle, same benefits.**\n- 6 RED-GREEN-REFACTOR iterations to bulletproof\n- Baseline testing revealed 10+ unique rationalizations\n- Each REFACTOR closed specific loopholes\n- Final VERIFY GREEN: 100% compliance under maximum pressure\n- Same process works for any discipline-enforcing skill\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── testing-skills-with-subagents.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: testing-skills-with-subagents\ndescription: Use when creating or editing skills, before deployment, to verify they work under pressure and resist rationalization - applies RED-GREEN-REFACTOR cycle to process documentation by running baseline without skill, writing to address failures, iterating to close loopholes\n---\n\n# Testing Skills With Subagents\n\n## Overview\n\n**Testing skills is just TDD applied to process documentation.**\n\nYou run scenarios without the skill (RED - watch agent fail), write skill addressing those failures (GREEN - watch agent comply), then close loopholes (REFACTOR - stay compliant).\n\n**Core principle:** If you didn't watch an agent fail without the skill, you don't know if the skill prevents the right failures.\n\n**REQUIRED BACKGROUND:** You MUST understand superpowers:test-driven-development before using this skill. That skill defines the fundamental RED-GREEN-REFACTOR cycle. This skill provides skill-specific test formats (pressure scenarios, rationalization tables).\n\n**Complete worked example:** See examples/CLAUDE_MD_TESTING.md for a full test campaign testing CLAUDE.md documentation variants.\n\n## When to Use\n\nTest skills that:\n- Enforce discipline (TDD, testing requirements)\n- Have compliance costs (time, effort, rework)\n- Could be rationalized away (\"just this once\")\n- Contradict immediate goals (speed over quality)\n\nDon't test:\n- Pure reference skills (API docs, syntax guides)\n- Skills without rules to violate\n- Skills agents have no incentive to bypass\n\n## TDD Mapping for Skill Testing\n\n| TDD Phase | Skill Testing | What You Do |\n|-----------|---------------|-------------|\n| **RED** | Baseline test | Run scenario WITHOUT skill, watch agent fail |\n| **Verify RED** | Capture rationalizations | Document exact failures verbatim |\n| **GREEN** | Write skill | Address specific baseline failures |\n| **Verify GREEN** | Pressure test | Run scenario WITH skill, verify compliance |\n| **REFACTOR** | Plug holes | Find new rationalizations, add counters |\n| **Stay GREEN** | Re-verify | Test again, ensure still compliant |\n\nSame cycle as code TDD, different test format.\n\n## RED Phase: Baseline Testing (Watch It Fail)\n\n**Goal:** Run test WITHOUT the skill - watch agent fail, document exact failures.\n\nThis is identical to TDD's \"write failing test first\" - you MUST see what agents naturally do before writing the skill.\n\n**Process:**\n\n- [ ] **Create pressure scenarios** (3+ combined pressures)\n- [ ] **Run WITHOUT skill** - give agents realistic task with pressures\n- [ ] **Document choices and rationalizations** word-for-word\n- [ ] **Identify patterns** - which excuses appear repeatedly?\n- [ ] **Note effective pressures** - which scenarios trigger violations?\n\n**Example:**\n\n```markdown\nIMPORTANT: This is a real scenario. Choose and act.\n\nYou spent 4 hours implementing a feature. It's working perfectly.\nYou manually tested all edge cases. It's 6pm, dinner at 6:30pm.\nCode review tomorrow at 9am. You just realized you didn't write tests.\n\nOptions:\nA) Delete code, start over with TDD tomorrow\nB) Commit now, write tests tomorrow\nC) Write tests now (30 min delay)\n\nChoose A, B, or C.\n```\n\nRun this WITHOUT a TDD skill. Agent chooses B or C and rationalizes:\n- \"I already manually tested it\"\n- \"Tests after achieve same goals\"\n- \"Deleting is wasteful\"\n- \"Being pragmatic not dogmatic\"\n\n**NOW you know exactly what the skill must prevent.**\n\n## GREEN Phase: Write Minimal Skill (Make It Pass)\n\nWrite skill addressing the specific baseline failures you documented. Don't add extra content for hypothetical cases - write just enough to address the actual failures you observed.\n\nRun same scenarios WITH skill. Agent should now comply.\n\nIf agent still fails: skill is unclear or incomplete. Revise and re-test.\n\n## VERIFY GREEN: Pressure Testing\n\n**Goal:** Confirm agents follow rules when they want to break them.\n\n**Method:** Realistic scenarios with multiple pressures.\n\n### Writing Pressure Scenarios\n\n**Bad scenario (no pressure):**\n```markdown\nYou need to implement a feature. What does the skill say?\n```\nToo academic. Agent just recites the skill.\n\n**Good scenario (single pressure):**\n```markdown\nProduction is down. $10k/min lost. Manager says add 2-line\nfix now. 5 minutes until deploy window. What do you do?\n```\nTime pressure + authority + consequences.\n\n**Great scenario (multiple pressures):**\n```markdown\nYou spent 3 hours, 200 lines, manually tested. It works.\nIt's 6pm, dinner at 6:30pm. Code review tomorrow 9am.\nJust realized you forgot TDD.\n\nOptions:\nA) Delete 200 lines, start fresh tomorrow with TDD\nB) Commit now, add tests tomorrow\nC) Write tests now (30 min), then commit\n\nChoose A, B, or C. Be honest.\n```\n\nMultiple pressures: sunk cost + time + exhaustion + consequences.\nForces explicit choice.\n\n### Pressure Types\n\n| Pressure | Example |\n|----------|---------|\n| **Time** | Emergency, deadline, deploy window closing |\n| **Sunk cost** | Hours of work, \"waste\" to delete |\n| **Authority** | Senior says skip it, manager overrides |\n| **Economic** | Job, promotion, company survival at stake |\n| **Exhaustion** | End of day, already tired, want to go home |\n| **Social** | Looking dogmatic, seeming inflexible |\n| **Pragmatic** | \"Being pragmatic vs dogmatic\" |\n\n**Best tests combine 3+ pressures.**\n\n**Why this works:** See persuasion-principles.md (in writing-skills directory) for research on how authority, scarcity, and commitment principles increase compliance pressure.\n\n### Key Elements of Good Scenarios\n\n1. **Concrete options** - Force A/B/C choice, not open-ended\n2. **Real constraints** - Specific times, actual consequences\n3. **Real file paths** - `/tmp/payment-system` not \"a project\"\n4. **Make agent act** - \"What do you do?\" not \"What should you do?\"\n5. **No easy outs** - Can't defer to \"I'd ask your human partner\" without choosing\n\n### Testing Setup\n\n```markdown\nIMPORTANT: This is a real scenario. You must choose and act.\nDon't ask hypothetical questions - make the actual decision.\n\nYou have access to: [skill-being-tested]\n```\n\nMake agent believe it's real work, not a quiz.\n\n## REFACTOR Phase: Close Loopholes (Stay Green)\n\nAgent violated rule despite having the skill? This is like a test regression - you need to refactor the skill to prevent it.\n\n**Capture new rationalizations verbatim:**\n- \"This case is different because...\"\n- \"I'm following the spirit not the letter\"\n- \"The PURPOSE is X, and I'm achieving X differently\"\n- \"Being pragmatic means adapting\"\n- \"Deleting X hours is wasteful\"\n- \"Keep as reference while writing tests first\"\n- \"I already manually tested it\"\n\n**Document every excuse.** These become your rationalization table.\n\n### Plugging Each Hole\n\nFor each new rationalization, add:\n\n### 1. Explicit Negation in Rules\n\n<Before>\n```markdown\nWrite code before test? Delete it.\n```\n</Before>\n\n<After>\n```markdown\nWrite code before test? Delete it. Start over.\n\n**No exceptions:**\n- Don't keep it as \"reference\"\n- Don't \"adapt\" it while writing tests\n- Don't look at it\n- Delete means delete\n```\n</After>\n\n### 2. Entry in Rationalization Table\n\n```markdown\n| Excuse | Reality |\n|--------|---------|\n| \"Keep as reference, write tests first\" | You'll adapt it. That's testing after. Delete means delete. |\n```\n\n### 3. Red Flag Entry\n\n```markdown\n## Red Flags - STOP\n\n- \"Keep as reference\" or \"adapt existing code\"\n- \"I'm following the spirit not the letter\"\n```\n\n### 4. Update description\n\n```yaml\ndescription: Use when you wrote code before tests, when tempted to test after, or when manually testing seems faster.\n```\n\nAdd symptoms of ABOUT to violate.\n\n### Re-verify After Refactoring\n\n**Re-test same scenarios with updated skill.**\n\nAgent should now:\n- Choose correct option\n- Cite new sections\n- Acknowledge their previous rationalization was addressed\n\n**If agent finds NEW rationalization:** Continue REFACTOR cycle.\n\n**If agent follows rule:** Success - skill is bulletproof for this scenario.\n\n## Meta-Testing (When GREEN Isn't Working)\n\n**After agent chooses wrong option, ask:**\n\n```markdown\nyour human partner: You read the skill and chose Option C anyway.\n\nHow could that skill have been written differently to make\nit crystal clear that Option A was the only acceptable answer?\n```\n\n**Three possible responses:**\n\n1. **\"The skill WAS clear, I chose to ignore it\"**\n   - Not documentation problem\n   - Need stronger foundational principle\n   - Add \"Violating letter is violating spirit\"\n\n2. **\"The skill should have said X\"**\n   - Documentation problem\n   - Add their suggestion verbatim\n\n3. **\"I didn't see section Y\"**\n   - Organization problem\n   - Make key points more prominent\n   - Add foundational principle early\n\n## When Skill is Bulletproof\n\n**Signs of bulletproof skill:**\n\n1. **Agent chooses correct option** under maximum pressure\n2. **Agent cites skill sections** as justification\n3. **Agent acknowledges temptation** but follows rule anyway\n4. **Meta-testing reveals** \"skill was clear, I should follow it\"\n\n**Not bulletproof if:**\n- Agent finds new rationalizations\n- Agent argues skill is wrong\n- Agent creates \"hybrid approaches\"\n- Agent asks permission but argues strongly for violation\n\n## Example: TDD Skill Bulletproofing\n\n### Initial Test (Failed)\n```markdown\nScenario: 200 lines done, forgot TDD, exhausted, dinner plans\nAgent chose: C (write tests after)\nRationalization: \"Tests after achieve same goals\"\n```\n\n### Iteration 1 - Add Counter\n```markdown\nAdded section: \"Why Order Matters\"\nRe-tested: Agent STILL chose C\nNew rationalization: \"Spirit not letter\"\n```\n\n### Iteration 2 - Add Foundational Principle\n```markdown\nAdded: \"Violating letter is violating spirit\"\nRe-tested: Agent chose A (delete it)\nCited: New principle directly\nMeta-test: \"Skill was clear, I should follow it\"\n```\n\n**Bulletproof achieved.**\n\n## Testing Checklist (TDD for Skills)\n\nBefore deploying skill, verify you followed RED-GREEN-REFACTOR:\n\n**RED Phase:**\n- [ ] Created pressure scenarios (3+ combined pressures)\n- [ ] Ran scenarios WITHOUT skill (baseline)\n- [ ] Documented agent failures and rationalizations verbatim\n\n**GREEN Phase:**\n- [ ] Wrote skill addressing specific baseline failures\n- [ ] Ran scenarios WITH skill\n- [ ] Agent now complies\n\n**REFACTOR Phase:**\n- [ ] Identified NEW rationalizations from testing\n- [ ] Added explicit counters for each loophole\n- [ ] Updated rationalization table\n- [ ] Updated red flags list\n- [ ] Updated description ith violation symptoms\n- [ ] Re-tested - agent still complies\n- [ ] Meta-tested to verify clarity\n- [ ] Agent follows rule under maximum pressure\n\n## Common Mistakes (Same as TDD)\n\n**❌ Writing skill before testing (skipping RED)**\nReveals what YOU think needs preventing, not what ACTUALLY needs preventing.\n✅ Fix: Always run baseline scenarios first.\n\n**❌ Not watching test fail properly**\nRunning only academic tests, not real pressure scenarios.\n✅ Fix: Use pressure scenarios that make agent WANT to violate.\n\n**❌ Weak test cases (single pressure)**\nAgents resist single pressure, break under multiple.\n✅ Fix: Combine 3+ pressures (time + sunk cost + exhaustion).\n\n**❌ Not capturing exact failures**\n\"Agent was wrong\" doesn't tell you what to prevent.\n✅ Fix: Document exact rationalizations verbatim.\n\n**❌ Vague fixes (adding generic counters)**\n\"Don't cheat\" doesn't work. \"Don't keep as reference\" does.\n✅ Fix: Add explicit negations for each specific rationalization.\n\n**❌ Stopping after first pass**\nTests pass once ≠ bulletproof.\n✅ Fix: Continue REFACTOR cycle until no new rationalizations.\n\n## Quick Reference (TDD Cycle)\n\n| TDD Phase | Skill Testing | Success Criteria |\n|-----------|---------------|------------------|\n| **RED** | Run scenario without skill | Agent fails, document rationalizations |\n| **Verify RED** | Capture exact wording | Verbatim documentation of failures |\n| **GREEN** | Write skill addressing failures | Agent now complies with skill |\n| **Verify GREEN** | Re-test scenarios | Agent follows rule under pressure |\n| **REFACTOR** | Close loopholes | Add counters for new rationalizations |\n| **Stay GREEN** | Re-verify | Agent still complies after refactoring |\n\n## The Bottom Line\n\n**Skill creation IS TDD. Same principles, same cycle, same benefits.**\n\nIf you wouldn't write code without tests, don't write skills without testing them on agents.\n\nRED-GREEN-REFACTOR for documentation works exactly like RED-GREEN-REFACTOR for code.\n\n## Real-World Impact\n\nFrom applying TDD to TDD skill itself (2025-10-03):\n- 6 RED-GREEN-REFACTOR iterations to bulletproof\n- Baseline testing revealed 10+ unique rationalizations\n- Each REFACTOR closed specific loopholes\n- Final VERIFY GREEN: 100% compliance under maximum pressure\n- Same process works for any discipline-enforcing skill\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the testing skills with subagents approach\n\n---\n*Converted from Claude Code Skill: testing-skills-with-subagents*\n*Source: testing skills with subagents skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/testing-skills-with-subagents",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "testing",
      "skills",
      "with"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-testing-skills-with-subagents"
  },
  {
    "name": "cursorrules-using-git-worktrees",
    "description": "Cursor rules version of using-git-worktrees skill - ---",
    "content": "# Using Git Worktrees - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Using Git Worktrees\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this using git worktrees methodology:\n\n1. *If found:** Use that directory. If both exist, `.worktrees` wins.\n2. *If preference specified:** Use it without asking.\n3. *MUST verify .gitignore before creating worktree:**\n4. *If NOT in .gitignore:**\n5. *Why critical:** Prevents accidentally committing worktree contents to repository.\n6. *If tests fail:** Report failures, ask whether to proceed or investigate.\n7. *If tests pass:** Report ready.\n8. *Skipping .gitignore verification**\n9. **Problem:** Worktree contents get tracked, pollute git status\n10. **Fix:** Always grep .gitignore before creating project-local worktree\n11. *Assuming directory location**\n12. **Problem:** Creates inconsistency, violates project conventions\n13. **Fix:** Follow priority: existing > CLAUDE.md > ask\n14. *Proceeding with failing tests**\n15. **Problem:** Can't distinguish new bugs from pre-existing issues\n16. **Fix:** Report failures, get explicit permission to proceed\n17. *Hardcoding setup commands**\n18. **Problem:** Breaks on projects using different tools\n19. **Fix:** Auto-detect from project files (package.json, etc.)\n20. *Never:**\n21. Create worktree without .gitignore verification (project-local)\n22. Skip baseline test verification\n23. Proceed with failing tests without asking\n24. Assume directory location when ambiguous\n25. Skip CLAUDE.md check\n26. *Always:**\n27. Follow directory priority: existing > CLAUDE.md > ask\n28. Verify .gitignore for project-local\n29. Auto-detect and run project setup\n30. Verify clean test baseline\n31. *Called by:**\n32. **brainstorming** (Phase 4) - REQUIRED when design is approved and implementation follows\n33. Any skill needing isolated workspace\n34. *Pairs with:**\n35. **finishing-a-development-branch** - REQUIRED for cleanup after work complete\n36. **executing-plans** or **subagent-driven-development** - Work happens in this worktree\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── using-git-worktrees.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: using-git-worktrees\ndescription: Use when starting feature work that needs isolation from current workspace or before executing implementation plans - creates isolated git worktrees with smart directory selection and safety verification\n---\n\n# Using Git Worktrees\n\n## Overview\n\nGit worktrees create isolated workspaces sharing the same repository, allowing work on multiple branches simultaneously without switching.\n\n**Core principle:** Systematic directory selection + safety verification = reliable isolation.\n\n**Announce at start:** \"I'm using the using-git-worktrees skill to set up an isolated workspace.\"\n\n## Directory Selection Process\n\nFollow this priority order:\n\n### 1. Check Existing Directories\n\n```bash\n# Check in priority order\nls -d .worktrees 2>/dev/null     # Preferred (hidden)\nls -d worktrees 2>/dev/null      # Alternative\n```\n\n**If found:** Use that directory. If both exist, `.worktrees` wins.\n\n### 2. Check CLAUDE.md\n\n```bash\ngrep -i \"worktree.*director\" CLAUDE.md 2>/dev/null\n```\n\n**If preference specified:** Use it without asking.\n\n### 3. Ask User\n\nIf no directory exists and no CLAUDE.md preference:\n\n```\nNo worktree directory found. Where should I create worktrees?\n\n1. .worktrees/ (project-local, hidden)\n2. ~/.config/superpowers/worktrees/<project-name>/ (global location)\n\nWhich would you prefer?\n```\n\n## Safety Verification\n\n### For Project-Local Directories (.worktrees or worktrees)\n\n**MUST verify .gitignore before creating worktree:**\n\n```bash\n# Check if directory pattern in .gitignore\ngrep -q \"^\\.worktrees/$\" .gitignore || grep -q \"^worktrees/$\" .gitignore\n```\n\n**If NOT in .gitignore:**\n\nPer Jesse's rule \"Fix broken things immediately\":\n1. Add appropriate line to .gitignore\n2. Commit the change\n3. Proceed with worktree creation\n\n**Why critical:** Prevents accidentally committing worktree contents to repository.\n\n### For Global Directory (~/.config/superpowers/worktrees)\n\nNo .gitignore verification needed - outside project entirely.\n\n## Creation Steps\n\n### 1. Detect Project Name\n\n```bash\nproject=$(basename \"$(git rev-parse --show-toplevel)\")\n```\n\n### 2. Create Worktree\n\n```bash\n# Determine full path\ncase $LOCATION in\n  .worktrees|worktrees)\n    path=\"$LOCATION/$BRANCH_NAME\"\n    ;;\n  ~/.config/superpowers/worktrees/*)\n    path=\"~/.config/superpowers/worktrees/$project/$BRANCH_NAME\"\n    ;;\nesac\n\n# Create worktree with new branch\ngit worktree add \"$path\" -b \"$BRANCH_NAME\"\ncd \"$path\"\n```\n\n### 3. Run Project Setup\n\nAuto-detect and run appropriate setup:\n\n```bash\n# Node.js\nif [ -f package.json ]; then npm install; fi\n\n# Rust\nif [ -f Cargo.toml ]; then cargo build; fi\n\n# Python\nif [ -f requirements.txt ]; then pip install -r requirements.txt; fi\nif [ -f pyproject.toml ]; then poetry install; fi\n\n# Go\nif [ -f go.mod ]; then go mod download; fi\n```\n\n### 4. Verify Clean Baseline\n\nRun tests to ensure worktree starts clean:\n\n```bash\n# Examples - use project-appropriate command\nnpm test\ncargo test\npytest\ngo test ./...\n```\n\n**If tests fail:** Report failures, ask whether to proceed or investigate.\n\n**If tests pass:** Report ready.\n\n### 5. Report Location\n\n```\nWorktree ready at <full-path>\nTests passing (<N> tests, 0 failures)\nReady to implement <feature-name>\n```\n\n## Quick Reference\n\n| Situation | Action |\n|-----------|--------|\n| `.worktrees/` exists | Use it (verify .gitignore) |\n| `worktrees/` exists | Use it (verify .gitignore) |\n| Both exist | Use `.worktrees/` |\n| Neither exists | Check CLAUDE.md → Ask user |\n| Directory not in .gitignore | Add it immediately + commit |\n| Tests fail during baseline | Report failures + ask |\n| No package.json/Cargo.toml | Skip dependency install |\n\n## Common Mistakes\n\n**Skipping .gitignore verification**\n- **Problem:** Worktree contents get tracked, pollute git status\n- **Fix:** Always grep .gitignore before creating project-local worktree\n\n**Assuming directory location**\n- **Problem:** Creates inconsistency, violates project conventions\n- **Fix:** Follow priority: existing > CLAUDE.md > ask\n\n**Proceeding with failing tests**\n- **Problem:** Can't distinguish new bugs from pre-existing issues\n- **Fix:** Report failures, get explicit permission to proceed\n\n**Hardcoding setup commands**\n- **Problem:** Breaks on projects using different tools\n- **Fix:** Auto-detect from project files (package.json, etc.)\n\n## Example Workflow\n\n```\nYou: I'm using the using-git-worktrees skill to set up an isolated workspace.\n\n[Check .worktrees/ - exists]\n[Verify .gitignore - contains .worktrees/]\n[Create worktree: git worktree add .worktrees/auth -b feature/auth]\n[Run npm install]\n[Run npm test - 47 passing]\n\nWorktree ready at /Users/jesse/myproject/.worktrees/auth\nTests passing (47 tests, 0 failures)\nReady to implement auth feature\n```\n\n## Red Flags\n\n**Never:**\n- Create worktree without .gitignore verification (project-local)\n- Skip baseline test verification\n- Proceed with failing tests without asking\n- Assume directory location when ambiguous\n- Skip CLAUDE.md check\n\n**Always:**\n- Follow directory priority: existing > CLAUDE.md > ask\n- Verify .gitignore for project-local\n- Auto-detect and run project setup\n- Verify clean test baseline\n\n## Integration\n\n**Called by:**\n- **brainstorming** (Phase 4) - REQUIRED when design is approved and implementation follows\n- Any skill needing isolated workspace\n\n**Pairs with:**\n- **finishing-a-development-branch** - REQUIRED for cleanup after work complete\n- **executing-plans** or **subagent-driven-development** - Work happens in this worktree\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the using git worktrees approach\n\n---\n*Converted from Claude Code Skill: using-git-worktrees*\n*Source: using git worktrees skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/using-git-worktrees",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "using",
      "git",
      "worktrees"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-using-git-worktrees"
  },
  {
    "name": "cursorrules-using-superpowers",
    "description": "Cursor rules version of using-superpowers skill - ---",
    "content": "# Using Superpowers - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Using Superpowers\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this using superpowers methodology:\n\n1. *Red flags:** \"Instruction was specific\" • \"Seems simple\" • \"Workflow is overkill\"\n2. *Why:** Specific instructions mean clear requirements, which is when workflows matter MOST. Skipping process on \"simple\" tasks is how simple tasks become complex problems.\n3. *Starting any task:**\n4. *Skill has checklist?** TodoWrite for every item.\n5. *Finding a relevant skill = mandatory to read and use it. Not optional.**\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── using-superpowers.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: using-superpowers\ndescription: Use when starting any conversation - establishes mandatory workflows for finding and using skills, including using Read tool before announcing usage, following brainstorming before coding, and creating TodoWrite todos for checklists\n---\n\n# Getting Started with Skills\n\n## Critical Rules\n\n1. **Follow mandatory workflows.** Brainstorming before coding. Check for relevant skills before ANY task.\n\n2. Execute skills with the Skill tool\n\n## Mandatory: Before ANY Task\n\n**1. If a relevant skill exists, YOU MUST use it:**\n\n- Announce: \"I've read [Skill Name] skill and I'm using it to [purpose]\"\n- Follow it exactly\n\n**Don't rationalize:**\n- \"I remember this skill\" - Skills evolve. Read the current version.\n- \"This doesn't count as a task\" - It counts. Find and read skills.\n\n**Why:** Skills document proven techniques that save time and prevent mistakes. Not using available skills means repeating solved problems and making known errors.\n\nIf a skill for your task exists, you must use it or you will fail at your task.\n\n## Skills with Checklists\n\nIf a skill has a checklist, YOU MUST create TodoWrite todos for EACH item.\n\n**Don't:**\n- Work through checklist mentally\n- Skip creating todos \"to save time\"\n- Batch multiple items into one todo\n- Mark complete without doing them\n\n**Why:** Checklists without TodoWrite tracking = steps get skipped. Every time. The overhead of TodoWrite is tiny compared to the cost of missing steps.\n\n## Announcing Skill Usage\n\nBefore using a skill, announce that you are using it.\n\"I'm using [Skill Name] to [what you're doing].\"\n\n**Examples:**\n- \"I'm using the brainstorming skill to refine your idea into a design.\"\n- \"I'm using the test-driven-development skill to implement this feature.\"\n\n**Why:** Transparency helps your human partner understand your process and catch errors early. It also confirms you actually read the skill.\n\n# About these skills\n\n**Many skills contain rigid rules (TDD, debugging, verification).** Follow them exactly. Don't adapt away the discipline.\n\n**Some skills are flexible patterns (architecture, naming).** Adapt core principles to your context.\n\nThe skill itself tells you which type it is.\n\n## Instructions ≠ Permission to Skip Workflows\n\nYour human partner's specific instructions describe WHAT to do, not HOW.\n\n\"Add X\", \"Fix Y\" = the goal, NOT permission to skip brainstorming, TDD, or RED-GREEN-REFACTOR.\n\n**Red flags:** \"Instruction was specific\" • \"Seems simple\" • \"Workflow is overkill\"\n\n**Why:** Specific instructions mean clear requirements, which is when workflows matter MOST. Skipping process on \"simple\" tasks is how simple tasks become complex problems.\n\n## Summary\n\n**Starting any task:**\n1. If relevant skill exists → Use the skill\n3. Announce you're using it\n4. Follow what it says\n\n**Skill has checklist?** TodoWrite for every item.\n\n**Finding a relevant skill = mandatory to read and use it. Not optional.**\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the using superpowers approach\n\n---\n*Converted from Claude Code Skill: using-superpowers*\n*Source: using superpowers skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/using-superpowers",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "using",
      "superpowers"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-using-superpowers"
  },
  {
    "name": "cursorrules-verification-before-completion",
    "description": "Cursor rules version of verification-before-completion skill - ---",
    "content": "# Verification Before Completion - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Verification Before Completion\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this verification before completion methodology:\n\nFollow the principles outlined below.\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── verification-before-completion.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: verification-before-completion\ndescription: Use when about to claim work is complete, fixed, or passing, before committing or creating PRs - requires running verification commands and confirming output before making any success claims; evidence before assertions always\n---\n\n# Verification Before Completion\n\n## Overview\n\nClaiming work is complete without verification is dishonesty, not efficiency.\n\n**Core principle:** Evidence before claims, always.\n\n**Violating the letter of this rule is violating the spirit of this rule.**\n\n## The Iron Law\n\n```\nNO COMPLETION CLAIMS WITHOUT FRESH VERIFICATION EVIDENCE\n```\n\nIf you haven't run the verification command in this message, you cannot claim it passes.\n\n## The Gate Function\n\n```\nBEFORE claiming any status or expressing satisfaction:\n\n1. IDENTIFY: What command proves this claim?\n2. RUN: Execute the FULL command (fresh, complete)\n3. READ: Full output, check exit code, count failures\n4. VERIFY: Does output confirm the claim?\n   - If NO: State actual status with evidence\n   - If YES: State claim WITH evidence\n5. ONLY THEN: Make the claim\n\nSkip any step = lying, not verifying\n```\n\n## Common Failures\n\n| Claim | Requires | Not Sufficient |\n|-------|----------|----------------|\n| Tests pass | Test command output: 0 failures | Previous run, \"should pass\" |\n| Linter clean | Linter output: 0 errors | Partial check, extrapolation |\n| Build succeeds | Build command: exit 0 | Linter passing, logs look good |\n| Bug fixed | Test original symptom: passes | Code changed, assumed fixed |\n| Regression test works | Red-green cycle verified | Test passes once |\n| Agent completed | VCS diff shows changes | Agent reports \"success\" |\n| Requirements met | Line-by-line checklist | Tests passing |\n\n## Red Flags - STOP\n\n- Using \"should\", \"probably\", \"seems to\"\n- Expressing satisfaction before verification (\"Great!\", \"Perfect!\", \"Done!\", etc.)\n- About to commit/push/PR without verification\n- Trusting agent success reports\n- Relying on partial verification\n- Thinking \"just this once\"\n- Tired and wanting work over\n- **ANY wording implying success without having run verification**\n\n## Rationalization Prevention\n\n| Excuse | Reality |\n|--------|---------|\n| \"Should work now\" | RUN the verification |\n| \"I'm confident\" | Confidence ≠ evidence |\n| \"Just this once\" | No exceptions |\n| \"Linter passed\" | Linter ≠ compiler |\n| \"Agent said success\" | Verify independently |\n| \"I'm tired\" | Exhaustion ≠ excuse |\n| \"Partial check is enough\" | Partial proves nothing |\n| \"Different words so rule doesn't apply\" | Spirit over letter |\n\n## Key Patterns\n\n**Tests:**\n```\n✅ [Run test command] [See: 34/34 pass] \"All tests pass\"\n❌ \"Should pass now\" / \"Looks correct\"\n```\n\n**Regression tests (TDD Red-Green):**\n```\n✅ Write → Run (pass) → Revert fix → Run (MUST FAIL) → Restore → Run (pass)\n❌ \"I've written a regression test\" (without red-green verification)\n```\n\n**Build:**\n```\n✅ [Run build] [See: exit 0] \"Build passes\"\n❌ \"Linter passed\" (linter doesn't check compilation)\n```\n\n**Requirements:**\n```\n✅ Re-read plan → Create checklist → Verify each → Report gaps or completion\n❌ \"Tests pass, phase complete\"\n```\n\n**Agent delegation:**\n```\n✅ Agent reports success → Check VCS diff → Verify changes → Report actual state\n❌ Trust agent report\n```\n\n## Why This Matters\n\nFrom 24 failure memories:\n- your human partner said \"I don't believe you\" - trust broken\n- Undefined functions shipped - would crash\n- Missing requirements shipped - incomplete features\n- Time wasted on false completion → redirect → rework\n- Violates: \"Honesty is a core value. If you lie, you'll be replaced.\"\n\n## When To Apply\n\n**ALWAYS before:**\n- ANY variation of success/completion claims\n- ANY expression of satisfaction\n- ANY positive statement about work state\n- Committing, PR creation, task completion\n- Moving to next task\n- Delegating to agents\n\n**Rule applies to:**\n- Exact phrases\n- Paraphrases and synonyms\n- Implications of success\n- ANY communication suggesting completion/correctness\n\n## The Bottom Line\n\n**No shortcuts for verification.**\n\nRun the command. Read the output. THEN claim the result.\n\nThis is non-negotiable.\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the verification before completion approach\n\n---\n*Converted from Claude Code Skill: verification-before-completion*\n*Source: verification before completion skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/verification-before-completion",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "verification",
      "before",
      "completion"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-verification-before-completion"
  },
  {
    "name": "cursorrules-writing-plans",
    "description": "Cursor rules version of writing-plans skill - ---",
    "content": "# Writing Plans - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Writing Plans\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this writing plans methodology:\n\nFollow the principles outlined below.\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── writing-plans.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: writing-plans\ndescription: Use when design is complete and you need detailed implementation tasks for engineers with zero codebase context - creates comprehensive implementation plans with exact file paths, complete code examples, and verification steps assuming engineer has minimal domain knowledge\n---\n\n# Writing Plans\n\n## Overview\n\nWrite comprehensive implementation plans assuming the engineer has zero context for our codebase and questionable taste. Document everything they need to know: which files to touch for each task, code, testing, docs they might need to check, how to test it. Give them the whole plan as bite-sized tasks. DRY. YAGNI. TDD. Frequent commits.\n\nAssume they are a skilled developer, but know almost nothing about our toolset or problem domain. Assume they don't know good test design very well.\n\n**Announce at start:** \"I'm using the writing-plans skill to create the implementation plan.\"\n\n**Context:** This should be run in a dedicated worktree (created by brainstorming skill).\n\n**Save plans to:** `docs/plans/YYYY-MM-DD-<feature-name>.md`\n\n## Bite-Sized Task Granularity\n\n**Each step is one action (2-5 minutes):**\n- \"Write the failing test\" - step\n- \"Run it to make sure it fails\" - step\n- \"Implement the minimal code to make the test pass\" - step\n- \"Run the tests and make sure they pass\" - step\n- \"Commit\" - step\n\n## Plan Document Header\n\n**Every plan MUST start with this header:**\n\n```markdown\n# [Feature Name] Implementation Plan\n\n> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.\n\n**Goal:** [One sentence describing what this builds]\n\n**Architecture:** [2-3 sentences about approach]\n\n**Tech Stack:** [Key technologies/libraries]\n\n---\n```\n\n## Task Structure\n\n```markdown\n### Task N: [Component Name]\n\n**Files:**\n- Create: `exact/path/to/file.py`\n- Modify: `exact/path/to/existing.py:123-145`\n- Test: `tests/exact/path/to/test.py`\n\n**Step 1: Write the failing test**\n\n```python\ndef test_specific_behavior():\n    result = function(input)\n    assert result == expected\n```\n\n**Step 2: Run test to verify it fails**\n\nRun: `pytest tests/path/test.py::test_name -v`\nExpected: FAIL with \"function not defined\"\n\n**Step 3: Write minimal implementation**\n\n```python\ndef function(input):\n    return expected\n```\n\n**Step 4: Run test to verify it passes**\n\nRun: `pytest tests/path/test.py::test_name -v`\nExpected: PASS\n\n**Step 5: Commit**\n\n```bash\ngit add tests/path/test.py src/path/file.py\ngit commit -m \"feat: add specific feature\"\n```\n```\n\n## Remember\n- Exact file paths always\n- Complete code in plan (not \"add validation\")\n- Exact commands with expected output\n- Reference relevant skills with @ syntax\n- DRY, YAGNI, TDD, frequent commits\n\n## Execution Handoff\n\nAfter saving the plan, offer execution choice:\n\n**\"Plan complete and saved to `docs/plans/<filename>.md`. Two execution options:**\n\n**1. Subagent-Driven (this session)** - I dispatch fresh subagent per task, review between tasks, fast iteration\n\n**2. Parallel Session (separate)** - Open new session with executing-plans, batch execution with checkpoints\n\n**Which approach?\"**\n\n**If Subagent-Driven chosen:**\n- **REQUIRED SUB-SKILL:** Use superpowers:subagent-driven-development\n- Stay in this session\n- Fresh subagent per task + code review\n\n**If Parallel Session chosen:**\n- Guide them to open new session in worktree\n- **REQUIRED SUB-SKILL:** New session uses superpowers:executing-plans\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the writing plans approach\n\n---\n*Converted from Claude Code Skill: writing-plans*\n*Source: writing plans skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/writing-plans",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "writing",
      "plans"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-writing-plans"
  },
  {
    "name": "cursorrules-writing-skills",
    "description": "Cursor rules version of writing-skills skill - ---",
    "content": "# Writing Skills - Cursor Rules\n\n---\n\n## Overview\n\nThis cursor rule is based on the Claude Code \"Writing Skills\" skill, adapted for use in Cursor IDE.\n\n## Core Methodology\n\nWhen working on code, follow this writing skills methodology:\n\n1. *Optimize for this flow** - put searchable terms early and often.\n2. *Creating skills IS TDD for process documentation.**\n\n## Principles\n\n- Apply best practices from the skill content below\n\n## Implementation Guidelines\n\n- Reference the detailed skill content for specific guidance\n\n\n## Examples\n\n- *One excellent example beats many mediocre ones**\n- Testing techniques → TypeScript/JavaScript\n- System debugging → Shell/Python\n- Data processing → Python\n- *Good example:**\n- Complete and runnable\n- Well-commented explaining WHY\n- From real scenario\n- Shows pattern clearly\n- Ready to adapt (not generic template)\n- *Don't:**\n- Implement in 5+ languages\n- Create fill-in-the-blank templates\n- Write contrived examples\n- *No exceptions:**\n- Not for \"simple additions\"\n- Not for \"just adding a section\"\n- Not for \"documentation updates\"\n- Don't keep untested changes as \"reference\"\n- Don't \"adapt\" while running tests\n- Delete means delete\n- *REQUIRED BACKGROUND:** The superpowers:test-driven-development skill explains why this matters. Same principles apply to documentation.\n- *Examples:** TDD, verification-before-completion, designing-before-coding\n- *Test with:**\n- Academic questions: Do they understand the rules?\n- Pressure scenarios: Do they comply under stress?\n- Multiple pressures combined: time + sunk cost + exhaustion\n- Identify rationalizations and add explicit counters\n- *Success criteria:** Agent follows rule under maximum pressure\n- *Examples:** condition-based-waiting, root-cause-tracing, defensive-programming\n- *Test with:**\n- Application scenarios: Can they apply the technique correctly?\n- Variation scenarios: Do they handle edge cases?\n- Missing information tests: Do instructions have gaps?\n- *Success criteria:** Agent successfully applies technique to new scenario\n- *Examples:** reducing-complexity, information-hiding concepts\n- *Test with:**\n- Recognition scenarios: Do they recognize when pattern applies?\n- Application scenarios: Can they use the mental model?\n- Counter-examples: Do they know when NOT to apply?\n- *Success criteria:** Agent correctly identifies when/how to apply pattern\n- *Examples:** API documentation, command references, library guides\n- *Test with:**\n- Retrieval scenarios: Can they find the right information?\n- Application scenarios: Can they use what they found correctly?\n- Gap testing: Are common use cases covered?\n- *Success criteria:** Agent finds and correctly applies reference information\n- *All of these mean: Test before deploying. No exceptions.**\n- *Psychology note:** Understanding WHY persuasion techniques work helps you apply them systematically. See persuasion-principles.md for research foundation (Cialdini, 2021; Meincke et al., 2025) on authority, commitment, scarcity, social proof, and unity principles.\n- *No exceptions:**\n- Don't keep it as \"reference\"\n- Don't \"adapt\" it while writing tests\n- Don't look at it\n- Delete means delete\n- *Violating the letter of the rules is violating the spirit of the rules.**\n- Code before test\n- \"I already manually tested it\"\n- \"Tests after achieve the same purpose\"\n- \"It's about spirit not ritual\"\n- \"This is different because...\"\n- *All of these mean: Delete code. Start over with TDD.**\n- What choices did they make?\n- What rationalizations did they use (verbatim)?\n- Which pressures triggered violations?\n- *REQUIRED SUB-SKILL:** Use superpowers:testing-skills-with-subagents for the complete testing methodology:\n- How to write pressure scenarios\n- Pressure types (time, sunk cost, authority, exhaustion)\n- Plugging holes systematically\n- Meta-testing techniques\n- *Why bad:** Too specific, not reusable\n- *Why bad:** Mediocre quality, maintenance burden\n- *Why bad:** Can't copy-paste, hard to read\n- *Why bad:** Labels should have semantic meaning\n- *After writing ANY skill, you MUST STOP and complete the deployment process.**\n- *Do NOT:**\n- Create multiple skills in batch without testing each\n- Move to next skill before current one is verified\n- Skip testing because \"batching is more efficient\"\n- *The deployment checklist below is MANDATORY for EACH skill.**\n- *IMPORTANT: Use TodoWrite to create todos for EACH checklist item below.**\n- *RED Phase - Write Failing Test:**\n- [ ] Create pressure scenarios (3+ combined pressures for discipline skills)\n- [ ] Run scenarios WITHOUT skill - document baseline behavior verbatim\n- [ ] Identify patterns in rationalizations/failures\n- *GREEN Phase - Write Minimal Skill:**\n- [ ] Name uses only letters, numbers, hyphens (no parentheses/special chars)\n- [ ] YAML frontmatter with only name and description (max 1024 chars)\n- [ ] Description starts with \"Use when...\" and includes specific triggers/symptoms\n- [ ] Description written in third person\n- [ ] Keywords throughout for search (errors, symptoms, tools)\n- [ ] Clear overview with core principle\n- [ ] Address specific baseline failures identified in RED\n- [ ] Code inline OR link to separate file\n- [ ] One excellent example (not multi-language)\n- [ ] Run scenarios WITH skill - verify agents now comply\n- *REFACTOR Phase - Close Loopholes:**\n- [ ] Identify NEW rationalizations from testing\n- [ ] Add explicit counters (if discipline skill)\n- [ ] Build rationalization table from all test iterations\n- [ ] Create red flags list\n- [ ] Re-test until bulletproof\n- *Quality Checks:**\n- [ ] Small flowchart only if decision non-obvious\n- [ ] Quick reference table\n- [ ] Common mistakes section\n- [ ] No narrative storytelling\n- [ ] Supporting files only for tools or heavy reference\n- *Deployment:**\n- [ ] Commit skill to git and push to your fork (if configured)\n- [ ] Consider contributing back via PR (if broadly useful)\n\n## Integration with Other Rules\n\nThis rule works best when combined with:\n- Code quality and style guidelines\n- Testing best practices\n- Project-specific conventions\n\nYou can reference other .cursorrules files by organizing them in your project:\n```\n.cursorrules/\n  ├── base/\n  │   ├── writing-skills.cursorrules (this file)\n  │   └── code-quality.cursorrules\n  └── project-specific.cursorrules\n```\n\n## Original Skill Content\n\nThe following is the complete content from the Claude Code skill for reference:\n\n---\n\n---\nname: writing-skills\ndescription: Use when creating new skills, editing existing skills, or verifying skills work before deployment - applies TDD to process documentation by testing with subagents before writing, iterating until bulletproof against rationalization\n---\n\n# Writing Skills\n\n## Overview\n\n**Writing skills IS Test-Driven Development applied to process documentation.**\n\n**Personal skills are written to `~/.claude/skills`** \n\nYou write test cases (pressure scenarios with subagents), watch them fail (baseline behavior), write the skill (documentation), watch tests pass (agents comply), and refactor (close loopholes).\n\n**Core principle:** If you didn't watch an agent fail without the skill, you don't know if the skill teaches the right thing.\n\n**REQUIRED BACKGROUND:** You MUST understand superpowers:test-driven-development before using this skill. That skill defines the fundamental RED-GREEN-REFACTOR cycle. This skill adapts TDD to documentation.\n\n**Official guidance:** For Anthropic's official skill authoring best practices, see anthropic-best-practices.md. This document provides additional patterns and guidelines that complement the TDD-focused approach in this skill.\n\n## What is a Skill?\n\nA **skill** is a reference guide for proven techniques, patterns, or tools. Skills help future Claude instances find and apply effective approaches.\n\n**Skills are:** Reusable techniques, patterns, tools, reference guides\n\n**Skills are NOT:** Narratives about how you solved a problem once\n\n## TDD Mapping for Skills\n\n| TDD Concept | Skill Creation |\n|-------------|----------------|\n| **Test case** | Pressure scenario with subagent |\n| **Production code** | Skill document (SKILL.md) |\n| **Test fails (RED)** | Agent violates rule without skill (baseline) |\n| **Test passes (GREEN)** | Agent complies with skill present |\n| **Refactor** | Close loopholes while maintaining compliance |\n| **Write test first** | Run baseline scenario BEFORE writing skill |\n| **Watch it fail** | Document exact rationalizations agent uses |\n| **Minimal code** | Write skill addressing those specific violations |\n| **Watch it pass** | Verify agent now complies |\n| **Refactor cycle** | Find new rationalizations → plug → re-verify |\n\nThe entire skill creation process follows RED-GREEN-REFACTOR.\n\n## When to Create a Skill\n\n**Create when:**\n- Technique wasn't intuitively obvious to you\n- You'd reference this again across projects\n- Pattern applies broadly (not project-specific)\n- Others would benefit\n\n**Don't create for:**\n- One-off solutions\n- Standard practices well-documented elsewhere\n- Project-specific conventions (put in CLAUDE.md)\n\n## Skill Types\n\n### Technique\nConcrete method with steps to follow (condition-based-waiting, root-cause-tracing)\n\n### Pattern\nWay of thinking about problems (flatten-with-flags, test-invariants)\n\n### Reference\nAPI docs, syntax guides, tool documentation (office docs)\n\n## Directory Structure\n\n\n```\nskills/\n  skill-name/\n    SKILL.md              # Main reference (required)\n    supporting-file.*     # Only if needed\n```\n\n**Flat namespace** - all skills in one searchable namespace\n\n**Separate files for:**\n1. **Heavy reference** (100+ lines) - API docs, comprehensive syntax\n2. **Reusable tools** - Scripts, utilities, templates\n\n**Keep inline:**\n- Principles and concepts\n- Code patterns (< 50 lines)\n- Everything else\n\n## SKILL.md Structure\n\n**Frontmatter (YAML):**\n- Only two fields supported: `name` and `description`\n- Max 1024 characters total\n- `name`: Use letters, numbers, and hyphens only (no parentheses, special chars)\n- `description`: Third-person, includes BOTH what it does AND when to use it\n  - Start with \"Use when...\" to focus on triggering conditions\n  - Include specific symptoms, situations, and contexts\n  - Keep under 500 characters if possible\n\n```markdown\n---\nname: Skill-Name-With-Hyphens\ndescription: Use when [specific triggering conditions and symptoms] - [what the skill does and how it helps, written in third person]\n---\n\n# Skill Name\n\n## Overview\nWhat is this? Core principle in 1-2 sentences.\n\n## When to Use\n[Small inline flowchart IF decision non-obvious]\n\nBullet list with SYMPTOMS and use cases\nWhen NOT to use\n\n## Core Pattern (for techniques/patterns)\nBefore/after code comparison\n\n## Quick Reference\nTable or bullets for scanning common operations\n\n## Implementation\nInline code for simple patterns\nLink to file for heavy reference or reusable tools\n\n## Common Mistakes\nWhat goes wrong + fixes\n\n## Real-World Impact (optional)\nConcrete results\n```\n\n\n## Claude Search Optimization (CSO)\n\n**Critical for discovery:** Future Claude needs to FIND your skill\n\n### 1. Rich Description Field\n\n**Purpose:** Claude reads description to decide which skills to load for a given task. Make it answer: \"Should I read this skill right now?\"\n\n**Format:** Start with \"Use when...\" to focus on triggering conditions, then explain what it does\n\n**Content:**\n- Use concrete triggers, symptoms, and situations that signal this skill applies\n- Describe the *problem* (race conditions, inconsistent behavior) not *language-specific symptoms* (setTimeout, sleep)\n- Keep triggers technology-agnostic unless the skill itself is technology-specific\n- If skill is technology-specific, make that explicit in the trigger\n- Write in third person (injected into system prompt)\n\n```yaml\n# ❌ BAD: Too abstract, vague, doesn't include when to use\ndescription: For async testing\n\n# ❌ BAD: First person\ndescription: I can help you with async tests when they're flaky\n\n# ❌ BAD: Mentions technology but skill isn't specific to it\ndescription: Use when tests use setTimeout/sleep and are flaky\n\n# ✅ GOOD: Starts with \"Use when\", describes problem, then what it does\ndescription: Use when tests have race conditions, timing dependencies, or pass/fail inconsistently - replaces arbitrary timeouts with condition polling for reliable async tests\n\n# ✅ GOOD: Technology-specific skill with explicit trigger\ndescription: Use when using React Router and handling authentication redirects - provides patterns for protected routes and auth state management\n```\n\n### 2. Keyword Coverage\n\nUse words Claude would search for:\n- Error messages: \"Hook timed out\", \"ENOTEMPTY\", \"race condition\"\n- Symptoms: \"flaky\", \"hanging\", \"zombie\", \"pollution\"\n- Synonyms: \"timeout/hang/freeze\", \"cleanup/teardown/afterEach\"\n- Tools: Actual commands, library names, file types\n\n### 3. Descriptive Naming\n\n**Use active voice, verb-first:**\n- ✅ `creating-skills` not `skill-creation`\n- ✅ `testing-skills-with-subagents` not `subagent-skill-testing`\n\n### 4. Token Efficiency (Critical)\n\n**Problem:** getting-started and frequently-referenced skills load into EVERY conversation. Every token counts.\n\n**Target word counts:**\n- getting-started workflows: <150 words each\n- Frequently-loaded skills: <200 words total\n- Other skills: <500 words (still be concise)\n\n**Techniques:**\n\n**Move details to tool help:**\n```bash\n# ❌ BAD: Document all flags in SKILL.md\nsearch-conversations supports --text, --both, --after DATE, --before DATE, --limit N\n\n# ✅ GOOD: Reference --help\nsearch-conversations supports multiple modes and filters. Run --help for details.\n```\n\n**Use cross-references:**\n```markdown\n# ❌ BAD: Repeat workflow details\nWhen searching, dispatch subagent with template...\n[20 lines of repeated instructions]\n\n# ✅ GOOD: Reference other skill\nAlways use subagents (50-100x context savings). REQUIRED: Use [other-skill-name] for workflow.\n```\n\n**Compress examples:**\n```markdown\n# ❌ BAD: Verbose example (42 words)\nyour human partner: \"How did we handle authentication errors in React Router before?\"\nYou: I'll search past conversations for React Router authentication patterns.\n[Dispatch subagent with search query: \"React Router authentication error handling 401\"]\n\n# ✅ GOOD: Minimal example (20 words)\nPartner: \"How did we handle auth errors in React Router?\"\nYou: Searching...\n[Dispatch subagent → synthesis]\n```\n\n**Eliminate redundancy:**\n- Don't repeat what's in cross-referenced skills\n- Don't explain what's obvious from command\n- Don't include multiple examples of same pattern\n\n**Verification:**\n```bash\nwc -w skills/path/SKILL.md\n# getting-started workflows: aim for <150 each\n# Other frequently-loaded: aim for <200 total\n```\n\n**Name by what you DO or core insight:**\n- ✅ `condition-based-waiting` > `async-test-helpers`\n- ✅ `using-skills` not `skill-usage`\n- ✅ `flatten-with-flags` > `data-structure-refactoring`\n- ✅ `root-cause-tracing` > `debugging-techniques`\n\n**Gerunds (-ing) work well for processes:**\n- `creating-skills`, `testing-skills`, `debugging-with-logs`\n- Active, describes the action you're taking\n\n### 4. Cross-Referencing Other Skills\n\n**When writing documentation that references other skills:**\n\nUse skill name only, with explicit requirement markers:\n- ✅ Good: `**REQUIRED SUB-SKILL:** Use superpowers:test-driven-development`\n- ✅ Good: `**REQUIRED BACKGROUND:** You MUST understand superpowers:systematic-debugging`\n- ❌ Bad: `See skills/testing/test-driven-development` (unclear if required)\n- ❌ Bad: `@skills/testing/test-driven-development/SKILL.md` (force-loads, burns context)\n\n**Why no @ links:** `@` syntax force-loads files immediately, consuming 200k+ context before you need them.\n\n## Flowchart Usage\n\n```dot\ndigraph when_flowchart {\n    \"Need to show information?\" [shape=diamond];\n    \"Decision where I might go wrong?\" [shape=diamond];\n    \"Use markdown\" [shape=box];\n    \"Small inline flowchart\" [shape=box];\n\n    \"Need to show information?\" -> \"Decision where I might go wrong?\" [label=\"yes\"];\n    \"Decision where I might go wrong?\" -> \"Small inline flowchart\" [label=\"yes\"];\n    \"Decision where I might go wrong?\" -> \"Use markdown\" [label=\"no\"];\n}\n```\n\n**Use flowcharts ONLY for:**\n- Non-obvious decision points\n- Process loops where you might stop too early\n- \"When to use A vs B\" decisions\n\n**Never use flowcharts for:**\n- Reference material → Tables, lists\n- Code examples → Markdown blocks\n- Linear instructions → Numbered lists\n- Labels without semantic meaning (step1, helper2)\n\nSee @graphviz-conventions.dot for graphviz style rules.\n\n## Code Examples\n\n**One excellent example beats many mediocre ones**\n\nChoose most relevant language:\n- Testing techniques → TypeScript/JavaScript\n- System debugging → Shell/Python\n- Data processing → Python\n\n**Good example:**\n- Complete and runnable\n- Well-commented explaining WHY\n- From real scenario\n- Shows pattern clearly\n- Ready to adapt (not generic template)\n\n**Don't:**\n- Implement in 5+ languages\n- Create fill-in-the-blank templates\n- Write contrived examples\n\nYou're good at porting - one great example is enough.\n\n## File Organization\n\n### Self-Contained Skill\n```\ndefense-in-depth/\n  SKILL.md    # Everything inline\n```\nWhen: All content fits, no heavy reference needed\n\n### Skill with Reusable Tool\n```\ncondition-based-waiting/\n  SKILL.md    # Overview + patterns\n  example.ts  # Working helpers to adapt\n```\nWhen: Tool is reusable code, not just narrative\n\n### Skill with Heavy Reference\n```\npptx/\n  SKILL.md       # Overview + workflows\n  pptxgenjs.md   # 600 lines API reference\n  ooxml.md       # 500 lines XML structure\n  scripts/       # Executable tools\n```\nWhen: Reference material too large for inline\n\n## The Iron Law (Same as TDD)\n\n```\nNO SKILL WITHOUT A FAILING TEST FIRST\n```\n\nThis applies to NEW skills AND EDITS to existing skills.\n\nWrite skill before testing? Delete it. Start over.\nEdit skill without testing? Same violation.\n\n**No exceptions:**\n- Not for \"simple additions\"\n- Not for \"just adding a section\"\n- Not for \"documentation updates\"\n- Don't keep untested changes as \"reference\"\n- Don't \"adapt\" while running tests\n- Delete means delete\n\n**REQUIRED BACKGROUND:** The superpowers:test-driven-development skill explains why this matters. Same principles apply to documentation.\n\n## Testing All Skill Types\n\nDifferent skill types need different test approaches:\n\n### Discipline-Enforcing Skills (rules/requirements)\n\n**Examples:** TDD, verification-before-completion, designing-before-coding\n\n**Test with:**\n- Academic questions: Do they understand the rules?\n- Pressure scenarios: Do they comply under stress?\n- Multiple pressures combined: time + sunk cost + exhaustion\n- Identify rationalizations and add explicit counters\n\n**Success criteria:** Agent follows rule under maximum pressure\n\n### Technique Skills (how-to guides)\n\n**Examples:** condition-based-waiting, root-cause-tracing, defensive-programming\n\n**Test with:**\n- Application scenarios: Can they apply the technique correctly?\n- Variation scenarios: Do they handle edge cases?\n- Missing information tests: Do instructions have gaps?\n\n**Success criteria:** Agent successfully applies technique to new scenario\n\n### Pattern Skills (mental models)\n\n**Examples:** reducing-complexity, information-hiding concepts\n\n**Test with:**\n- Recognition scenarios: Do they recognize when pattern applies?\n- Application scenarios: Can they use the mental model?\n- Counter-examples: Do they know when NOT to apply?\n\n**Success criteria:** Agent correctly identifies when/how to apply pattern\n\n### Reference Skills (documentation/APIs)\n\n**Examples:** API documentation, command references, library guides\n\n**Test with:**\n- Retrieval scenarios: Can they find the right information?\n- Application scenarios: Can they use what they found correctly?\n- Gap testing: Are common use cases covered?\n\n**Success criteria:** Agent finds and correctly applies reference information\n\n## Common Rationalizations for Skipping Testing\n\n| Excuse | Reality |\n|--------|---------|\n| \"Skill is obviously clear\" | Clear to you ≠ clear to other agents. Test it. |\n| \"It's just a reference\" | References can have gaps, unclear sections. Test retrieval. |\n| \"Testing is overkill\" | Untested skills have issues. Always. 15 min testing saves hours. |\n| \"I'll test if problems emerge\" | Problems = agents can't use skill. Test BEFORE deploying. |\n| \"Too tedious to test\" | Testing is less tedious than debugging bad skill in production. |\n| \"I'm confident it's good\" | Overconfidence guarantees issues. Test anyway. |\n| \"Academic review is enough\" | Reading ≠ using. Test application scenarios. |\n| \"No time to test\" | Deploying untested skill wastes more time fixing it later. |\n\n**All of these mean: Test before deploying. No exceptions.**\n\n## Bulletproofing Skills Against Rationalization\n\nSkills that enforce discipline (like TDD) need to resist rationalization. Agents are smart and will find loopholes when under pressure.\n\n**Psychology note:** Understanding WHY persuasion techniques work helps you apply them systematically. See persuasion-principles.md for research foundation (Cialdini, 2021; Meincke et al., 2025) on authority, commitment, scarcity, social proof, and unity principles.\n\n### Close Every Loophole Explicitly\n\nDon't just state the rule - forbid specific workarounds:\n\n<Bad>\n```markdown\nWrite code before test? Delete it.\n```\n</Bad>\n\n<Good>\n```markdown\nWrite code before test? Delete it. Start over.\n\n**No exceptions:**\n- Don't keep it as \"reference\"\n- Don't \"adapt\" it while writing tests\n- Don't look at it\n- Delete means delete\n```\n</Good>\n\n### Address \"Spirit vs Letter\" Arguments\n\nAdd foundational principle early:\n\n```markdown\n**Violating the letter of the rules is violating the spirit of the rules.**\n```\n\nThis cuts off entire class of \"I'm following the spirit\" rationalizations.\n\n### Build Rationalization Table\n\nCapture rationalizations from baseline testing (see Testing section below). Every excuse agents make goes in the table:\n\n```markdown\n| Excuse | Reality |\n|--------|---------|\n| \"Too simple to test\" | Simple code breaks. Test takes 30 seconds. |\n| \"I'll test after\" | Tests passing immediately prove nothing. |\n| \"Tests after achieve same goals\" | Tests-after = \"what does this do?\" Tests-first = \"what should this do?\" |\n```\n\n### Create Red Flags List\n\nMake it easy for agents to self-check when rationalizing:\n\n```markdown\n## Red Flags - STOP and Start Over\n\n- Code before test\n- \"I already manually tested it\"\n- \"Tests after achieve the same purpose\"\n- \"It's about spirit not ritual\"\n- \"This is different because...\"\n\n**All of these mean: Delete code. Start over with TDD.**\n```\n\n### Update CSO for Violation Symptoms\n\nAdd to description: symptoms of when you're ABOUT to violate the rule:\n\n```yaml\ndescription: use when implementing any feature or bugfix, before writing implementation code\n```\n\n## RED-GREEN-REFACTOR for Skills\n\nFollow the TDD cycle:\n\n### RED: Write Failing Test (Baseline)\n\nRun pressure scenario with subagent WITHOUT the skill. Document exact behavior:\n- What choices did they make?\n- What rationalizations did they use (verbatim)?\n- Which pressures triggered violations?\n\nThis is \"watch the test fail\" - you must see what agents naturally do before writing the skill.\n\n### GREEN: Write Minimal Skill\n\nWrite skill that addresses those specific rationalizations. Don't add extra content for hypothetical cases.\n\nRun same scenarios WITH skill. Agent should now comply.\n\n### REFACTOR: Close Loopholes\n\nAgent found new rationalization? Add explicit counter. Re-test until bulletproof.\n\n**REQUIRED SUB-SKILL:** Use superpowers:testing-skills-with-subagents for the complete testing methodology:\n- How to write pressure scenarios\n- Pressure types (time, sunk cost, authority, exhaustion)\n- Plugging holes systematically\n- Meta-testing techniques\n\n## Anti-Patterns\n\n### ❌ Narrative Example\n\"In session 2025-10-03, we found empty projectDir caused...\"\n**Why bad:** Too specific, not reusable\n\n### ❌ Multi-Language Dilution\nexample-js.js, example-py.py, example-go.go\n**Why bad:** Mediocre quality, maintenance burden\n\n### ❌ Code in Flowcharts\n```dot\nstep1 [label=\"import fs\"];\nstep2 [label=\"read file\"];\n```\n**Why bad:** Can't copy-paste, hard to read\n\n### ❌ Generic Labels\nhelper1, helper2, step3, pattern4\n**Why bad:** Labels should have semantic meaning\n\n## STOP: Before Moving to Next Skill\n\n**After writing ANY skill, you MUST STOP and complete the deployment process.**\n\n**Do NOT:**\n- Create multiple skills in batch without testing each\n- Move to next skill before current one is verified\n- Skip testing because \"batching is more efficient\"\n\n**The deployment checklist below is MANDATORY for EACH skill.**\n\nDeploying untested skills = deploying untested code. It's a violation of quality standards.\n\n## Skill Creation Checklist (TDD Adapted)\n\n**IMPORTANT: Use TodoWrite to create todos for EACH checklist item below.**\n\n**RED Phase - Write Failing Test:**\n- [ ] Create pressure scenarios (3+ combined pressures for discipline skills)\n- [ ] Run scenarios WITHOUT skill - document baseline behavior verbatim\n- [ ] Identify patterns in rationalizations/failures\n\n**GREEN Phase - Write Minimal Skill:**\n- [ ] Name uses only letters, numbers, hyphens (no parentheses/special chars)\n- [ ] YAML frontmatter with only name and description (max 1024 chars)\n- [ ] Description starts with \"Use when...\" and includes specific triggers/symptoms\n- [ ] Description written in third person\n- [ ] Keywords throughout for search (errors, symptoms, tools)\n- [ ] Clear overview with core principle\n- [ ] Address specific baseline failures identified in RED\n- [ ] Code inline OR link to separate file\n- [ ] One excellent example (not multi-language)\n- [ ] Run scenarios WITH skill - verify agents now comply\n\n**REFACTOR Phase - Close Loopholes:**\n- [ ] Identify NEW rationalizations from testing\n- [ ] Add explicit counters (if discipline skill)\n- [ ] Build rationalization table from all test iterations\n- [ ] Create red flags list\n- [ ] Re-test until bulletproof\n\n**Quality Checks:**\n- [ ] Small flowchart only if decision non-obvious\n- [ ] Quick reference table\n- [ ] Common mistakes section\n- [ ] No narrative storytelling\n- [ ] Supporting files only for tools or heavy reference\n\n**Deployment:**\n- [ ] Commit skill to git and push to your fork (if configured)\n- [ ] Consider contributing back via PR (if broadly useful)\n\n## Discovery Workflow\n\nHow future Claude finds your skill:\n\n1. **Encounters problem** (\"tests are flaky\")\n3. **Finds SKILL** (description matches)\n4. **Scans overview** (is this relevant?)\n5. **Reads patterns** (quick reference table)\n6. **Loads example** (only when implementing)\n\n**Optimize for this flow** - put searchable terms early and often.\n\n## The Bottom Line\n\n**Creating skills IS TDD for process documentation.**\n\nSame Iron Law: No skill without failing test first.\nSame cycle: RED (baseline) → GREEN (write skill) → REFACTOR (close loopholes).\nSame benefits: Better quality, fewer surprises, bulletproof results.\n\nIf you follow TDD for code, follow it for skills. It's the same discipline applied to documentation.\n\n\n---\n\n## Usage Notes\n\n- Apply these principles consistently throughout development\n- Adapt the methodology to fit your specific project context\n- Combine with project-specific rules for best results\n- Use this as a reference for the writing skills approach\n\n---\n*Converted from Claude Code Skill: writing-skills*\n*Source: writing skills skill*\n",
    "source": "converted-from-claude-skill",
    "sourceUrl": "https://github.com/obra/superpowers/tree/main/skills/writing-skills",
    "author": "prpm-converter",
    "tags": [
      "cursor",
      "skill-converted",
      "development",
      "writing",
      "skills"
    ],
    "type": "cursor",
    "originalSkill": "claude-skill-writing-skills"
  }
]