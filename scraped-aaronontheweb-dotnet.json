[
  {
    "name": "aaronontheweb-.cursor-meta",
    "slug": ".cursor-meta",
    "displayName": ".cursor meta",
    "description": ".cursor meta for .NET development",
    "author": "Aaronontheweb",
    "type": "cursor",
    "category": "languages",
    "tags": [
      "cursor",
      "cursor-rule",
      "dotnet",
      "csharp"
    ],
    "content": "---\ndescription: A meta-rule for using Cursor to update *.mdc file in this repository.\nglobs: *.mdc\n---\n# Cursor Rules\n\nThis document outlines the meta-rules for cursor operations in this repository.\n\n## Line Ending & Formatting Rules\n\n1. **Line Endings**\n   - Don't modify existing line endings\n   - Preserve CRLF/LF as found in the original file\n\n2. **Whitespace**\n   - Preserve trailing whitespace where it exists\n   - Maintain existing indentation style (spaces vs tabs)\n   - Keep line length consistent with existing code\n\n## File Handling\n\n1. **MDC Files**\n   - Always commit changes to `*.mdc` files directly\n   - Ensure changes to `*.mdc` files are synchronized with their implementation\n   - Maintain consistent formatting within MDC files\n   - Prefer modifying existing files over creating new ones unless explicitly requested\n   - When adding new content, first check if it fits within an existing rule file\n\n\n2. **File Creation**\n\n   - Only create new rule files when:\n     - Explicitly requested by the user\n     - The content doesn't logically fit in any existing rule file\n     - Creating a new file would significantly improve organization and clarity\n   - Document the rationale for creating new files in their README.md\n\n## Code Style & Structure\n\n1. **Formatting**\n   - Preserve existing code formatting patterns\n   - Maintain consistent naming conventions\n   - Keep indentation consistent with file style\n\n2. **Organization**\n   - Keep file structure consistent\n   - Don't move files without updating all references\n   - Maintain existing import/include order\n\n## Rule Content\n\n1. **Examples**\n    - Always include \"do\" and \"don't\" examples when showing specific changes to files or syntax\n    - Include helpful comments that explain why an example is a \"do\" or a \"don't\"\n\n## Documentation\n\n1. **README.md**\n    - Each `*.mdc` file is lumped into a folder with a `README.md` file explaining what the rule does and when it's used. ",
    "sourceUrl": "https://github.com/Aaronontheweb/dotnet-cursor-rules/blob/master/.cursor/rules/meta.mdc",
    "version": "1.0.0",
    "metadata": {
      "originalPath": ".cursor/rules/meta.mdc",
      "sha": "774a89732b0c7c49e20a02a81fa9fd14e450eef2"
    }
  },
  {
    "name": "aaronontheweb-benchmarking-benchmarking",
    "slug": "benchmarking-benchmarking",
    "displayName": "benchmarking benchmarking",
    "description": "benchmarking benchmarking for .NET development",
    "author": "Aaronontheweb",
    "type": "cursor",
    "category": "languages",
    "tags": [
      "cursor",
      "cursor-rule",
      "dotnet",
      "csharp"
    ],
    "content": "---\ndescription: Designing benchmarks for measuring .NET performance\nglobs: \nalwaysApply: false\n---\n# Cursor Rules File: .NET Benchmarking Best Practices\n# This file provides guidelines for writing effective benchmarks using BenchmarkDotNet\n# and other performance testing tools.\n\nRole Definition:\n - Performance Engineer\n - .NET Runtime Specialist\n - Optimization Expert\n\nGeneral:\n  Description: >\n    Performance testing and benchmarking should be systematic, reproducible,\n    and provide meaningful insights. Use BenchmarkDotNet as the primary tool\n    for micro-benchmarking and performance regression testing.\n  Requirements:\n    - Use BenchmarkDotNet for micro-benchmarks\n    - Ensure consistent test environments\n    - Follow scientific method\n    - Track performance metrics over time\n    - Consider memory and allocation patterns\n\nProject Setup:\n  - Configure benchmark projects:\n      ```xml\n      <Project Sdk=\"Microsoft.NET.Sdk\">\n        <PropertyGroup>\n          <OutputType>Exe</OutputType>\n          <TargetFramework>net8.0</TargetFramework>\n          <Configuration>Release</Configuration>\n          <Optimize>true</Optimize>\n          <DebugSymbols>false</DebugSymbols>\n        </PropertyGroup>\n        \n        <ItemGroup>\n          <PackageReference Include=\"BenchmarkDotNet\" Version=\"0.13.10\" />\n          <PackageReference Include=\"BenchmarkDotNet.Diagnostics.Windows\" Version=\"0.13.10\" \n              Condition=\"'$(OS)' == 'Windows_NT'\" />\n        </ItemGroup>\n      </Project>\n      ```\n\nBenchmark Structure:\n  - Basic benchmark setup:\n      ```csharp\n      [MemoryDiagnoser]\n      [RankColumn, MinColumn, MaxColumn, MeanColumn, MedianColumn]\n      public class StringOperationsBenchmarks\n      {\n          private const string TestString = \"Hello, World!\";\n          private readonly StringBuilder _builder = new();\n          \n          [Params(10, 100, 1000)]\n          public int Iterations { get; set; }\n          \n          [GlobalSetup]\n          public void Setup()\n          {\n              // Setup code that runs once before all benchmarks\n          }\n          \n          [Benchmark(Baseline = true)]\n          public string StringConcat()\n          {\n              var result = string.Empty;\n              for (int i = 0; i < Iterations; i++)\n                  result += TestString;\n              return result;\n          }\n          \n          [Benchmark]\n          public string StringBuilder()\n          {\n              _builder.Clear();\n              for (int i = 0; i < Iterations; i++)\n                  _builder.Append(TestString);\n              return _builder.ToString();\n          }\n      }\n      ```\n\nMemory Analysis:\n  - Track allocations and GC:\n      ```csharp\n      [MemoryDiagnoser]\n      [GcServer(true)]\n      public class MemoryBenchmarks\n      {\n          [Benchmark]\n          public IEnumerable<string> AllocatingMethod()\n          {\n              return Enumerable.Range(0, 1000)\n                  .Select(i => i.ToString());\n          }\n          \n          [Benchmark]\n          public IEnumerable<string> NonAllocatingMethod()\n          {\n              return Enumerable.Range(0, 1000)\n                  .Select(i => i.ToString())\n                  .ToArray();\n          }\n      }\n      ```\n\nHardware Intrinsics:\n  - Measure SIMD performance:\n      ```csharp\n      [SimpleJob(RuntimeMoniker.Net80)]\n      [RyuJitX64Job]\n      public class VectorBenchmarks\n      {\n          private float[] _data;\n          \n          [GlobalSetup]\n          public void Setup()\n          {\n              _data = new float[1024];\n              // Initialize data\n          }\n          \n          [Benchmark(Baseline = true)]\n          public float ScalarSum()\n          {\n              float sum = 0;\n              for (int i = 0; i < _data.Length; i++)\n                  sum += _data[i];\n              return sum;\n          }\n          \n          [Benchmark]\n          public float VectorSum()\n          {\n              return Vector.Sum(_data);\n          }\n      }\n      ```\n\nAsync Performance:\n  - Benchmark async operations:\n      ```csharp\n      public class AsyncBenchmarks\n      {\n          private HttpClient _client;\n          \n          [GlobalSetup]\n          public void Setup()\n          {\n              _client = new HttpClient();\n          }\n          \n          [Benchmark]\n          public async Task<string> SingleRequest()\n          {\n              return await _client.GetStringAsync(\"http://example.com\");\n          }\n          \n          [Benchmark]\n          public async Task<string[]> ParallelRequests()\n          {\n              var tasks = Enumerable.Range(0, 10)\n                  .Select(_ => _client.GetStringAsync(\"http://example.com\"))\n                  .ToArray();\n              \n              return await Task.WhenAll(tasks);\n          }\n      }\n      ```\n\nCI/CD Integration:\n  - Configure benchmark runs:\n      ```yaml\n      - name: Run Benchmarks\n        run: |\n          dotnet run -c Release --filter '*'\n      \n      - name: Store Results\n        uses: actions/upload-artifact@v3\n        with:\n          name: benchmark-results\n          path: BenchmarkDotNet.Artifacts/**\n      ```\n  - Track performance over time:\n      ```csharp\n      [Config(typeof(RegressionConfig))]\n      public class RegressionBenchmarks\n      {\n          private class RegressionConfig : ManualConfig\n          {\n              public RegressionConfig()\n              {\n                  AddExporter(MarkdownExporter.GitHub);\n                  AddDiagnoser(MemoryDiagnoser.Default);\n                  AddColumn(StatisticColumn.Median);\n                  AddColumn(RankColumn.Arabic);\n              }\n          }\n      }\n      ```\n\nBest Practices:\n  - Avoid common pitfalls:\n      ```csharp\n      // Good: Proper benchmark isolation\n      [IterationSetup]\n      public void IterationSetup()\n      {\n          _data = new byte[1024];  // Fresh data for each iteration\n      }\n      \n      // Avoid: Shared state between iterations\n      private byte[] _sharedData = new byte[1024];  // Can lead to false results\n      ```\n  - Use appropriate job configurations:\n      ```csharp\n      [SimpleJob(RuntimeMoniker.Net80, baseline: true)]\n      [SimpleJob(RuntimeMoniker.Net70)]\n      [SimpleJob(RuntimeMoniker.Net60)]\n      public class CrossVersionBenchmarks\n      {\n          [Benchmark]\n          public void BenchmarkMethod() { }\n      }\n      ```\n  - Document environment requirements:\n      ```csharp\n      /*\n      ## Required Environment\n      - Windows 10+ or Linux with perf_event_paranoid <= 2\n      - CPU: Modern x64 processor with AVX2 support\n      - RAM: 16GB minimum\n      - Minimal background processes\n      */\n      ```\n\n### IterationSetup and IterationCleanup Method Signatures\n\n**Library Name**: BenchmarkDotNet\n**Programming Language**: C#\n**Library Version**: (,14.0]\n**Severity**: Error (must be followed)\n\n#### Rule Description\nAlways make sure to use `void` methods when defining `IterationSetup` or `IterationCleanup` activities for BenchmarkDotNet classes.\n\n#### Good Examples\n```csharp\n// Good\n[IterationSetup]\npublic void DoSetup()\n{\n}\n\n[IterationCleanup]\npublic void DoCleanup()\n{\n}\n```\n\n#### Bad Examples\n```csharp\n// Bad - will throw runtime exception\n[IterationSetup]\npublic async Task DoSetup()\n{\n}\n\n[IterationCleanup]\npublic async Task DoCleanup()\n{\n}\n```\n\n#### Rationale\nWhile async Task methods will compile, BenchmarkDotNet will throw a runtime exception when these methods are used. The framework requires these methods to be void methods to function properly. \n\n\n# End of Cursor Rules File ",
    "sourceUrl": "https://github.com/Aaronontheweb/dotnet-cursor-rules/blob/master/benchmarking/benchmarking.mdc",
    "version": "1.0.0",
    "metadata": {
      "originalPath": "benchmarking/benchmarking.mdc",
      "sha": "3caa547550790a86f87bf06a35516a456bcce343"
    }
  },
  {
    "name": "aaronontheweb-ci-cd-code-signing",
    "slug": "ci-cd-code-signing",
    "displayName": "ci-cd code signing",
    "description": "ci-cd code signing for .NET development",
    "author": "Aaronontheweb",
    "type": "cursor",
    "category": "languages",
    "tags": [
      "cursor",
      "cursor-rule",
      "dotnet",
      "csharp"
    ],
    "content": "---\ndescription: Rules and best practices for .NET code signing\nglobs: **/signsettings.json,**/appsettings.json,**/*.nupkg\nalwaysApply: false\n---\n\n# .NET Code Signing Rules and Best Practices\n\n## Prerequisites\nThese rules only apply when one of the following exists:\n- `signsettings.json`\n- `appsettings.json` with a `SignClient` section\n\n## Code Signing Configuration\n\n### SignClient Configuration\n```json\n{\n  \"SignClient\": {\n    \"AzureAd\": {\n      \"AADInstance\": \"https://login.microsoftonline.com/\",\n      \"ClientId\": \"[configured in CI]\",\n      \"TenantId\": \"[configured in CI]\"\n    },\n    \"Service\": {\n      \"Url\": \"https://signing-service.example.com/\",\n      \"ResourceId\": \"[configured in CI]\"\n    }\n  }\n}\n```\n\n## Security Best Practices\n1. Never commit signing credentials to source control\n2. Store signing credentials in CI/CD secret variables\n3. Use environment-specific signing configurations\n4. Implement proper credential rotation\n5. Log signing operations for audit purposes\n\n## CI/CD Integration\n\n### GitHub Actions Example\n```yaml\njobs:\n  sign:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n    \n    - name: Install SignClient\n      run: dotnet tool install --global SignClient\n    \n    - name: Sign NuGet Packages\n      run: |\n        SignClient sign `\n          --config signsettings.json `\n          --input \"**/*.nupkg\" `\n          --secret \"${{ secrets.SIGN_CLIENT_SECRET }}\" `\n          --name \"MyProject\" `\n          --description \"Official release package\"\n```\n\n### Azure DevOps Example\n```yaml\nsteps:\n- task: UseDotNet@2\n  inputs:\n    useGlobalJson: true\n\n- script: dotnet tool install --global SignClient\n  displayName: 'Install SignClient'\n\n- powershell: |\n    SignClient sign `\n      --config signsettings.json `\n      --input \"$(Build.ArtifactStagingDirectory)/*.nupkg\" `\n      --secret \"$(SignClientSecret)\" `\n      --name \"$(Build.DefinitionName)\" `\n      --description \"Official release package\"\n  displayName: 'Sign Packages'\n  env:\n    SignClientSecret: $(SignClientSecret)\n```\n\n## Verification\n1. Implement post-signing verification\n2. Check signature validity before publishing\n3. Include signature verification in test pipeline\n4. Document signature verification process\n\n## Package Publishing\n1. Only publish signed packages for releases\n2. Implement signature verification before publishing\n3. Maintain signed package archive\n4. Document package signature in release notes\n\n## Troubleshooting\n1. Common signing errors and solutions\n2. Credential validation steps\n3. Service connectivity issues\n4. Certificate expiration handling\n\n## Maintenance\n1. Regular credential rotation schedule\n2. Certificate expiration monitoring\n3. Signing service health checks\n4. Audit log review process ",
    "sourceUrl": "https://github.com/Aaronontheweb/dotnet-cursor-rules/blob/master/ci-cd/code-signing.mdc",
    "version": "1.0.0",
    "metadata": {
      "originalPath": "ci-cd/code-signing.mdc",
      "sha": "dfc1a6c7075d6bef127aa74b0643548ea060dfd3"
    }
  },
  {
    "name": "aaronontheweb-ci-cd-dotnet-build",
    "slug": "ci-cd-dotnet-build",
    "displayName": "ci-cd dotnet build",
    "description": "ci-cd dotnet build for .NET development",
    "author": "Aaronontheweb",
    "type": "cursor",
    "category": "languages",
    "tags": [
      "cursor",
      "cursor-rule",
      "dotnet",
      "csharp"
    ],
    "content": "---\ndescription: Rules and best practices for .NET build systems\nglobs: **/Directory.Build.props,**/.azure/*.yaml,**/build-system/*.yaml,**/RELEASE_NOTES.md,**/.github/workflows/*.yaml,**/*.sln,**/*.csproj\nalwaysApply: false\n---\n\n# .NET Build System Rules and Best Practices\n\n## Core Build Philosophy\n\n### ✅ DO\n- Use native `dotnet` CLI commands as the primary build mechanism\n- Keep build scripts simple, maintainable, and cross-platform compatible\n- Use PowerShell for custom build tasks that can't be handled by `dotnet` CLI\n- Maintain clear separation between build, test, and release processes\n- Document all build prerequisites and requirements\n\n### ❌ DON'T\n- Use complex build systems like CAKE, FAKE, or NUKE\n- Mix build and deployment logic in the same scripts\n- Hardcode environment-specific paths or settings\n- Implement complex logic in YAML pipelines (use PowerShell scripts instead)\n- Duplicate build logic across different files\n\n## Project Structure\n\n> [!IMPORTANT]\n> Don't create new files without first checking existing ones. Build system files should follow a consistent, predictable structure.\n\n### Required Files and Their Purposes\n```\n├── Directory.Build.props       # Central version and package metadata\n├── Directory.Packages.props    # Centralized package version management\n├── global.json                # SDK version pinning\n���── RELEASE_NOTES.md           # Version history and release notes\n├── build.ps1                  # Version management script (minimal)\n├── scripts/                   # PowerShell helper scripts\n│   ├── getReleaseNotes.ps1    # Parse release notes\n│   ├── bumpVersion.ps1        # Update assembly versions\n│   ├── integration-tests.ps1  # Integration test runner\n│   └── *.ps1                 # Other build helper scripts\n├── build-system/             # CI/CD pipeline definitions\n│   ├── azure-pipeline.template.yaml  # Shared pipeline template\n│   ├── windows-pr-validation.yaml    # Windows PR validation\n│   ├── linux-pr-validation.yaml      # Linux PR validation\n│   └── windows-release.yaml          # Release pipeline\n└── .github/workflows/        # GitHub Actions (if used)\n    ├── pr-validation.yaml    # PR validation\n    └── release.yaml          # Release workflow\n```\n\n### File Responsibilities\n\n#### Directory.Build.props\n- Central version management\n- Package metadata\n- Common build properties\n- Shared package versions\n\nExample:\n```xml\n<Project>\n  <PropertyGroup>\n    <VersionPrefix>1.0.0</VersionPrefix>\n    <PackageReleaseNotes><!-- Auto-updated by build.ps1 --></PackageReleaseNotes>\n    <Authors>Your Company</Authors>\n    <Copyright>© $([System.DateTime]::Now.Year) Your Company</Copyright>\n    <PackageLicenseExpression>Apache-2.0</PackageLicenseExpression>\n    <PackageProjectUrl>https://github.com/org/repo</PackageProjectUrl>\n    <PackageReadmeFile>README.md</PackageReadmeFile>\n    <RepositoryUrl>https://github.com/org/repo.git</RepositoryUrl>\n    <RepositoryType>git</RepositoryType>\n  </PropertyGroup>\n  \n  <!-- Package versions -->\n  <PropertyGroup>\n    <MicrosoftExtensionsVersion>8.0.0</MicrosoftExtensionsVersion>\n    <XunitVersion>2.7.0</XunitVersion>\n  </PropertyGroup>\n</Project>\n```\n\n#### RELEASE_NOTES.md\nMust follow this exact format for automated parsing:\n```markdown\n#### 1.2.3 March 14 2024 ####\n* First change\n* Second change\n\n#### 1.2.2 March 10 2024 ####\n* Previous changes\n```\n\n> [!WARNING]\n> Common mistakes to avoid:\n> - Extra blank lines between version and changes\n> - Missing space between version and date\n> - Incorrect number of # symbols\n> - Missing bullet points for changes\n\n## Build Scripts\n\n### build.ps1\nKeep this script minimal. Its only job should be version management:\n\n```powershell\n[CmdletBinding()]\nparam()\n\n$ErrorActionPreference = 'Stop'\n\n# Import helper functions\n. \"$PSScriptRoot\\scripts\\getReleaseNotes.ps1\"\n. \"$PSScriptRoot\\scripts\\bumpVersion.ps1\"\n\n# Update version information\n$releaseNotes = Get-ReleaseNotes -MarkdownFile (Join-Path -Path $PSScriptRoot -ChildPath \"RELEASE_NOTES.md\")\nUpdateVersionAndReleaseNotes -ReleaseNotesResult $releaseNotes -XmlFilePath (Join-Path -Path $PSScriptRoot -ChildPath \"src\\Directory.Build.props\")\n\nWrite-Output \"Updated version to $($releaseNotes.Version)\"\n```\n\n### Integration Tests\nPlace integration tests in a dedicated script with clear error handling:\n\n```powershell\n[CmdletBinding()]\nparam(\n    [ValidateSet(\"Release\", \"Debug\")]\n    [string]$Configuration = \"Release\"\n)\n\n# Track test results\n$script:hasUnexpectedFailures = $false\n$script:totalTests = 0\n$script:passedTests = 0\n$script:failedTests = 0\n\nfunction Invoke-Test {\n    param(\n        [string]$TestName,\n        [scriptblock]$TestScript,\n        [bool]$ExpectFailure = $false\n    )\n    \n    $script:totalTests++\n    try {\n        & $TestScript\n        if ($LASTEXITCODE -ne 0 -and -not $ExpectFailure) {\n            $script:hasUnexpectedFailures = $true\n            $script:failedTests++\n        } else {\n            $script:passedTests++\n        }\n    }\n    catch {\n        $script:hasUnexpectedFailures = $true\n        $script:failedTests++\n    }\n}\n\n# Run all tests before exiting\nexit $script:hasUnexpectedFailures ? 1 : 0\n```\n\n## CI/CD Pipeline Best Practices\n\n### ✅ DO\n- Use pipeline templates for shared configuration\n- Keep pipeline files in `build-system/` directory\n- Use consistent naming conventions\n- Include clear display names for all steps\n- Set appropriate timeouts\n- Configure proper trigger conditions\n- Use matrix builds for cross-platform testing\n- Publish test results and artifacts\n- Set up proper dependency caching\n\n### ❌ DON'T\n- Put complex logic in YAML files\n- Duplicate steps across pipelines\n- Use inline scripts for complex operations\n- Hardcode version numbers or configuration\n- Mix PR validation and release pipelines\n- Ignore test failures\n- Skip publishing test results\n\n### Azure Pipeline Template Example\n```yaml\nparameters:\n  name: ''\n  vmImage: ''\n  timeoutInMinutes: 10\n  runIntegrationTests: false\n\njobs:\n  - job: ${{ parameters.name }}\n    timeoutInMinutes: ${{ parameters.timeoutInMinutes }}\n    pool:\n      vmImage: ${{ parameters.vmImage }}\n    steps:\n      - checkout: self\n        clean: false\n        submodules: recursive\n        \n      - task: UseDotNet@2\n        displayName: 'Use .NET SDK'\n        inputs:\n          useGlobalJson: true\n          \n      # Version bump\n      - task: PowerShell@2\n        displayName: 'Update version'\n        inputs:\n          filePath: './build.ps1'\n          \n      # Build and test\n      - script: dotnet build -c Release\n        displayName: 'Build solution'\n          \n      - script: dotnet test -c Release --no-build --logger:trx\n        displayName: 'Run unit tests'\n          \n      # Integration tests\n      - task: PowerShell@2\n        displayName: 'Run integration tests'\n        condition: eq(${{ parameters.runIntegrationTests }}, true)\n        inputs:\n          filePath: './scripts/integration-tests.ps1'\n          arguments: '-Configuration Release'\n          \n      # Package\n      - script: dotnet pack -c Release -o $(Build.ArtifactStagingDirectory)\n        displayName: 'Create packages'\n        condition: succeeded()\n          \n      # Publish results\n      - task: PublishTestResults@2\n        displayName: 'Publish test results'\n        condition: always()\n        inputs:\n          testRunner: VSTest\n          testResultsFiles: '**/*.trx'\n          failTaskOnFailedTests: true\n```\n\n### PR Validation Pipeline\n```yaml\ntrigger:\n  branches:\n    include: [ dev, master ]\n  paths:\n    exclude: [ '*.md', 'docs/*' ]\n\npr:\n  autoCancel: true\n  branches:\n    include: [ dev, master ]\n\njobs:\n  - template: azure-pipeline.template.yaml\n    parameters:\n      name: 'Windows'\n      vmImage: 'windows-latest'\n      runIntegrationTests: true\n```\n\n### Release Pipeline\n```yaml\ntrigger:\n  branches:\n    include: [ refs/tags/* ]\n  paths:\n    exclude: [ '*.md', 'docs/*' ]\n\nvariables:\n  - group: nuget-keys\n  - name: projectName\n    value: YourProject\n\nsteps:\n  - task: UseDotNet@2\n    inputs:\n      useGlobalJson: true\n\n  - script: ./build.ps1\n    displayName: 'Update version'\n\n  - script: |\n      dotnet pack -c Release -o $(Build.ArtifactStagingDirectory)\n      dotnet nuget push \"$(Build.ArtifactStagingDirectory)/*.nupkg\" --api-key $(nugetKey) --source https://api.nuget.org/v3/index.json\n    displayName: 'Create and publish packages'\n```\n\n## Common Patterns and Anti-patterns\n\n### Version Management\n\n✅ DO:\n- Use RELEASE_NOTES.md as the single source of truth\n- Automate version updates via build.ps1\n- Include detailed release notes for each version\n- Follow semantic versioning\n- Update all version references consistently\n\n❌ DON'T:\n- Manually edit version numbers\n- Store versions in multiple places\n- Skip release notes\n- Use inconsistent version formats\n- Forget to update package versions\n\n### Build Process\n\n✅ DO:\n- Build before running tests\n- Use `--no-build` for test/pack after build\n- Set appropriate configuration\n- Enable deterministic builds\n- Cache dependencies\n- Use consistent output directories\n\n❌ DON'T:\n- Mix Debug/Release artifacts\n- Skip test runs\n- Ignore build warnings\n- Use platform-specific commands\n- Hardcode paths\n\n### Testing\n\n✅ DO:\n- Run all tests before exit\n- Publish test results\n- Use appropriate test loggers\n- Set test timeouts\n- Handle expected failures properly\n- Separate unit and integration tests\n\n❌ DON'T:\n- Ignore test failures\n- Skip result publishing\n- Mix test types\n- Use platform-specific test runners\n- Leave failing tests unhandled\n\n### Package Creation\n\n✅ DO:\n- Include symbols packages\n- Set appropriate package metadata\n- Use consistent output directory\n- Verify package contents\n- Include documentation files\n\n❌ DON'T:\n- Skip symbol packages\n- Hardcode version numbers\n- Mix package sources\n- Ignore package validation\n- Skip README files\n\n## Migration Guidelines\n\nWhen moving from complex build systems to `dotnet` CLI:\n\n1. **Analyze Current Build**\n   - List all build tasks\n   - Identify custom logic\n   - Document dependencies\n   - Note platform-specific code\n\n2. **Plan Migration**\n   - Map tasks to `dotnet` commands\n   - Identify scripts needed\n   - Plan folder structure\n   - Set up new pipelines\n\n3. **Execute Migration**\n   - Create new script structure\n   - Convert build tasks\n   - Update CI/CD pipelines\n   - Test thoroughly\n   - Run in parallel with old system\n\n4. **Validate**\n   - Cross-platform testing\n   - Build verification\n   - Package validation\n   - Pipeline testing\n   - Documentation update\n\n## Best Practices Summary\n\n1. **Script Organization**\n   - One purpose per script\n   - Clear error handling\n   - Consistent naming\n   - Proper documentation\n   - Cross-platform compatibility\n\n2. **Pipeline Structure**\n   - Template-based design\n   - Clear step organization\n   - Proper condition handling\n   - Result publishing\n   - Artifact management\n\n3. **Version Control**\n   - Single source of truth\n   - Automated updates\n   - Consistent formatting\n   - Clear documentation\n   - Proper validation\n\n4. **Testing Strategy**\n   - Separate test types\n   - Clear result reporting\n   - Proper error handling\n   - Complete coverage\n   - Performance consideration\n\n5. **Documentation**\n   - Clear prerequisites\n   - Step-by-step guides\n   - Troubleshooting tips\n   - Example commands\n   - Version history\n\n## Version Management Helper Functions\n\n### Release Notes Parser (getReleaseNotes.ps1)\nThis script parses the RELEASE_NOTES.md file to extract version information and notes:\n\n```powershell\nfunction Get-ReleaseNotes {\n    param (\n        [Parameter(Mandatory=$true)]\n        [string]$MarkdownFile\n    )\n\n    # Read markdown file content\n    $content = Get-Content -Path $MarkdownFile -Raw\n\n    # Split content based on headers\n    $sections = $content -split \"####\"\n\n    # Output object to store result\n    $outputObject = [PSCustomObject]@{\n        Version       = $null\n        Date          = $null\n        ReleaseNotes  = $null\n    }\n\n    # Check if we have at least 3 sections (1. Before the header, 2. Header, 3. Release notes)\n    if ($sections.Count -ge 3) {\n        $header = $sections[1].Trim()\n        $releaseNotes = $sections[2].Trim()\n\n        # Extract version and date from the header\n        $headerParts = $header -split \" \", 2\n        if ($headerParts.Count -eq 2) {\n            $outputObject.Version = $headerParts[0]\n            $outputObject.Date = $headerParts[1]\n        }\n\n        $outputObject.ReleaseNotes = $releaseNotes\n    }\n\n    return $outputObject\n}\n```\n\n### Version Updater (bumpVersion.ps1)\nThis script updates the version and release notes in Directory.Build.props:\n\n```powershell\nfunction UpdateVersionAndReleaseNotes {\n    param (\n        [Parameter(Mandatory=$true)]\n        [PSCustomObject]$ReleaseNotesResult,\n\n        [Parameter(Mandatory=$true)]\n        [string]$XmlFilePath\n    )\n\n    if (-not (Test-Path $XmlFilePath)) {\n        throw \"Directory.Build.props not found at: $XmlFilePath\"\n    }\n\n    try {\n        # Load XML\n        $xmlContent = New-Object XML\n        $xmlContent.Load($XmlFilePath)\n\n        # Update VersionPrefix and PackageReleaseNotes\n        $versionPrefixElement = $xmlContent.SelectSingleNode(\"//VersionPrefix\")\n        if ($null -eq $versionPrefixElement) {\n            throw \"VersionPrefix element not found in Directory.Build.props\"\n        }\n        $versionPrefixElement.InnerText = $ReleaseNotesResult.Version\n\n        $packageReleaseNotesElement = $xmlContent.SelectSingleNode(\"//PackageReleaseNotes\")\n        if ($null -eq $packageReleaseNotesElement) {\n            throw \"PackageReleaseNotes element not found in Directory.Build.props\"\n        }\n        $packageReleaseNotesElement.InnerText = $ReleaseNotesResult.ReleaseNotes\n\n        # Save the updated XML\n        $xmlContent.Save($XmlFilePath)\n    }\n    catch {\n        throw \"Failed to update Directory.Build.props: $_\"\n    }\n}\n```\n\n### Finding Directory.Build.props\nWhen working with complex repository structures, you might need to locate the correct Directory.Build.props file. Here's a helper function:\n\n```powershell\nfunction Find-DirectoryBuildProps {\n    param (\n        [Parameter(Mandatory=$true)]\n        [string]$StartPath,\n        \n        [Parameter(Mandatory=$false)]\n        [string]$FileName = \"Directory.Build.props\"\n    )\n    \n    # First check if file exists in start path\n    $directPath = Join-Path $StartPath $FileName\n    if (Test-Path $directPath) {\n        return $directPath\n    }\n    \n    # Check src directory if it exists\n    $srcPath = Join-Path $StartPath \"src\" $FileName\n    if (Test-Path $srcPath) {\n        return $srcPath\n    }\n    \n    # Search recursively up to 2 levels deep\n    $searchResults = Get-ChildItem -Path $StartPath -Filter $FileName -Recurse -Depth 2 |\n        Where-Object { $_.Name -eq $FileName }\n    \n    if ($searchResults.Count -eq 0) {\n        throw \"Could not find $FileName in or below $StartPath\"\n    }\n    if ($searchResults.Count -gt 1) {\n        Write-Warning \"Found multiple $FileName files. Using the first one found.\"\n        $searchResults | ForEach-Object { Write-Warning \"Found: $($_.FullName)\" }\n    }\n    \n    return $searchResults[0].FullName\n}\n```\n\n### Complete Version Update Example\nHere's how to use these functions together in your build script:\n\n```powershell\n[CmdletBinding()]\nparam(\n    [Parameter(Mandatory=$false)]\n    [string]$Configuration = \"Release\"\n)\n\n$ErrorActionPreference = 'Stop'\n\n# Import helper functions\n. \"$PSScriptRoot\\scripts\\getReleaseNotes.ps1\"\n. \"$PSScriptRoot\\scripts\\bumpVersion.ps1\"\n\ntry {\n    # Find Directory.Build.props\n    $buildPropsPath = Find-DirectoryBuildProps -StartPath $PSScriptRoot\n    Write-Host \"Found Directory.Build.props at: $buildPropsPath\"\n    \n    # Parse release notes\n    $releaseNotesPath = Join-Path $PSScriptRoot \"RELEASE_NOTES.md\"\n    $releaseNotes = Get-ReleaseNotes -MarkdownFile $releaseNotesPath\n    \n    if ($null -eq $releaseNotes.Version) {\n        throw \"Failed to parse version from RELEASE_NOTES.md\"\n    }\n    \n    Write-Host \"Updating to version $($releaseNotes.Version)\"\n    \n    # Update version information\n    UpdateVersionAndReleaseNotes -ReleaseNotesResult $releaseNotes -XmlFilePath $buildPropsPath\n    \n    Write-Host \"Successfully updated version and release notes\"\n}\ncatch {\n    Write-Error \"Failed to update version: $_\"\n    exit 1\n}\n```\n\n### Common Version Management Issues\n\n#### ✅ DO:\n- Validate release notes format before parsing\n- Handle multiple Directory.Build.props files gracefully\n- Provide clear error messages for parsing failures\n- Back up files before making changes\n- Log all version updates\n\n#### ❌ DON'T:\n- Assume file locations without verification\n- Skip error handling in XML operations\n- Overwrite files without validation\n- Ignore malformed release notes\n- Make partial updates\n\n### Troubleshooting Version Updates\n\n1. **Release Notes Not Parsed**\n   - Check exact format matches template\n   - Verify no extra spaces in header\n   - Ensure proper line endings (CRLF vs LF)\n   - Validate bullet point format\n\n2. **Directory.Build.props Not Found**\n   - Check repository structure\n   - Verify search path is correct\n   - Look for case sensitivity issues\n   - Check file permissions\n\n3. **XML Update Failures**\n   - Verify XML is well-formed\n   - Check for required elements\n   - Ensure proper namespace handling\n   - Validate XML schema\n\n4. **Version Format Issues**\n   - Ensure semantic versioning\n   - Check for pre-release tag format\n   - Validate build metadata\n   - Verify version string parsing \n\n## Command Delegation and Error Handling\n\n### When to Use `dotnet` CLI vs PowerShell\n\n#### Use `dotnet` CLI Directly For:\n- Building projects and solutions\n- Running tests\n- Creating NuGet packages\n- Publishing applications\n- Restoring packages\n- Managing project references\n\nExample of proper `dotnet` CLI usage:\n```powershell\n# Direct command - no need for script wrapping\ndotnet build -c Release\n\n# Test with proper logger configuration\ndotnet test -c Release --no-build --logger:trx\n\n# Package creation with symbols\ndotnet pack -c Release --include-symbols\n```\n\n#### Use PowerShell Scripts For:\n- Version management and release notes parsing\n- Complex integration test orchestration\n- Environment setup and validation\n- Tasks requiring file system operations\n- Multi-step processes with error aggregation\n- Custom build task orchestration\n\n### Error Handling Patterns\n\n#### ❌ Anti-Pattern: Shell Script Error Masking\n```powershell\n# DON'T DO THIS: Masks real exit codes\ntry {\n    dotnet test\n    if ($LASTEXITCODE -ne 0) { \n        Write-Warning \"Tests failed but continuing...\"\n        $LASTEXITCODE = 0  # WRONG: Masks the real failure\n    }\n}\ncatch {\n    Write-Warning \"Error occurred but continuing...\"\n}\n```\n\n#### ✅ Correct Pattern: Preserve Exit Codes\n```powershell\n# DO THIS: Preserves exit codes and handles expected failures properly\nfunction Invoke-Test {\n    param(\n        [string]$TestName,\n        [scriptblock]$TestScript,\n        [bool]$ExpectFailure = $false\n    )\n    \n    try {\n        & $TestScript\n        $exitCode = $LASTEXITCODE\n        \n        if ($exitCode -ne 0 -and -not $ExpectFailure) {\n            Write-Host \"Test failed: $TestName (Exit code: $exitCode)\" -ForegroundColor Red\n            return $false\n        }\n        if ($exitCode -eq 0 -and $ExpectFailure) {\n            Write-Host \"Test succeeded unexpectedly: $TestName\" -ForegroundColor Red\n            return $false\n        }\n        \n        Write-Host \"Test completed as expected: $TestName\" -ForegroundColor Green\n        return $true\n    }\n    catch {\n        Write-Host \"Test threw exception: $TestName`n$_\" -ForegroundColor Red\n        return $false\n    }\n}\n```\n\n### Command Delegation Guidelines\n\n#### ✅ DO:\n- Let `dotnet` CLI handle all build operations\n- Use `--no-build` when running tests after build\n- Pass through exit codes faithfully\n- Collect all errors before exiting\n- Use proper logging and verbosity settings\n\n#### ❌ DON'T:\n- Wrap simple `dotnet` commands in scripts\n- Mask or ignore exit codes\n- Mix build configurations\n- Handle MSBuild properties in scripts\n- Reimplement `dotnet` CLI functionality\n\n### Examples of Proper Delegation\n\n#### Build and Test Pipeline\n```powershell\n# DON'T DO THIS:\nfunction Build-AndTest {\n    # Wrong: Unnecessary wrapping of dotnet commands\n    dotnet restore\n    if ($LASTEXITCODE -eq 0) {\n        dotnet build\n        if ($LASTEXITCODE -eq 0) {\n            dotnet test\n        }\n    }\n}\n\n# DO THIS INSTEAD:\n# In pipeline YAML:\nsteps:\n  - script: dotnet build -c Release\n    displayName: 'Build'\n    \n  - script: dotnet test -c Release --no-build\n    displayName: 'Test'\n```\n\n#### Integration Test Runner\n```powershell\n# Proper balance of script logic and dotnet commands\nfunction Start-IntegrationTest {\n    param(\n        [string]$ProjectPath,\n        [string]$Configuration = \"Release\"\n    )\n    \n    # Script handles:\n    # 1. Test environment setup\n    # 2. Result aggregation\n    # 3. Error tracking\n    $results = @{\n        Passed = 0\n        Failed = 0\n        Errors = @()\n    }\n    \n    # Let dotnet handle the actual operations\n    $tests = @(\n        @{ Name = \"Basic\"; Args = @(\"--filter\", \"Category=Basic\") }\n        @{ Name = \"Extended\"; Args = @(\"--filter\", \"Category=Extended\") }\n    )\n    \n    foreach ($test in $tests) {\n        Write-Host \"Running $($test.Name) tests...\"\n        \n        # Delegate to dotnet for the actual test execution\n        dotnet test $ProjectPath -c $Configuration --no-build @($test.Args)\n        \n        if ($LASTEXITCODE -ne 0) {\n            $results.Failed++\n            $results.Errors += \"Test '$($test.Name)' failed with exit code $LASTEXITCODE\"\n        } else {\n            $results.Passed++\n        }\n    }\n    \n    # Script handles result reporting\n    if ($results.Failed -gt 0) {\n        Write-Host \"Test Summary: $($results.Passed) passed, $($results.Failed) failed\"\n        $results.Errors | ForEach-Object { Write-Host \"  $_\" -ForegroundColor Red }\n        exit 1\n    }\n    \n    Write-Host \"All tests passed!\" -ForegroundColor Green\n    exit 0\n}\n```\n\n### Error Code Handling\n\n#### Exit Code Principles\n1. Never mask unexpected failures\n2. Track expected failures separately\n3. Run all tests before exiting\n4. Provide clear error summaries\n5. Use proper exit codes\n\n```powershell\n# Example of proper error tracking\n$script:hasUnexpectedFailures = $false\n$script:expectedFailures = 0\n$script:totalTests = 0\n\ntry {\n    # Run all tests even if some fail\n    foreach ($test in $tests) {\n        $script:totalTests++\n        \n        & $test.Command\n        if ($LASTEXITCODE -ne 0) {\n            if ($test.ExpectFailure) {\n                $script:expectedFailures++\n            } else {\n                $script:hasUnexpectedFailures = $true\n            }\n        }\n    }\n    \n    # Exit with failure only if we had unexpected failures\n    exit $script:hasUnexpectedFailures ? 1 : 0\n}\ncatch {\n    Write-Error \"Test execution failed: $_\"\n    exit 1\n}\n```\n\n### When to Create Helper Scripts\n\nCreate PowerShell scripts only when you need to:\n1. Orchestrate multiple `dotnet` commands\n2. Set up test environments\n3. Aggregate results from multiple operations\n4. Handle expected failures\n5. Provide custom logging or reporting\n6. Manage file system operations\n\nOtherwise, use `dotnet` CLI directly in your build pipeline. ",
    "sourceUrl": "https://github.com/Aaronontheweb/dotnet-cursor-rules/blob/master/ci-cd/dotnet-build.mdc",
    "version": "1.0.0",
    "metadata": {
      "originalPath": "ci-cd/dotnet-build.mdc",
      "sha": "43e23376a894e5cc4f89bb5dac62b07d1f8feb73"
    }
  },
  {
    "name": "aaronontheweb-csharp-coding-style",
    "slug": "csharp-coding-style",
    "displayName": "csharp coding style",
    "description": "csharp coding style for .NET development",
    "author": "Aaronontheweb",
    "type": "cursor",
    "category": "languages",
    "tags": [
      "cursor",
      "cursor-rule",
      "dotnet",
      "csharp"
    ],
    "content": "---\ndescription: his file provides guidelines for writing clean, maintainable, and idiomatic C# code with a focus on functional patterns and proper abstraction.\nglobs: *.cs\nalwaysApply: false\n---\n\nRole Definition:\n - C# Language Expert\n - Software Architect\n - Code Quality Specialist\n\nGeneral:\n  Description: >\n    C# code should be written to maximize readability, maintainability, and correctness\n    while minimizing complexity and coupling. Prefer functional patterns and immutable\n    data where appropriate, and keep abstractions simple and focused.\n  Requirements:\n    - Write clear, self-documenting code\n    - Keep abstractions simple and focused\n    - Minimize dependencies and coupling\n    - Use modern C# features appropriately\n\nType Definitions:\n  - Prefer records for data types:\n      ```csharp\n      // Good: Immutable data type with value semantics\n      public sealed record CustomerDto(string Name, Email Email);\n      \n      // Avoid: Class with mutable properties\n      public class Customer\n      {\n          public string Name { get; set; }\n          public string Email { get; set; }\n      }\n      ```\n  - Make classes sealed by default:\n      ```csharp\n      // Good: Sealed by default\n      public sealed class OrderProcessor\n      {\n          // Implementation\n      }\n      \n      // Only unsealed when inheritance is specifically designed for\n      public abstract class Repository<T>\n      {\n          // Base implementation\n      }\n      ```\n  - Use value objects to avoid primitive obsession:\n      ```csharp\n      // Good: Strong typing with value objects\n      public sealed record OrderId(Guid Value)\n      {\n          public static OrderId New() => new(Guid.NewGuid());\n          public static OrderId From(string value) => new(Guid.Parse(value));\n      }\n      \n      // Avoid: Primitive types for identifiers\n      public class Order\n      {\n          public Guid Id { get; set; }  // Primitive obsession\n      }\n      ```\n\nFunctional Patterns:\n  - Use pattern matching effectively:\n      ```csharp\n      // Good: Clear pattern matching\n      public decimal CalculateDiscount(Customer customer) =>\n          customer switch\n          {\n              { Tier: CustomerTier.Premium } => 0.2m,\n              { OrderCount: > 10 } => 0.1m,\n              _ => 0m\n          };\n      \n      // Avoid: Nested if statements\n      public decimal CalculateDiscount(Customer customer)\n      {\n          if (customer.Tier == CustomerTier.Premium)\n              return 0.2m;\n          if (customer.OrderCount > 10)\n              return 0.1m;\n          return 0m;\n      }\n      ```\n  - Prefer pure methods:\n      ```csharp\n      // Good: Pure function\n      public static decimal CalculateTotalPrice(\n          IEnumerable<OrderLine> lines,\n          decimal taxRate) =>\n          lines.Sum(line => line.Price * line.Quantity) * (1 + taxRate);\n      \n      // Avoid: Method with side effects\n      public void CalculateAndUpdateTotalPrice()\n      {\n          this.Total = this.Lines.Sum(l => l.Price * l.Quantity);\n          this.UpdateDatabase();\n      }\n      ```\n\nCode Organization:\n  - Separate state from behavior:\n      ```csharp\n      // Good: Behavior separate from state\n      public sealed record Order(OrderId Id, List<OrderLine> Lines);\n      \n      public static class OrderOperations\n      {\n          public static decimal CalculateTotal(Order order) =>\n              order.Lines.Sum(line => line.Price * line.Quantity);\n      }\n      ```\n  - Use extension methods appropriately:\n      ```csharp\n      // Good: Extension method for domain-specific operations\n      public static class OrderExtensions\n      {\n          public static bool CanBeFulfilled(this Order order, Inventory inventory) =>\n              order.Lines.All(line => inventory.HasStock(line.ProductId, line.Quantity));\n      }\n      ```\n\nDependency Management:\n  - Minimize constructor injection:\n      ```csharp\n      // Good: Minimal dependencies\n      public sealed class OrderProcessor\n      {\n          private readonly IOrderRepository _repository;\n          \n          public OrderProcessor(IOrderRepository repository)\n          {\n              _repository = repository;\n          }\n      }\n      \n      // Avoid: Too many dependencies\n      public class OrderProcessor\n      {\n          public OrderProcessor(\n              IOrderRepository repository,\n              ILogger logger,\n              IEmailService emailService,\n              IMetrics metrics,\n              IValidator validator)\n          {\n              // Too many dependencies indicates possible design issues\n          }\n      }\n      ```\n  - Prefer composition with interfaces:\n      ```csharp\n      // Good: Composition with interfaces\n      public sealed class EnhancedLogger : ILogger\n      {\n          private readonly ILogger _baseLogger;\n          private readonly IMetrics _metrics;\n          \n          public EnhancedLogger(ILogger baseLogger, IMetrics metrics)\n          {\n              _baseLogger = baseLogger;\n              _metrics = metrics;\n          }\n      }\n      ```\n\nCode Clarity:\n    - Prefer range indexers over LINQ:\n      ```csharp\n      // Good: Using range indexers with clear comments\n      var lastItem = items[^1];  // ^1 means \"1 from the end\"\n      var firstThree = items[..3];  // ..3 means \"take first 3 items\"\n      var slice = items[2..5];  // take items from index 2 to 4 (5 exclusive)\n      \n      // Avoid: Using LINQ when range indexers are clearer\n      var lastItem = items.LastOrDefault();\n      var firstThree = items.Take(3).ToList();\n      var slice = items.Skip(2).Take(3).ToList();\n      ```\n  - Use meaningful names:\n      ```csharp\n      // Good: Clear intent\n      public async Task<Result<Order>> ProcessOrderAsync(\n          OrderRequest request,\n          CancellationToken cancellationToken)\n      \n      // Avoid: Unclear abbreviations\n      public async Task<Result<T>> ProcAsync<T>(ReqDto r, CancellationToken ct)\n      ```\n\nError Handling:\n  - Use Result types for expected failures:\n      ```csharp\n      // Good: Explicit error handling\n      public sealed record Result<T>\n      {\n          public T? Value { get; }\n          public Error? Error { get; }\n          \n          private Result(T value) => Value = value;\n          private Result(Error error) => Error = error;\n          \n          public static Result<T> Success(T value) => new(value);\n          public static Result<T> Failure(Error error) => new(error);\n      }\n      ```\n  - Prefer exceptions for exceptional cases:\n      ```csharp\n      // Good: Exception for truly exceptional case\n      public static OrderId From(string value)\n      {\n          if (!Guid.TryParse(value, out var guid))\n              throw new ArgumentException(\"Invalid OrderId format\", nameof(value));\n          \n          return new OrderId(guid);\n      }\n      ```\n\nTesting Considerations:\n  - Design for testability:\n      ```csharp\n      // Good: Easy to test pure functions\n      public static class PriceCalculator\n      {\n          public static decimal CalculateDiscount(\n              decimal price,\n              int quantity,\n              CustomerTier tier) =>\n              // Pure calculation\n      }\n      \n      // Avoid: Hard to test due to hidden dependencies\n      public decimal CalculateDiscount()\n      {\n          var user = _userService.GetCurrentUser();  // Hidden dependency\n          var settings = _configService.GetSettings(); // Hidden dependency\n          // Calculation\n      }\n      ```\n\nImmutable Collections:\n  - Use System.Collections.Immutable with records:\n      ```csharp\n      // Good: Immutable collections in records\n      public sealed record Order(\n          OrderId Id, \n          ImmutableList<OrderLine> Lines,\n          ImmutableDictionary<string, string> Metadata);\n      \n      // Avoid: Mutable collections in records\n      public record Order(\n          OrderId Id,\n          List<OrderLine> Lines,  // Can be modified after creation\n          Dictionary<string, string> Metadata);\n      ```\n  - Initialize immutable collections efficiently:\n      ```csharp\n      // Good: Using builder pattern\n      var builder = ImmutableList.CreateBuilder<OrderLine>();\n      foreach (var line in lines)\n      {\n          builder.Add(line);\n      }\n      return new Order(id, builder.ToImmutable());\n      \n      // Also Good: Using collection initializer\n      return new Order(\n          id,\n          lines.ToImmutableList(),\n          metadata.ToImmutableDictionary());\n      ```\n\n// ... existing code ...\n\nError Handling:\n  - Use Result types for expected failures:\n      ```csharp\n      // Good: Explicit error handling\n      public sealed record Result<T>\n      {\n          public T? Value { get; }\n          public Error? Error { get; }\n          \n          private Result(T value) => Value = value;\n          private Result(Error error) => Error = error;\n          \n          public static Result<T> Success(T value) => new(value);\n          public static Result<T> Failure(Error error) => new(error);\n      }\n      ```\n  - Prefer exceptions for exceptional cases:\n      ```csharp\n      // Good: Exception for truly exceptional case\n      public static OrderId From(string value)\n      {\n          if (!Guid.TryParse(value, out var guid))\n              throw new ArgumentException(\"Invalid OrderId format\", nameof(value));\n          \n          return new OrderId(guid);\n      }\n      ```\n\nSafe Operations:\n  - Use Try methods for safer operations:\n      ```csharp\n      // Good: Using TryGetValue for dictionary access\n      if (dictionary.TryGetValue(key, out var value))\n      {\n          // Use value safely here\n      }\n      else\n      {\n          // Handle missing key case\n      }\n\n      // Avoid: Direct indexing which can throw\n      var value = dictionary[key];  // Throws if key doesn't exist\n\n      // Good: Using Uri.TryCreate for URL parsing\n      if (Uri.TryCreate(urlString, UriKind.Absolute, out var uri))\n      {\n          // Use uri safely here\n      }\n      else\n      {\n          // Handle invalid URL case\n      }\n\n      // Avoid: Direct Uri creation which can throw\n      var uri = new Uri(urlString);  // Throws on invalid URL\n\n      // Good: Using int.TryParse for number parsing\n      if (int.TryParse(input, out var number))\n      {\n          // Use number safely here\n      }\n      else\n      {\n          // Handle invalid number case\n      }\n\n      // Good: Combining Try methods with null coalescing\n      var value = dictionary.TryGetValue(key, out var result)\n          ? result\n          : defaultValue;\n\n      // Good: Using Try methods in LINQ with pattern matching\n      var validNumbers = strings\n          .Select(s => (Success: int.TryParse(s, out var num), Value: num))\n          .Where(x => x.Success)\n          .Select(x => x.Value);\n      ```\n      \n  - Prefer Try methods over exception handling:\n      ```csharp\n      // Good: Using Try method\n      if (decimal.TryParse(priceString, out var price))\n      {\n          // Process price\n      }\n\n      // Avoid: Exception handling for expected cases\n      try\n      {\n          var price = decimal.Parse(priceString);\n          // Process price\n      }\n      catch (FormatException)\n      {\n          // Handle invalid format\n      }\n      ```\n\nAsynchronous Programming:\n  - Avoid async void:\n      ```csharp\n      // Good: Async method returns Task\n      public async Task ProcessOrderAsync(Order order)\n      {\n          await _repository.SaveAsync(order);\n      }\n      \n      // Avoid: Async void can crash your application\n      public async void ProcessOrder(Order order)\n      {\n          await _repository.SaveAsync(order);\n      }\n      ```\n  - Use Task.FromResult for pre-computed values:\n      ```csharp\n      // Good: Return pre-computed value\n      public Task<int> GetDefaultQuantityAsync() =>\n          Task.FromResult(1);\n      \n      // Better: Use ValueTask for zero allocations\n      public ValueTask<int> GetDefaultQuantityAsync() =>\n          new ValueTask<int>(1);\n      \n      // Avoid: Unnecessary thread pool usage\n      public Task<int> GetDefaultQuantityAsync() =>\n          Task.Run(() => 1);\n      ```\n  - Always flow CancellationToken:\n      ```csharp\n      // Good: Propagate cancellation\n      public async Task<Order> ProcessOrderAsync(\n          OrderRequest request,\n          CancellationToken cancellationToken)\n      {\n          var order = await _repository.GetAsync(\n              request.OrderId, \n              cancellationToken);\n              \n          await _processor.ProcessAsync(\n              order, \n              cancellationToken);\n              \n          return order;\n      }\n      ```\n  - Prefer await over ContinueWith:\n      ```csharp\n      // Good: Using await\n      public async Task<Order> ProcessOrderAsync(OrderId id)\n      {\n          var order = await _repository.GetAsync(id);\n          await _validator.ValidateAsync(order);\n          return order;\n      }\n      \n      // Avoid: Using ContinueWith\n      public Task<Order> ProcessOrderAsync(OrderId id)\n      {\n          return _repository.GetAsync(id)\n              .ContinueWith(t => \n              {\n                  var order = t.Result; // Can deadlock\n                  return _validator.ValidateAsync(order);\n              });\n      }\n      ```\n  - Never use Task.Result or Task.Wait:\n      ```csharp\n      // Good: Async all the way\n      public async Task<Order> GetOrderAsync(OrderId id)\n      {\n          return await _repository.GetAsync(id);\n      }\n      \n      // Avoid: Blocking on async code\n      public Order GetOrder(OrderId id)\n      {\n          return _repository.GetAsync(id).Result; // Can deadlock\n      }\n      ```\n  - Use TaskCompletionSource correctly:\n      ```csharp\n      // Good: Using RunContinuationsAsynchronously\n      private readonly TaskCompletionSource<Order> _tcs = \n          new(TaskCreationOptions.RunContinuationsAsynchronously);\n      \n      // Avoid: Default TaskCompletionSource can cause deadlocks\n      private readonly TaskCompletionSource<Order> _tcs = new();\n      ```\n  - Always dispose CancellationTokenSources:\n      ```csharp\n      // Good: Proper disposal of CancellationTokenSource\n      public async Task<Order> GetOrderWithTimeout(OrderId id)\n      {\n          using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));\n          return await _repository.GetAsync(id, cts.Token);\n      }\n      ```\n  - Prefer async/await over direct Task return:\n      ```csharp\n      // Good: Using async/await\n      public async Task<Order> ProcessOrderAsync(OrderRequest request)\n      {\n          await _validator.ValidateAsync(request);\n          var order = await _factory.CreateAsync(request);\n          return order;\n      }\n      \n      // Avoid: Manual task composition\n      public Task<Order> ProcessOrderAsync(OrderRequest request)\n      {\n          return _validator.ValidateAsync(request)\n              .ContinueWith(t => _factory.CreateAsync(request))\n              .Unwrap();\n      }\n      ```\n\nNullability:\n  - Enable nullable reference types:\n      ```xml\n      <PropertyGroup>\n        <Nullable>enable</Nullable>\n        <WarningsAsErrors>nullable</WarningsAsErrors>\n      </PropertyGroup>\n      ```\n  - Mark nullable fields explicitly:\n      ```csharp\n      // Good: Explicit nullability\n      public class OrderProcessor\n      {\n          private readonly ILogger<OrderProcessor>? _logger;\n          private string? _lastError;\n          \n          public OrderProcessor(ILogger<OrderProcessor>? logger = null)\n          {\n              _logger = logger;\n          }\n      }\n      \n      // Avoid: Implicit nullability\n      public class OrderProcessor\n      {\n          private readonly ILogger<OrderProcessor> _logger; // Warning: Could be null\n          private string _lastError; // Warning: Could be null\n      }\n      ```\n  - Use null checks appropriately:\n      ```csharp\n      // Good: Proper null checking\n      public void ProcessOrder(Order? order)\n      {\n          if (order is null)\n              throw new ArgumentNullException(nameof(order));\n              \n          _logger?.LogInformation(\"Processing order {Id}\", order.Id);\n      }\n      \n      // Good: Using pattern matching for null checks\n      public decimal CalculateTotal(Order? order) =>\n          order switch\n          {\n              null => throw new ArgumentNullException(nameof(order)),\n              { Lines: null } => throw new ArgumentException(\"Order lines cannot be null\", nameof(order)),\n              _ => order.Lines.Sum(l => l.Total)\n          };\n      ```\n  - Use null-forgiving operator when appropriate:\n      ```csharp\n      public class OrderValidator\n      {\n          private readonly IValidator<Order> _validator;\n          \n          public OrderValidator(IValidator<Order> validator)\n          {\n              _validator = validator ?? throw new ArgumentNullException(nameof(validator));\n          }\n          \n          public ValidationResult Validate(Order order)\n          {\n              // We know _validator can't be null due to constructor check\n              return _validator!.Validate(order);\n          }\n      }\n      ```\n  - Use nullability attributes:\n      ```csharp\n      public class StringUtilities\n      {\n          // Output is non-null if input is non-null\n          [return: NotNullIfNotNull(nameof(input))]\n          public static string? ToUpperCase(string? input) =>\n              input?.ToUpperInvariant();\n          \n          // Method never returns null\n          [return: NotNull]\n          public static string EnsureNotNull(string? input) =>\n              input ?? string.Empty;\n          \n          // Parameter must not be null when method returns true\n          public static bool TryParse(string? input, [NotNullWhen(true)] out string? result)\n          {\n              result = null;\n              if (string.IsNullOrEmpty(input))\n                  return false;\n                  \n              result = input;\n              return true;\n          }\n      }\n      ```\n  - Use init-only properties with non-null validation:\n      ```csharp\n      // Good: Non-null validation in constructor\n      public sealed record Order\n      {\n          public required OrderId Id { get; init; }\n          public required ImmutableList<OrderLine> Lines { get; init; }\n          \n          public Order()\n          {\n              Id = null!; // Will be set by required property\n              Lines = null!; // Will be set by required property\n          }\n          \n          private Order(OrderId id, ImmutableList<OrderLine> lines)\n          {\n              Id = id;\n              Lines = lines;\n          }\n          \n          public static Order Create(OrderId id, IEnumerable<OrderLine> lines) =>\n              new(id, lines.ToImmutableList());\n      }\n      ```\n  - Document nullability in interfaces:\n      ```csharp\n      public interface IOrderRepository\n      {\n          // Explicitly shows that null is a valid return value\n          Task<Order?> FindByIdAsync(OrderId id, CancellationToken ct = default);\n          \n          // Method will never return null\n          [return: NotNull]\n          Task<IReadOnlyList<Order>> GetAllAsync(CancellationToken ct = default);\n          \n          // Parameter cannot be null\n          Task SaveAsync([NotNull] Order order, CancellationToken ct = default);\n      }\n      ```\n\nSymbol References:\n  - Always use nameof operator:\n      ```csharp\n      // Good: Using nameof for parameter names\n      public void ProcessOrder(Order order)\n      {\n          if (order is null)\n              throw new ArgumentNullException(nameof(order));\n      }\n      \n      // Good: Using nameof for property names\n      public class Customer\n      {\n          private string _email;\n          \n          public string Email\n          {\n              get => _email;\n              set => _email = value ?? throw new ArgumentNullException(nameof(value));\n          }\n          \n          public void UpdateEmail(string newEmail)\n          {\n              if (string.IsNullOrEmpty(newEmail))\n                  throw new ArgumentException(\"Email cannot be empty\", nameof(newEmail));\n              \n              Email = newEmail;\n          }\n      }\n      \n      // Good: Using nameof in attributes\n      public class OrderProcessor\n      {\n          [Required(ErrorMessage = \"The {0} field is required\")]\n          [Display(Name = nameof(OrderId))]\n          public string OrderId { get; init; }\n          \n          [MemberNotNull(nameof(_repository))]\n          private void InitializeRepository()\n          {\n              _repository = new OrderRepository();\n          }\n          \n          [NotifyPropertyChangedFor(nameof(FullName))]\n          public string FirstName\n          {\n              get => _firstName;\n              set => SetProperty(ref _firstName, value);\n          }\n      }\n      \n      // Avoid: Hard-coded string references\n      public void ProcessOrder(Order order)\n      {\n          if (order is null)\n              throw new ArgumentNullException(\"order\"); // Breaks refactoring\n      }\n      ```\n  - Use nameof with exceptions:\n      ```csharp\n      public class OrderService\n      {\n          public async Task<Order> GetOrderAsync(OrderId id, CancellationToken ct)\n          {\n              var order = await _repository.FindAsync(id, ct);\n              \n              if (order is null)\n                  throw new OrderNotFoundException(\n                      $\"Order with {nameof(id)} '{id}' not found\");\n                      \n              if (!order.Lines.Any())\n                  throw new InvalidOperationException(\n                      $\"{nameof(order.Lines)} cannot be empty\");\n                      \n              return order;\n          }\n          \n          public void ValidateOrder(Order order)\n          {\n              ArgumentNullException.ThrowIfNull(order, nameof(order));\n              \n              if (order.Lines.Count == 0)\n                  throw new ArgumentException(\n                      \"Order must have at least one line\",\n                      nameof(order));\n          }\n      }\n      ```\n  - Use nameof in logging:\n      ```csharp\n      public class OrderProcessor\n      {\n          private readonly ILogger<OrderProcessor> _logger;\n          \n          public async Task ProcessAsync(Order order)\n          {\n              _logger.LogInformation(\n                  \"Starting {Method} for order {OrderId}\",\n                  nameof(ProcessAsync),\n                  order.Id);\n                  \n              try\n              {\n                  await ProcessInternalAsync(order);\n              }\n              catch (Exception ex)\n              {\n                  _logger.LogError(\n                      ex,\n                      \"Error in {Method} for {Property} {Value}\",\n                      nameof(ProcessAsync),\n                      nameof(order.Id),\n                      order.Id);\n                  throw;\n              }\n          }\n      }\n      ```\n\n# End of Cursor Rules File ",
    "sourceUrl": "https://github.com/Aaronontheweb/dotnet-cursor-rules/blob/master/csharp/coding-style.mdc",
    "version": "1.0.0",
    "metadata": {
      "originalPath": "csharp/coding-style.mdc",
      "sha": "7e6df26e4bafd3291397633b8791e835e7d1c840"
    }
  },
  {
    "name": "aaronontheweb-csharp-testing",
    "slug": "csharp-testing",
    "displayName": "csharp testing",
    "description": "csharp testing for .NET development",
    "author": "Aaronontheweb",
    "type": "cursor",
    "category": "languages",
    "tags": [
      "cursor",
      "cursor-rule",
      "dotnet",
      "csharp"
    ],
    "content": "---\ndescription: This file provides guidelines for writing effective, maintainable tests using xUnit and related tools.\nglobs: *.cs,*.Tests.csproj\nalwaysApply: false\n---\n\nRole Definition:\n - Test Engineer\n - Quality Assurance Specialist\n - CI/CD Expert\n\nGeneral:\n  Description: >\n    Tests should be reliable, maintainable, and provide meaningful coverage.\n    Use xUnit as the primary testing framework, with proper isolation and\n    clear patterns for test organization and execution.\n  Requirements:\n    - Use xUnit as the testing framework\n    - Ensure test isolation\n    - Follow consistent patterns\n    - Maintain high code coverage\n    - Configure proper CI/CD test execution\n\nProject Setup:\n  - Configure test projects:\n      ```xml\n      <Project Sdk=\"Microsoft.NET.Sdk\">\n        <PropertyGroup>\n          <TargetFramework>net8.0</TargetFramework>\n          <IsPackable>false</IsPackable>\n          <IsTestProject>true</IsTestProject>\n          <CollectCoverage>true</CollectCoverage>\n          <CoverletOutputFormat>cobertura</CoverletOutputFormat>\n        </PropertyGroup>\n        \n        <ItemGroup>\n          <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"17.8.0\" />\n          <PackageReference Include=\"xunit\" Version=\"2.6.2\" />\n          <PackageReference Include=\"xunit.runner.visualstudio\" Version=\"2.5.4\" />\n          <PackageReference Include=\"coverlet.collector\" Version=\"6.0.0\" />\n          <PackageReference Include=\"coverlet.msbuild\" Version=\"6.0.0\" />\n        </ItemGroup>\n      </Project>\n      ```\n\nTest Class Structure:\n  - Use ITestOutputHelper for logging:\n      ```csharp\n      public class OrderProcessingTests\n      {\n          private readonly ITestOutputHelper _output;\n          \n          public OrderProcessingTests(ITestOutputHelper output)\n          {\n              _output = output;\n          }\n          \n          [Fact]\n          public async Task ProcessOrder_ValidOrder_Succeeds()\n          {\n              _output.WriteLine(\"Starting test with valid order\");\n              // Test implementation\n          }\n      }\n      ```\n  - Use fixtures for shared state:\n      ```csharp\n      public class DatabaseFixture : IAsyncLifetime\n      {\n          public DbConnection Connection { get; private set; }\n          \n          public async Task InitializeAsync()\n          {\n              Connection = new SqlConnection(\"connection-string\");\n              await Connection.OpenAsync();\n          }\n          \n          public async Task DisposeAsync()\n          {\n              await Connection.DisposeAsync();\n          }\n      }\n      \n      public class OrderTests : IClassFixture<DatabaseFixture>\n      {\n          private readonly DatabaseFixture _fixture;\n          private readonly ITestOutputHelper _output;\n          \n          public OrderTests(DatabaseFixture fixture, ITestOutputHelper output)\n          {\n              _fixture = fixture;\n              _output = output;\n          }\n      }\n      ```\n\nTest Methods:\n  - Prefer Theory over multiple Facts:\n      ```csharp\n      public class DiscountCalculatorTests\n      {\n          public static TheoryData<decimal, int, decimal> DiscountTestData => \n              new()\n              {\n                  { 100m, 1, 0m },      // No discount for single item\n                  { 100m, 5, 5m },      // 5% for 5 items\n                  { 100m, 10, 10m },    // 10% for 10 items\n              };\n          \n          [Theory]\n          [MemberData(nameof(DiscountTestData))]\n          public void CalculateDiscount_ReturnsCorrectAmount(\n              decimal price,\n              int quantity,\n              decimal expectedDiscount)\n          {\n              // Arrange\n              var calculator = new DiscountCalculator();\n              \n              // Act\n              var discount = calculator.Calculate(price, quantity);\n              \n              // Assert\n              Assert.Equal(expectedDiscount, discount);\n          }\n      }\n      ```\n  - Follow Arrange-Act-Assert pattern:\n      ```csharp\n      [Fact]\n      public async Task ProcessOrder_ValidOrder_UpdatesInventory()\n      {\n          // Arrange\n          var order = new Order(\n              OrderId.New(),\n              new[] { new OrderLine(\"SKU123\", 5) });\n          var processor = new OrderProcessor(_mockRepository.Object);\n          \n          // Act\n          var result = await processor.ProcessAsync(order);\n          \n          // Assert\n          Assert.True(result.IsSuccess);\n          _mockRepository.Verify(\n              r => r.UpdateInventoryAsync(\n                  It.IsAny<string>(),\n                  It.IsAny<int>()),\n              Times.Once);\n      }\n      ```\n\nTest Isolation:\n  - Use fresh data for each test:\n      ```csharp\n      public class OrderTests\n      {\n          private static Order CreateTestOrder() =>\n              new(OrderId.New(), TestData.CreateOrderLines());\n              \n          [Fact]\n          public async Task ProcessOrder_Success()\n          {\n              var order = CreateTestOrder();\n              // Test implementation\n          }\n      }\n      ```\n  - Clean up resources:\n      ```csharp\n      public class IntegrationTests : IAsyncDisposable\n      {\n          private readonly TestServer _server;\n          private readonly HttpClient _client;\n          \n          public IntegrationTests()\n          {\n              _server = new TestServer(CreateHostBuilder());\n              _client = _server.CreateClient();\n          }\n          \n          public async ValueTask DisposeAsync()\n          {\n              _client.Dispose();\n              await _server.DisposeAsync();\n          }\n      }\n      ```\n\nCI/CD Configuration:\n  - Configure test runs:\n      ```yaml\n      - name: Test\n        run: |\n          dotnet test --configuration Release \\\n                      --collect:\"XPlat Code Coverage\" \\\n                      --logger:trx \\\n                      --results-directory ./coverage\n      \n      - name: Upload coverage\n        uses: actions/upload-artifact@v3\n        with:\n          name: coverage-results\n          path: coverage/**\n      ```\n  - Enable code coverage:\n      ```xml\n      <PropertyGroup>\n        <CollectCoverage>true</CollectCoverage>\n        <CoverletOutputFormat>cobertura</CoverletOutputFormat>\n        <CoverletOutput>./coverage/</CoverletOutput>\n        <ThresholdType>line,branch,method</ThresholdType>\n        <ThresholdStat>total</ThresholdStat>\n        <Threshold>80</Threshold>\n      </PropertyGroup>\n      ```\n\nIntegration Testing:\n  - Always use TestContainers for infrastructure:\n      ```csharp\n      // Good: Using TestContainers for database testing\n      public class DatabaseTests : IAsyncLifetime\n      {\n          private readonly TestcontainersContainer _dbContainer;\n          \n          public DatabaseTests()\n          {\n              _dbContainer = new TestcontainersBuilder<TestcontainersContainer>()\n                  .WithImage(\"mcr.microsoft.com/mssql/server:2022-latest\")\n                  .WithEnvironment(\"ACCEPT_EULA\", \"Y\")\n                  .WithEnvironment(\"SA_PASSWORD\", \"Your_password123\")\n                  .WithPortBinding(1433, true)\n                  .Build();\n          }\n          \n          public async Task InitializeAsync()\n          {\n              await _dbContainer.StartAsync();\n          }\n          \n          public async Task DisposeAsync()\n          {\n              await _dbContainer.DisposeAsync();\n          }\n      }\n      \n      // Good: Using TestContainers for Redis testing\n      public class CacheTests : IAsyncLifetime\n      {\n          private readonly TestcontainersContainer _redisContainer;\n          private IConnectionMultiplexer _redis;\n          \n          public CacheTests()\n          {\n              _redisContainer = new TestcontainersBuilder<TestcontainersContainer>()\n                  .WithImage(\"redis:alpine\")\n                  .WithPortBinding(6379, true)\n                  .Build();\n          }\n          \n          public async Task InitializeAsync()\n          {\n              await _redisContainer.StartAsync();\n              _redis = await ConnectionMultiplexer.ConnectAsync(\n                  $\"localhost:{_redisContainer.GetMappedPublicPort(6379)}\");\n          }\n          \n          public async Task DisposeAsync()\n          {\n              if (_redis is not null)\n                  await _redis.DisposeAsync();\n              await _redisContainer.DisposeAsync();\n          }\n      }\n      \n      // Good: Using TestContainers for message queue testing\n      public class MessageQueueTests : IAsyncLifetime\n      {\n          private readonly TestcontainersContainer _rabbitContainer;\n          private IConnection _connection;\n          \n          public MessageQueueTests()\n          {\n              _rabbitContainer = new TestcontainersBuilder<TestcontainersContainer>()\n                  .WithImage(\"rabbitmq:management-alpine\")\n                  .WithPortBinding(5672, true)\n                  .WithPortBinding(15672, true)\n                  .Build();\n          }\n          \n          public async Task InitializeAsync()\n          {\n              await _rabbitContainer.StartAsync();\n              var factory = new ConnectionFactory\n              {\n                  HostName = \"localhost\",\n                  Port = _rabbitContainer.GetMappedPublicPort(5672)\n              };\n              _connection = await factory.CreateConnectionAsync();\n          }\n          \n          public async Task DisposeAsync()\n          {\n              await _connection.CloseAsync();\n              await _rabbitContainer.DisposeAsync();\n          }\n      }\n      ```\n      \n  - Avoid mocking infrastructure:\n      ```csharp\n      // Avoid: Mocking database\n      public class DatabaseTests\n      {\n          private readonly Mock<IDbConnection> _mockDb = new();\n          \n          [Fact]\n          public async Task Test_WithMockedDb()\n          {\n              _mockDb.Setup(db => db.QueryAsync<Order>())\n                  .ReturnsAsync(new[] { new Order() });\n              // Test with mocked database - can miss real database behavior\n          }\n      }\n      \n      // Good: Real database in container\n      public class DatabaseTests : IAsyncLifetime\n      {\n          private readonly TestcontainersContainer _dbContainer;\n          private IDbConnection _db;\n          \n          // ... TestContainers setup as shown above ...\n          \n          [Fact]\n          public async Task Test_WithRealDb()\n          {\n              // Test with real database in container\n              var order = await _db.QuerySingleAsync<Order>(\n                  \"SELECT * FROM Orders WHERE Id = @Id\",\n                  new { Id = 1 });\n          }\n      }\n      ```\n      \n  - Use container networks for multi-container scenarios:\n      ```csharp\n      public class IntegrationTests : IAsyncLifetime\n      {\n          private readonly INetwork _network;\n          private readonly TestcontainersContainer _dbContainer;\n          private readonly TestcontainersContainer _redisContainer;\n          \n          public IntegrationTests()\n          {\n              _network = new TestcontainersNetwork();\n              \n              _dbContainer = new TestcontainersBuilder<TestcontainersContainer>()\n                  .WithImage(\"postgres:latest\")\n                  .WithNetwork(_network)\n                  .WithNetworkAliases(\"db\")\n                  .Build();\n                  \n              _redisContainer = new TestcontainersBuilder<TestcontainersContainer>()\n                  .WithImage(\"redis:alpine\")\n                  .WithNetwork(_network)\n                  .WithNetworkAliases(\"redis\")\n                  .Build();\n          }\n          \n          public async Task InitializeAsync()\n          {\n              await _network.CreateAsync();\n              await Task.WhenAll(\n                  _dbContainer.StartAsync(),\n                  _redisContainer.StartAsync());\n          }\n          \n          public async Task DisposeAsync()\n          {\n              await Task.WhenAll(\n                  _dbContainer.DisposeAsync().AsTask(),\n                  _redisContainer.DisposeAsync().AsTask());\n              await _network.DisposeAsync();\n          }\n      }\n      ```\n\nBest Practices:\n  - Name tests clearly:\n      ```csharp\n      // Good: Clear test names\n      [Fact]\n      public async Task ProcessOrder_WhenInventoryAvailable_UpdatesStockAndReturnsSuccess()\n      \n      // Avoid: Unclear names\n      [Fact]\n      public async Task TestProcessOrder()\n      ```\n  - Use meaningful assertions:\n      ```csharp\n      // Good: Clear assertions\n      Assert.Equal(expected, actual);\n      Assert.Contains(expectedItem, collection);\n      Assert.Throws<OrderException>(() => processor.Process(invalidOrder));\n      \n      // Avoid: Multiple assertions without context\n      Assert.NotNull(result);\n      Assert.True(result.Success);\n      Assert.Equal(0, result.Errors.Count);\n      ```\n  - Handle async operations properly:\n      ```csharp\n      // Good: Async test method\n      [Fact]\n      public async Task ProcessOrder_ValidOrder_Succeeds()\n      {\n          await using var processor = new OrderProcessor();\n          var result = await processor.ProcessAsync(order);\n          Assert.True(result.IsSuccess);\n      }\n      \n      // Avoid: Sync over async\n      [Fact]\n      public void ProcessOrder_ValidOrder_Succeeds()\n      {\n          using var processor = new OrderProcessor();\n          var result = processor.ProcessAsync(order).Result;  // Can deadlock\n          Assert.True(result.IsSuccess);\n      }\n      ```\n\nAssertions:\n  - Use xUnit's built-in assertions:\n      ```csharp\n      // Good: Using xUnit's built-in assertions\n      public class OrderTests\n      {\n          [Fact]\n          public void CalculateTotal_WithValidLines_ReturnsCorrectSum()\n          {\n              // Arrange\n              var order = new Order(\n                  OrderId.New(),\n                  new[]\n                  {\n                      new OrderLine(\"SKU1\", 2, 10.0m),\n                      new OrderLine(\"SKU2\", 1, 20.0m)\n                  });\n              \n              // Act\n              var total = order.CalculateTotal();\n              \n              // Assert\n              Assert.Equal(40.0m, total);\n          }\n          \n          [Fact]\n          public void Order_WithInvalidLines_ThrowsException()\n          {\n              // Arrange\n              var invalidLines = new OrderLine[] { };\n              \n              // Act & Assert\n              var ex = Assert.Throws<ArgumentException>(() =>\n                  new Order(OrderId.New(), invalidLines));\n              Assert.Equal(\"Order must have at least one line\", ex.Message);\n          }\n          \n          [Fact]\n          public void Order_WithValidData_HasExpectedProperties()\n          {\n              // Arrange\n              var id = OrderId.New();\n              var lines = new[] { new OrderLine(\"SKU1\", 1, 10.0m) };\n              \n              // Act\n              var order = new Order(id, lines);\n              \n              // Assert\n              Assert.NotNull(order);\n              Assert.Equal(id, order.Id);\n              Assert.Single(order.Lines);\n              Assert.Collection(order.Lines,\n                  line =>\n                  {\n                      Assert.Equal(\"SKU1\", line.Sku);\n                      Assert.Equal(1, line.Quantity);\n                      Assert.Equal(10.0m, line.Price);\n                  });\n          }\n      }\n      ```\n      \n  - Avoid third-party assertion libraries:\n      ```csharp\n      // Avoid: Using FluentAssertions or similar libraries\n      public class OrderTests\n      {\n          [Fact]\n          public void CalculateTotal_WithValidLines_ReturnsCorrectSum()\n          {\n              var order = new Order(\n                  OrderId.New(),\n                  new[]\n                  {\n                      new OrderLine(\"SKU1\", 2, 10.0m),\n                      new OrderLine(\"SKU2\", 1, 20.0m)\n                  });\n              \n              // Avoid: Using FluentAssertions\n              order.CalculateTotal().Should().Be(40.0m);\n              order.Lines.Should().HaveCount(2);\n              order.Should().NotBeNull();\n          }\n      }\n      ```\n      \n  - Use proper assertion types:\n      ```csharp\n      public class CustomerTests\n      {\n          [Fact]\n          public void Customer_WithValidEmail_IsCreated()\n          {\n              // Boolean assertions\n              Assert.True(customer.IsActive);\n              Assert.False(customer.IsDeleted);\n              \n              // Equality assertions\n              Assert.Equal(\"john@example.com\", customer.Email);\n              Assert.NotEqual(Guid.Empty, customer.Id);\n              \n              // Collection assertions\n              Assert.Empty(customer.Orders);\n              Assert.Contains(\"Admin\", customer.Roles);\n              Assert.DoesNotContain(\"Guest\", customer.Roles);\n              Assert.All(customer.Orders, o => Assert.NotNull(o.Id));\n              \n              // Type assertions\n              Assert.IsType<PremiumCustomer>(customer);\n              Assert.IsAssignableFrom<ICustomer>(customer);\n              \n              // String assertions\n              Assert.StartsWith(\"CUST\", customer.Reference);\n              Assert.Contains(\"Premium\", customer.Description);\n              Assert.Matches(\"^CUST\\\\d{6}$\", customer.Reference);\n              \n              // Range assertions\n              Assert.InRange(customer.Age, 18, 100);\n              \n              // Reference assertions\n              Assert.Same(expectedCustomer, actualCustomer);\n              Assert.NotSame(differentCustomer, actualCustomer);\n          }\n      }\n      ```\n      \n  - Use Assert.Collection for complex collections:\n      ```csharp\n      [Fact]\n      public void ProcessOrder_CreatesExpectedEvents()\n      {\n          // Arrange\n          var processor = new OrderProcessor();\n          var order = CreateTestOrder();\n          \n          // Act\n          var events = processor.Process(order);\n          \n          // Assert\n          Assert.Collection(events,\n              evt =>\n              {\n                  Assert.IsType<OrderReceivedEvent>(evt);\n                  var received = Assert.IsType<OrderReceivedEvent>(evt);\n                  Assert.Equal(order.Id, received.OrderId);\n              },\n              evt =>\n              {\n                  Assert.IsType<InventoryReservedEvent>(evt);\n                  var reserved = Assert.IsType<InventoryReservedEvent>(evt);\n                  Assert.Equal(order.Id, reserved.OrderId);\n                  Assert.NotEmpty(reserved.ReservedItems);\n              },\n              evt =>\n              {\n                  Assert.IsType<OrderConfirmedEvent>(evt);\n                  var confirmed = Assert.IsType<OrderConfirmedEvent>(evt);\n                  Assert.Equal(order.Id, confirmed.OrderId);\n                  Assert.True(confirmed.IsSuccess);\n              });\n      }\n      ```\n\n# End of Cursor Rules File ",
    "sourceUrl": "https://github.com/Aaronontheweb/dotnet-cursor-rules/blob/master/csharp/testing.mdc",
    "version": "1.0.0",
    "metadata": {
      "originalPath": "csharp/testing.mdc",
      "sha": "2d41c079e4159e1fe2a8c3ae5d181c77a98fb994"
    }
  },
  {
    "name": "aaronontheweb-dotnet-sdk-dependency-management",
    "slug": "dotnet-sdk-dependency-management",
    "displayName": "dotnet-sdk dependency management",
    "description": "dotnet-sdk dependency management for .NET development",
    "author": "Aaronontheweb",
    "type": "cursor",
    "category": "languages",
    "tags": [
      "cursor",
      "cursor-rule",
      "dotnet",
      "csharp"
    ],
    "content": "---\ndescription: This file provides guidelines for safely managing NuGet package dependencies in .NET projects, focusing on security, licensing, and maintainability.\nglobs: Directory.Packages.props,*.csproj,*.fsproj,Directory.Build.props,nuget.config\nalwaysApply: false\n---\n\n# Cursor Rules File: Best Practices for .NET Dependency Management\nRole Definition:\n - Package Management Expert\n - Security Analyst\n - License Compliance Specialist\n\nGeneral:\n  Description: >\n    .NET projects must manage their dependencies using secure and consistent practices,\n    with attention to security vulnerabilities, license compliance, and proper version\n    management through the dotnet CLI.\n  Requirements:\n    - Use dotnet CLI for package management\n    - Verify package licenses before installation\n    - Monitor for security vulnerabilities\n    - Maintain consistent versioning strategies\n\nPackage Installation:\n  - Always use dotnet CLI commands:\n      - Preferred: `dotnet add package <PackageId> [-v <Version>]`\n      - Avoid manual .csproj/.fsproj edits\n      - Examples:\n        ```bash\n        # Add latest stable version\n        dotnet add package Newtonsoft.Json\n        \n        # Add specific version\n        dotnet add package Serilog -v 3.1.1\n        \n        # Add package to specific project\n        dotnet add MyProject/MyProject.csproj package Microsoft.Extensions.Logging\n        ```\n  - Before installation:\n      - Check package license compatibility\n      - Review package download statistics\n      - Verify package authenticity (signed packages)\n      - Consider package maintenance status\n\nCheck and Upgrade NuGet Packages:\n\n  To check for outdated packages and upgrade them in your .NET solution:\n\n  1. **Check for outdated packages**\n     ```bash\n     dotnet list package --outdated\n     ```\n     This command will show:\n     - Currently used version (\"Resolved\")\n     - Latest available version (\"Latest\")\n     - The version you're requesting (\"Requested\")\n\n  2. **Update package versions**\n     - If using central package management (Directory.Packages.props):\n       - Update the versions in `Directory.Packages.props`:\n       ```xml\n       <PackageVersion Include=\"PackageName\" Version=\"NewVersion\" />\n       ```\n\n     - If using traditional package references:\n       ```bash\n       dotnet add package PackageName --version NewVersion\n       ```\n\n  3. **Restore and verify**\n     ```bash\n     dotnet restore\n     dotnet build\n     dotnet test\n     ```\n\n  Example output of `dotnet list package --outdated`:\n  ```\n  Project `MyProject` has the following updates to its packages\n     [netstandard2.1]:\n     Top-level Package      Requested   Resolved   Latest\n     > Akka.Streams         1.5.13      1.4.45     1.5.38\n  ```\n\n  Note: After updating packages, always:\n  1. Check for breaking changes in the package's release notes\n  2. Build the solution to catch any compatibility issues\n  3. Run tests to ensure everything still works\n  4. Review and update any code that needs to be modified for the new versions\n\nSecurity Considerations:\n  - Enable security scanning:\n      - Run `dotnet restore --use-lock-file` to generate lock file\n      - Use `dotnet list package --vulnerable` to check for known vulnerabilities\n      - Configure GitHub Dependabot or similar tools\n  - Monitor security:\n      - Subscribe to security advisories\n      - Regular vulnerability scanning in CI/CD\n      - Automated security updates for patch versions\n  - Example workflow:\n    ```bash\n    # Generate lock file\n    dotnet restore --use-lock-file\n    \n    # Check for vulnerabilities\n    dotnet list package --vulnerable\n    \n    # Update vulnerable package\n    dotnet add package VulnerablePackage -v SecureVersion\n    \n    # Regenerate lock file\n    dotnet restore --force-evaluate\n    ```\n\nLicense Compliance:\n  - Verify licenses before adding dependencies:\n      - Check license compatibility with your project\n      - Document license requirements\n      - Maintain license inventory\n  - Common OSS-friendly licenses:\n      - MIT\n      - Apache 2.0\n      - BSD\n      - MS-PL\n  - Warning signs:\n      - No license specified\n      - Restrictive licenses (GPL for commercial software)\n      - License changes between versions\n\nVersion Management:\n  - Use semantic versioning:\n      - Lock major versions for stability\n      - Allow minor updates for features\n      - Auto-update patches for security\n  - Version constraints:\n      - Avoid floating versions (*)\n      - Use minimum version constraints when needed\n      - Document version decisions\n  - Example in Directory.Packages.props:\n    ```xml\n    <Project>\n      <ItemGroup>\n        <!-- Locked major version -->\n        <PackageVersion Include=\"Important.Package\" Version=\"2.0.0\" />\n        \n        <!-- Allow minor updates -->\n        <PackageVersion Include=\"Feature.Package\" Version=\"[3.0,4.0)\" />\n        \n        <!-- Allow patch updates -->\n        <PackageVersion Include=\"Stable.Package\" Version=\"[1.2.3,1.3.0)\" />\n      </ItemGroup>\n    </Project>\n    ```\n\nMaintenance:\n  - Regular housekeeping:\n      - Remove unused packages\n      - Consolidate duplicate dependencies\n      - Update documentation\n  - Automation:\n      - Implement automated vulnerability scanning\n      - Set up dependency update workflows\n      - Configure license compliance checks\n  - Commands for maintenance:\n    ```bash\n    # List all packages\n    dotnet list package\n    \n    # Check for unused dependencies\n    dotnet remove package UnusedPackage\n    \n    # Clean solution\n    dotnet clean\n    dotnet restore --force\n    ```\n\nIntegration with CI/CD:\n  - Implement checks:\n      - Vulnerability scanning\n      - License compliance\n      - Package restore verification\n  - Example GitHub Actions workflow:\n    ```yaml\n    - name: Security scan\n      run: |\n        dotnet restore --use-lock-file\n        dotnet list package --vulnerable\n        \n    - name: License check\n      run: dotnet-project-licenses\n    ```\n\n# End of Cursor Rules File ",
    "sourceUrl": "https://github.com/Aaronontheweb/dotnet-cursor-rules/blob/master/dotnet-sdk/dependency-management.mdc",
    "version": "1.0.0",
    "metadata": {
      "originalPath": "dotnet-sdk/dependency-management.mdc",
      "sha": "7aaede645daca70504d0ebb59934a308160c719c"
    }
  },
  {
    "name": "aaronontheweb-dotnet-sdk-solution-management",
    "slug": "dotnet-sdk-solution-management",
    "displayName": "dotnet-sdk solution management",
    "description": "dotnet-sdk solution management for .NET development",
    "author": "Aaronontheweb",
    "type": "cursor",
    "category": "languages",
    "tags": [
      "cursor",
      "cursor-rule",
      "dotnet",
      "csharp"
    ],
    "content": "---\ndescription: This file provides guidelines for maintaining .NET solutions with consistent SDK versions, shared metadata, and centralized package management.\nglobs: *.sln, global.json, Directory.Build.props, Directory.Package.props, *.csproj, *.fsproj\nalwaysApply: false\n---\n\n# Cursor Rules File: Best Practices for .NET Solution Management\n\nRole Definition:\n - .NET Solution Architect\n - Build System Expert\n - Package Management Specialist\n\nGeneral:\n  Description: >\n    .NET solutions must be configured with explicit SDK versioning, shared build properties,\n    and centralized package management to ensure consistency, maintainability, and security\n    across all projects within the solution.\n  Requirements:\n    - Maintain a global.json for SDK version control\n    - Use Directory.Build.props for shared metadata\n    - Implement centralized package management\n    - Configure secure and reliable package sources\n\nSDK Version Management:\n  - Maintain a global.json file in the solution root:\n      - Specify exact SDK version to ensure consistent builds\n      - Include rollForward policy for patch version flexibility\n      - Example:\n        ```json\n        {\n          \"sdk\": {\n            \"version\": \"8.0.100\",\n            \"rollForward\": \"patch\"\n          }\n        }\n        ```\n  - Update SDK versions through controlled processes:\n      - Test new SDK versions in development/CI before updating\n      - Document SDK version changes in source control\n      - Consider implications for CI/CD pipelines\n\nShared Build Properties:\n  - Implement Directory.Build.props in solution root:\n      - Define common metadata:\n          - Company/Author information\n          - Copyright details\n          - Project URL\n          - License information\n          - Version prefix/suffix strategy\n      - Example structure:\n        ```xml\n        <Project>\n          <PropertyGroup>\n            <Authors>Your Company</Authors>\n            <Company>Your Company</Company>\n            <Copyright>© $([System.DateTime]::Now.Year) Your Company</Copyright>\n            <PackageLicenseExpression>MIT</PackageLicenseExpression>\n            <PackageProjectUrl>https://github.com/your/project</PackageProjectUrl>\n            <VersionPrefix>1.0.0</VersionPrefix>\n          </PropertyGroup>\n        </Project>\n        ```\n  - Consider environment-specific overrides:\n      - Use Directory.Build.targets for overrides\n      - Support CI/CD pipeline customization\n\nPackage Management:\n  - Enable centralized package management:\n      - Create Directory.Packages.props:\n          - Define package versions once\n          - Enforce consistent versions across projects\n          - Example:\n            ```xml\n            <Project>\n              <PropertyGroup>\n                <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>\n              </PropertyGroup>\n              <ItemGroup>\n                <PackageVersion Include=\"Newtonsoft.Json\" Version=\"13.0.3\" />\n              </ItemGroup>\n            </Project>\n            ```\n  - Configure nuget.config:\n      - Enable package source mapping\n      - Define trusted package sources\n      - Example:\n        ```xml\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <configuration>\n          <packageSourceMapping>\n            <packageSource key=\"nuget.org\">\n              <package pattern=\"*\" />\n            </packageSource>\n          </packageSourceMapping>\n          <packageSources>\n            <clear />\n            <add key=\"nuget.org\" value=\"https://api.nuget.org/v3/index.json\" />\n          </packageSources>\n        </configuration>\n        ```\n\nMaintenance:\n  - Regular auditing:\n      - Review SDK versions for security updates\n      - Validate package versions for vulnerabilities\n      - Update shared metadata as needed\n  - Version control:\n      - Commit all configuration files\n      - Document changes in commit messages\n      - Consider using git hooks for validation\n\nCompilation:\n  - Use dotnet CLI for builds:\n      - Prefer `dotnet build` over IDE builds for consistency\n      - Use `dotnet build -c Release` for release builds\n      - Enable deterministic builds with `/p:ContinuousIntegrationBuild=true`\n  - Enforce code quality:\n      - Enable `TreatWarningsAsErrors` in Directory.Build.props:\n        ```xml\n        <PropertyGroup>\n          <TreatWarningsAsErrors>true</TreatWarningsAsErrors>\n          <!-- Optionally allow specific warnings -->\n          <WarningsNotAsErrors>CS1591</WarningsNotAsErrors>\n        </PropertyGroup>\n        ```\n      - Address warnings properly:\n          - Fix the underlying issue rather than suppressing\n          - Document any necessary warning suppressions\n          - Use `#pragma warning disable` sparingly and only with comments\n  - Build configuration:\n      - Use conditional compilation symbols purposefully\n      - Define debug/release-specific behavior clearly\n      - Example:\n        ```xml\n        <PropertyGroup>\n          <DefineConstants>TRACE</DefineConstants>\n          <DefineConstants Condition=\"'$(Configuration)'=='Debug'\">$(DefineConstants);DEBUG</DefineConstants>\n        </PropertyGroup>\n        ```\n  - Performance:\n      - Enable incremental builds by default\n      - Use `dotnet build --no-incremental` only when needed\n      - Consider using Fast Up-to-Date Check:\n        ```xml\n        <PropertyGroup>\n          <DisableFastUpToDateCheck>false</DisableFastUpToDateCheck>\n        </PropertyGroup>\n        ```\n  - Build output:\n      - Set consistent output paths\n      - Configure deterministic output:\n        ```xml\n        <PropertyGroup>\n          <Deterministic>true</Deterministic>\n          <ContinuousIntegrationBuild Condition=\"'$(GITHUB_ACTIONS)' == 'true'\">true</ContinuousIntegrationBuild>\n        </PropertyGroup>\n        ```\n  - Error handling:\n      - Log build errors comprehensively\n      - Use MSBuild binary log for detailed diagnostics:\n        ```bash\n        dotnet build -bl:build.binlog\n        ```\n      - Configure error reporting in CI/CD:\n        ```yaml\n        - name: Build\n          run: dotnet build --configuration Release /p:ContinuousIntegrationBuild=true\n          env:\n            DOTNET_CLI_TELEMETRY_OPTOUT: 1\n            DOTNET_NOLOGO: 1\n        ```\n\n# End of Cursor Rules File ",
    "sourceUrl": "https://github.com/Aaronontheweb/dotnet-cursor-rules/blob/master/dotnet-sdk/solution-management.mdc",
    "version": "1.0.0",
    "metadata": {
      "originalPath": "dotnet-sdk/solution-management.mdc",
      "sha": "3f00b7748b22f283650097f0ca833e877a83a513"
    }
  },
  {
    "name": "aaronontheweb-dotnet-tools-consuming-dotnettool",
    "slug": "dotnet-tools-consuming-dotnettool",
    "displayName": "dotnet-tools consuming dotnettool",
    "description": "dotnet-tools consuming dotnettool for .NET development",
    "author": "Aaronontheweb",
    "type": "cursor",
    "category": "languages",
    "tags": [
      "cursor",
      "cursor-rule",
      "dotnet",
      "csharp"
    ],
    "content": "---\ndescription: This tool is used for helping manage and organize the installation of `dotnet tool` instances that are used for .NET projects.\nglobs: \nalwaysApply: false\n---\n\n# Cursor Rules File: Best Practices for Consuming dotnet Tool Instances\n# This file provides guidelines for projects that depend on dotnet tools. It ensures that:\n# - A tool manifest is maintained for local and CI/CD consistency.\n# - Tool versions are explicitly defined.\n# - Proper installation, updating, and documentation practices are followed.\n\nGeneral:\n  Description: >\n    Projects consuming dotnet tool instances must manage their tool dependencies through a tool manifest.\n    This approach promotes reproducible builds and clear dependency management, ensuring that the correct\n    tool versions are used consistently across different environments.\n  Requirements:\n    - Maintain a tool manifest file (typically located at `.config/dotnet-tools.json`) in the project root.\n    - Use explicit versioning for all dotnet tools to prevent unexpected updates.\n    - Integrate tool management into the CI/CD pipeline for automated restoration.\n\nPreparation:\n  - If a tool manifest does not exist, create one by running:\n      - `dotnet new tool-manifest`\n  - Update the tool manifest with the necessary tools by executing:\n      - `dotnet tool install <tool-package> --version <version>`\n  - Ensure the manifest file (`.config/dotnet-tools.json`) is checked into version control for consistency.\n\nTool Management:\n  - Installation:\n      - Use `dotnet tool install` with an explicit version to add a tool to the manifest.\n      - Verify that the installed tool versions match the ones specified in the manifest.\n      - For tools that support both global and local installation, prefer local installation via manifest.\n  - Updating:\n      - To update a tool, use `dotnet tool update <tool-package> --version <version>`.\n      - After updating, validate that the manifest reflects the new version.\n  - Restoration:\n      - Ensure that `dotnet tool restore` is executed as part of local setup and CI/CD processes to install all tools defined in the manifest.\n  - Verification:\n      - Periodically review the manifest to confirm that all tool versions are current and that deprecated or unused tools are removed.\n\nIntegration & CI/CD:\n  - Include the following steps in your CI/CD pipeline:\n      - **Restore Tools:** Run `dotnet tool restore` prior to build or test phases.\n      - **Version Check:** Validate that the manifest has not drifted from the expected tool versions.\n      - **Cache Tools:** Consider caching the restored tools between pipeline runs to improve build times.\n  - Document the usage of these tools in your project README or contributing guidelines for clarity.\n\nDocumentation & Maintenance:\n  - Document in your project README:\n      - The purpose of each dotnet tool listed in the manifest.\n      - Instructions for installing, updating, or troubleshooting the tools.\n  - Regularly audit the manifest to:\n      - Remove outdated or unused tools.\n      - Update tools when new versions become available and are verified for compatibility.\n  - Maintain clear commit messages when changes are made to the tool manifest.\n\nSecurity & Compliance:\n  - Ensure that all tools come from trusted sources and have proper licensing.\n  - Avoid using wildcard or range versioning to mitigate the risk of unintentional upgrades.\n  - Document any security advisories or considerations related to the consumed tools.\n\nAutomation:\n  - Automate tool restoration by incorporating `dotnet tool restore` into your build scripts.\n  - Consider using scripts or CI/CD tasks to:\n      - Check for available updates to the tools.\n      - Validate the integrity and security compliance of the manifest file.\n      - Monitor for security advisories related to installed tools.\n      - Automatically create PRs for tool updates after successful testing.\n      \n# End of Cursor Rules File",
    "sourceUrl": "https://github.com/Aaronontheweb/dotnet-cursor-rules/blob/master/dotnet-tools/consuming-dotnettool.mdc",
    "version": "1.0.0",
    "metadata": {
      "originalPath": "dotnet-tools/consuming-dotnettool.mdc",
      "sha": "b07e3138ca01b24bf0678b97cbe2efebc28c2038"
    }
  },
  {
    "name": "aaronontheweb-dotnet-tools-publishing-dotnettool",
    "slug": "dotnet-tools-publishing-dotnettool",
    "displayName": "dotnet-tools publishing dotnettool",
    "description": "dotnet-tools publishing dotnettool for .NET development",
    "author": "Aaronontheweb",
    "type": "cursor",
    "category": "languages",
    "tags": [
      "cursor",
      "cursor-rule",
      "dotnet",
      "csharp"
    ],
    "content": "---\ndescription: This file serves as a guideline for the Cursor AI Agent to ensure the proper creation, packaging, and publishing of a `dotnet tool`. Follow these rules to maintain consistency, quality, and security across published tools.\nglobs: \nalwaysApply: false\n---\n\n# Cursor Rules File: Best Practices for Publishing a dotnet Tool\n# This file serves as a guideline for the Cursor AI Agent to ensure the proper\n# creation, packaging, and publishing of a dotnet tool. Follow these rules to\n# maintain consistency, quality, and security across published tools.\n\n\nRole Definition:\n - .NET Expert\n - OSS author\n - Aware that users running on multiple versions of .NET in different environments might need access to this tool\n\nGeneral:\n  Description: >\n    The dotnet tool must be packaged as a NuGet package that adheres to\n    semantic versioning, proper dependency management, and includes comprehensive\n    documentation. This file outlines the steps and checks that need to be performed.\n  Requirements:\n    - Use a project file (.csproj) with the property <PackAsTool>true</PackAsTool>\n    - Follow semantic versioning (MAJOR.MINOR.PATCH)\n    - Ensure the tool is documented with a README and inline help support\n\nPreparation:\n  - Validate that the project file includes:\n      - <PackAsTool>true</PackAsTool>\n      - Proper versioning and package metadata (e.g., PackageId, Authors, Description, License)\n  - Include a detailed README file with:\n      - Installation instructions (e.g., `dotnet tool install -g <package-id>`)\n      - Usage examples and command options\n      - Troubleshooting and FAQ sections\n  - Confirm that all dependencies are explicitly declared\n  - Always target the most recent long-term release of .NET (currently .NET 8) unless the project is explicitly set to multi-target or targets and older version of the runtime\n  - Always include a `<RollForward>LatestMajor</RollForward>` so the tool can automatically be used with newer runtimes without a new version needing to be released\n\nPackaging:\n  - Use the `dotnet pack` command to generate the NuGet package:\n      - Ensure that all necessary files (binaries, assets, configuration files) are included\n      - Verify that the output .nupkg file contains the expected metadata and assets\n  - Run tests to verify that the tool functions correctly in a local install scenario\n\n# End of Cursor Rules File",
    "sourceUrl": "https://github.com/Aaronontheweb/dotnet-cursor-rules/blob/master/dotnet-tools/publishing-dotnettool.mdc",
    "version": "1.0.0",
    "metadata": {
      "originalPath": "dotnet-tools/publishing-dotnettool.mdc",
      "sha": "d5d6deb6d04fcb0e2b48826e68fde264bef69123"
    }
  },
  {
    "name": "aaronontheweb-nuget-packages-nuget-package-publishing",
    "slug": "nuget-packages-nuget-package-publishing",
    "displayName": "nuget-packages nuget package publishing",
    "description": "nuget-packages nuget package publishing for .NET development",
    "author": "Aaronontheweb",
    "type": "cursor",
    "category": "languages",
    "tags": [
      "cursor",
      "cursor-rule",
      "dotnet",
      "csharp"
    ],
    "content": "---\ndescription: This document provides comprehensive guidance for publishing high-quality NuGet packages that follow industry best practices.\nglobs: *.props, *.csproj, *.fsproj\nalwaysApply: false\n---\n\n# NuGet Package Publishing Best Practices\n\nThis document provides comprehensive guidance for publishing high-quality NuGet packages that follow industry best practices.\n\n## Table of Contents\n\n- [License Configuration](mdc:#license-configuration)\n- [Package Documentation](mdc:#package-documentation)\n- [Metadata Organization](mdc:#metadata-organization)\n- [Source Debugging Support](mdc:#source-debugging-support)\n- [Package Dependencies](mdc:#package-dependencies)\n- [Versioning](mdc:#versioning)\n- [Build and Pack Commands](mdc:#build-and-pack-commands)\n- [Quality Checks](mdc:#quality-checks)\n\n## License Configuration\n\n### Use License Expressions\n\nAlways use SPDX license expressions instead of deprecated license URLs or embedding license files in your package.\n\n#### ✅ DO: Use license expression\n\n```xml\n<PropertyGroup>\n  <PackageLicenseExpression>MIT</PackageLicenseExpression>\n</PropertyGroup>\n```\n\n#### ❌ DON'T: Use deprecated licenseUrl\n\n```xml\n<PropertyGroup>\n  <PackageLicenseUrl>https://licenses.nuget.org/MIT</PackageLicenseUrl>\n</PropertyGroup>\n```\n\n### Common License Expression Examples\n\n#### MIT License\n\n```xml\n<PropertyGroup>\n  <PackageLicenseExpression>MIT</PackageLicenseExpression>\n</PropertyGroup>\n```\n\n#### Apache 2.0 License\n\n```xml\n<PropertyGroup>\n  <PackageLicenseExpression>Apache-2.0</PackageLicenseExpression>\n</PropertyGroup>\n```\n\n#### BSD 3-Clause License\n\n```xml\n<PropertyGroup>\n  <PackageLicenseExpression>BSD-3-Clause</PackageLicenseExpression>\n</PropertyGroup>\n```\n\n#### GPL v3 License\n\n```xml\n<PropertyGroup>\n  <PackageLicenseExpression>GPL-3.0-only</PackageLicenseExpression>\n</PropertyGroup>\n```\n\n#### Multiple Licenses (OR)\n\n```xml\n<PropertyGroup>\n  <PackageLicenseExpression>MIT OR Apache-2.0</PackageLicenseExpression>\n</PropertyGroup>\n```\n\n## Package Documentation\n\n### Include README.md\n\nAlways include a README.md file in your package to provide clear documentation for users.\n\n#### ✅ DO: Include README with proper configuration\n\n```xml\n<PropertyGroup>\n  <PackageReadmeFile>README.md</PackageReadmeFile>\n</PropertyGroup>\n<ItemGroup>\n  <None Include=\"README.md\" Pack=\"true\" PackagePath=\"/\" />\n</ItemGroup>\n```\n\n#### ✅ DO: Include README from a different location\n\n```xml\n<PropertyGroup>\n  <PackageReadmeFile>README.md</PackageReadmeFile>\n</PropertyGroup>\n<ItemGroup>\n  <None Include=\"docs/README.md\" Pack=\"true\" PackagePath=\"/\" />\n</ItemGroup>\n```\n\n#### ❌ DON'T: Forget to include the README in the package\n\n```xml\n<PropertyGroup>\n  <PackageReadmeFile>README.md</PackageReadmeFile>\n  <!-- Missing the ItemGroup that includes the file -->\n</PropertyGroup>\n```\n\n### README Content Best Practices\n\nA good README.md should include:\n\n1. Package name and description\n2. Installation instructions\n3. Basic usage examples\n4. API documentation or link to it\n5. License information\n6. Contributing guidelines\n\n#### Example README.md Structure\n\n```markdown\n# MyAwesomePackage\n\nA lightweight, high-performance library for doing awesome things.\n\n## Installation\n\n```shell\ndotnet add package MyAwesomePackage\n```\n\n## Quick Start\n\n```csharp\nusing MyAwesomeNamespace;\n\nvar awesome = new AwesomeClass();\nvar result = awesome.DoSomethingAwesome();\n```\n\n## Features\n\n- Feature 1: Description\n- Feature 2: Description\n- Feature 3: Description\n\n## Documentation\n\nFor full documentation, visit [our docs site](mdc:https:/docs.myawesomepackage.com).\n\n## License\n\nMIT License\n```\n\n### Image Domain Restrictions\n\nWhen including images in your README.md, ensure they come from trusted domains. NuGet.org only renders images from approved domains.\n\n#### Approved Image Domains\n\n- api.codacy.com\n- app.codacy.com\n- api.codeclimate.com\n- api.dependabot.com\n- api.travis-ci.com\n- api.reuse.software\n- app.fossa.com\n- app.fossa.io\n- avatars.githubusercontent.com\n- badge.fury.io\n- badgen.net\n- badges.gitter.im\n- buildstats.info\n- caniuse.bitsofco.de\n- camo.githubusercontent.com\n- cdn.jsdelivr.net\n- cdn.syncfusion.com\n- ci.appveyor.com\n- circleci.com\n- codecov.io\n- codefactor.io\n- coveralls.io\n- dev.azure.com\n- flat.badgen.net\n- github.com/.../workflows/.../badge.svg\n- gitlab.com\n- img.shields.io\n- i.imgur.com\n- isitmaintained.com\n- opencollective.com\n- raw.github.com\n- raw.githubusercontent.com\n- snyk.io\n- sonarcloud.io\n- travis-ci.com\n- travis-ci.org\n- wakatime.com\n- user-images.githubusercontent.com\n\n#### ✅ DO: Use approved domains for images\n\n```markdown\n![Build Status](mdc:https:/img.shields.io/github/workflow/status/myorg/myrepo/CI)\n![Coverage](mdc:https:/codecov.io/gh/myorg/myrepo/branch/main/graph/badge.svg)\n```\n\n#### ❌ DON'T: Use unapproved domains for images\n\n```markdown\n![Logo](mdc:https:/my-unapproved-domain.com/logo.png)\n```\n\n## Metadata Organization\n\n### Directory.Build.props for Common Metadata\n\nUse `Directory.Build.props` for common metadata shared across multiple packages in a solution.\n\n#### ✅ DO: Place common metadata in Directory.Build.props\n\n```xml\n<Project>\n  <PropertyGroup>\n    <!-- Company/Organization Information -->\n    <Authors>Contoso, Inc.</Authors>\n    <Company>Contoso, Inc.</Company>\n    <Copyright>© $([System.DateTime]::Now.Year) Contoso, Inc. All rights reserved.</Copyright>\n    \n    <!-- Repository Information -->\n    <PackageProjectUrl>https://github.com/contoso/awesome-library</PackageProjectUrl>\n    <RepositoryUrl>https://github.com/contoso/awesome-library.git</RepositoryUrl>\n    <RepositoryType>git</RepositoryType>\n    \n    <!-- Release Information -->\n    <PackageReleaseNotes>https://github.com/contoso/awesome-library/releases</PackageReleaseNotes>\n    \n    <!-- Common Package Configuration -->\n    <PackageLicenseExpression>MIT</PackageLicenseExpression>\n    <PackageRequireLicenseAcceptance>false</PackageRequireLicenseAcceptance>\n    <PackageReadmeFile>README.md</PackageReadmeFile>\n    <PackageIcon>icon.png</PackageIcon>\n    \n    <!-- Build Configuration -->\n    <LangVersion>latest</LangVersion>\n    <Nullable>enable</Nullable>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>\n  </PropertyGroup>\n  \n  <ItemGroup>\n    <None Include=\"$(MSBuildThisFileDirectory)\\icon.png\" Pack=\"true\" PackagePath=\"\\\" Visible=\"false\" />\n  </ItemGroup>\n</Project>\n```\n\n### Project-Specific Metadata\n\nKeep package-specific metadata in the project file (`.csproj`, `.fsproj`).\n\n#### ✅ DO: Place package-specific metadata in project file\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup>\n    <TargetFrameworks>net6.0;net7.0;net8.0</TargetFrameworks>\n    \n    <!-- Package-specific metadata -->\n    <PackageId>Contoso.AwesomeLibrary.Core</PackageId>\n    <Version>1.2.3</Version>\n    <Description>A core library for doing awesome things efficiently and reliably.</Description>\n    <PackageTags>awesome;library;performance;utilities</PackageTags>\n    \n    <!-- Package-specific configuration -->\n    <GenerateDocumentationFile>true</GenerateDocumentationFile>\n  </PropertyGroup>\n  \n  <ItemGroup>\n    <None Include=\"README.md\" Pack=\"true\" PackagePath=\"\\\" />\n  </ItemGroup>\n</Project>\n```\n\n#### ❌ DON'T: Duplicate common metadata in project files\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup>\n    <TargetFrameworks>net6.0;net7.0;net8.0</TargetFrameworks>\n    \n    <!-- DON'T duplicate these in every project file -->\n    <Authors>Contoso, Inc.</Authors>\n    <Company>Contoso, Inc.</Company>\n    <Copyright>© 2023 Contoso, Inc. All rights reserved.</Copyright>\n    <PackageLicenseExpression>MIT</PackageLicenseExpression>\n    <PackageProjectUrl>https://github.com/contoso/awesome-library</PackageProjectUrl>\n    \n    <!-- Package-specific metadata -->\n    <PackageId>Contoso.AwesomeLibrary.Core</PackageId>\n    <Version>1.2.3</Version>\n    <Description>A core library for doing awesome things efficiently and reliably.</Description>\n    <PackageTags>awesome;library;performance;utilities</PackageTags>\n  </PropertyGroup>\n</Project>\n```\n\n## Source Debugging Support\n\n### Enable SourceLink\n\nSourceLink enables step-through debugging of your package's source code directly from NuGet packages.\n\n#### ✅ DO: Configure SourceLink for GitHub\n\n```xml\n<PropertyGroup>\n  <PublishRepositoryUrl>true</PublishRepositoryUrl>\n  <EmbedUntrackedSources>true</EmbedUntrackedSources>\n  <IncludeSymbols>true</IncludeSymbols>\n  <SymbolPackageFormat>snupkg</SymbolPackageFormat>\n  <!-- Recommended for deterministic builds in CI -->\n  <ContinuousIntegrationBuild Condition=\"'$(CI)' == 'true'\">true</ContinuousIntegrationBuild>\n</PropertyGroup>\n\n<ItemGroup>\n  <PackageReference Include=\"Microsoft.SourceLink.GitHub\" Version=\"1.1.1\" PrivateAssets=\"All\"/>\n</ItemGroup>\n```\n\n#### ✅ DO: Configure SourceLink for Azure DevOps\n\n```xml\n<PropertyGroup>\n  <PublishRepositoryUrl>true</PublishRepositoryUrl>\n  <EmbedUntrackedSources>true</EmbedUntrackedSources>\n  <IncludeSymbols>true</IncludeSymbols>\n  <SymbolPackageFormat>snupkg</SymbolPackageFormat>\n</PropertyGroup>\n\n<ItemGroup>\n  <PackageReference Include=\"Microsoft.SourceLink.AzureRepos.Git\" Version=\"1.1.1\" PrivateAssets=\"All\"/>\n</ItemGroup>\n```\n\n#### ✅ DO: Configure SourceLink for GitLab\n\n```xml\n<PropertyGroup>\n  <PublishRepositoryUrl>true</PublishRepositoryUrl>\n  <EmbedUntrackedSources>true</EmbedUntrackedSources>\n  <IncludeSymbols>true</IncludeSymbols>\n  <SymbolPackageFormat>snupkg</SymbolPackageFormat>\n</PropertyGroup>\n\n<ItemGroup>\n  <PackageReference Include=\"Microsoft.SourceLink.GitLab\" Version=\"1.1.1\" PrivateAssets=\"All\"/>\n</ItemGroup>\n```\n\n#### ❌ DON'T: Publish packages without symbol support\n\n```xml\n<PropertyGroup>\n  <!-- Missing SourceLink and symbol configuration -->\n  <Version>1.0.0</Version>\n</PropertyGroup>\n```\n\n### Symbol Packages\n\nAlways include symbol packages (`.snupkg`) when publishing to NuGet.org.\n\n#### ✅ DO: Configure symbol package generation\n\n```xml\n<PropertyGroup>\n  <IncludeSymbols>true</IncludeSymbols>\n  <SymbolPackageFormat>snupkg</SymbolPackageFormat>\n</PropertyGroup>\n```\n\n#### ✅ DO: Publish both package and symbols\n\n```shell\ndotnet pack -c Release\ndotnet nuget push bin/Release/MyPackage.1.0.0.nupkg -s https://api.nuget.org/v3/index.json -k YOUR_API_KEY\ndotnet nuget push bin/Release/MyPackage.1.0.0.snupkg -s https://api.nuget.org/v3/index.json -k YOUR_API_KEY\n```\n\n## Package Dependencies\n\n### Minimize Dependencies\n\nKeep dependencies to a minimum to reduce potential conflicts and improve load times.\n\n#### ✅ DO: Keep dependencies minimal\n\n```xml\n<ItemGroup>\n  <!-- Only include what you absolutely need -->\n  <PackageReference Include=\"Newtonsoft.Json\" Version=\"13.0.1\" />\n</ItemGroup>\n```\n\n#### ❌ DON'T: Include unnecessary dependencies\n\n```xml\n<ItemGroup>\n  <!-- Don't include packages you don't directly use -->\n  <PackageReference Include=\"Newtonsoft.Json\" Version=\"13.0.1\" />\n  <PackageReference Include=\"System.Data.SqlClient\" Version=\"4.8.3\" />\n  <PackageReference Include=\"Microsoft.Extensions.Logging\" Version=\"6.0.0\" />\n</ItemGroup>\n```\n\n### Use Appropriate Version Ranges\n\nSpecify version ranges that balance flexibility with stability.\n\n#### ✅ DO: Use specific version ranges\n\n```xml\n<ItemGroup>\n  <!-- Exact version -->\n  <PackageReference Include=\"ExactPackage\" Version=\"1.2.3\" />\n  \n  <!-- Minimum version (1.0.0 or higher) -->\n  <PackageReference Include=\"MinimumPackage\" Version=\"1.0.0\" />\n  \n  <!-- Range with minimum and maximum (>= 2.0.0 and < 3.0.0) -->\n  <PackageReference Include=\"RangePackage\" Version=\"[2.0.0,3.0.0)\" />\n  \n  <!-- Specific major and minor, any patch (>= 1.2.0 and < 1.3.0) -->\n  <PackageReference Include=\"MinorRangePackage\" Version=\"[1.2.*,)\" />\n</ItemGroup>\n```\n\n#### ❌ DON'T: Use overly broad version ranges\n\n```xml\n<ItemGroup>\n  <!-- Too broad, accepts any version -->\n  <PackageReference Include=\"AnyVersionPackage\" Version=\"*\" />\n  \n  <!-- Too broad, accepts any version from 1.0.0 onwards -->\n  <PackageReference Include=\"TooFlexiblePackage\" Version=\"1.*\" />\n</ItemGroup>\n```\n\n### Split Functionality into Separate Packages\n\nFor complex libraries, consider splitting functionality into separate packages.\n\n#### ✅ DO: Split functionality logically\n\nExample package structure:\n- `MyCompany.MyLibrary.Core` - Core functionality\n- `MyCompany.MyLibrary.Data` - Data access components\n- `MyCompany.MyLibrary.AspNetCore` - ASP.NET Core integration\n- `MyCompany.MyLibrary.All` - Metapackage that references all the above\n\n#### ✅ DO: Create metapackages for convenience\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup>\n    <TargetFramework>netstandard2.0</TargetFramework>\n    <PackageId>MyCompany.MyLibrary.All</PackageId>\n    <Description>Metapackage that includes all MyLibrary components</Description>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"MyCompany.MyLibrary.Core\" Version=\"1.0.0\" />\n    <PackageReference Include=\"MyCompany.MyLibrary.Data\" Version=\"1.0.0\" />\n    <PackageReference Include=\"MyCompany.MyLibrary.AspNetCore\" Version=\"1.0.0\" />\n  </ItemGroup>\n</Project>\n```\n\n## Versioning\n\n### Follow Semantic Versioning (SemVer)\n\nUse SemVer to communicate the impact of changes to your package.\n\n#### Version Components\n\n- **Major (X.y.z)**: Breaking changes\n- **Minor (x.Y.z)**: New features, non-breaking\n- **Patch (x.y.Z)**: Bug fixes only\n\n#### ✅ DO: Increment version numbers appropriately\n\n```xml\n<PropertyGroup>\n  <!-- Initial version -->\n  <Version>1.0.0</Version>\n  \n  <!-- After adding new features -->\n  <Version>1.1.0</Version>\n  \n  <!-- After fixing bugs -->\n  <Version>1.1.1</Version>\n  \n  <!-- After making breaking changes -->\n  <Version>2.0.0</Version>\n</PropertyGroup>\n```\n\n#### ✅ DO: Use version suffixes for pre-release versions\n\n```xml\n<PropertyGroup>\n  <!-- Alpha release -->\n  <Version>1.0.0-alpha.1</Version>\n  \n  <!-- Beta release -->\n  <Version>1.0.0-beta.2</Version>\n  \n  <!-- Release candidate -->\n  <Version>1.0.0-rc.1</Version>\n  \n  <!-- Final release -->\n  <Version>1.0.0</Version>\n</PropertyGroup>\n```\n\n#### ❌ DON'T: Make breaking changes without incrementing the major version\n\n```xml\n<!-- DON'T: This suggests no breaking changes -->\n<PropertyGroup>\n  <Version>1.2.0</Version>\n</PropertyGroup>\n```\n\n### Version in Directory.Build.props\n\nFor multi-package solutions, manage versions centrally.\n\n#### ✅ DO: Centralize version management\n\n```xml\n<!-- In Directory.Build.props -->\n<Project>\n  <PropertyGroup>\n    <VersionPrefix>1.2.3</VersionPrefix>\n    <VersionSuffix Condition=\"'$(Configuration)' == 'Debug'\">preview</VersionSuffix>\n  </PropertyGroup>\n</Project>\n```\n\n## Build and Pack Commands\n\n### Generate Packages with dotnet pack\n\nUse `dotnet pack` to generate both `.nupkg` and `.snupkg` files.\n\n#### ✅ DO: Pack with appropriate configuration\n\n```shell\n# Basic pack command\ndotnet pack -c Release\n\n# Pack with specific version\ndotnet pack -c Release /p:Version=1.2.3\n\n# Pack with version suffix\ndotnet pack -c Release --version-suffix preview.1\n\n# Pack multiple projects\ndotnet pack MySolution.sln -c Release\n```\n\n### Verify Package Contents\n\nAlways verify package contents before publishing.\n\n#### ✅ DO: Inspect package contents\n\n```shell\n# Install the NuGet Package Explorer CLI\ndotnet tool install -g NuGet.PackageExplorer.CLI\n\n# View package contents\nnuget-pe view MyPackage.1.0.0.nupkg\n\n# Or use the nuget CLI\nnuget verify MyPackage.1.0.0.nupkg\n```\n\n### Publish Packages\n\nPublish packages to NuGet.org or a private feed.\n\n#### ✅ DO: Publish to NuGet.org\n\n```shell\n# Push package to NuGet.org\ndotnet nuget push MyPackage.1.0.0.nupkg -s https://api.nuget.org/v3/index.json -k YOUR_API_KEY\n\n# Push symbol package\ndotnet nuget push MyPackage.1.0.0.snupkg -s https://api.nuget.org/v3/index.json -k YOUR_API_KEY\n```\n\n#### ✅ DO: Publish to a private feed\n\n```shell\n# Push to Azure Artifacts\ndotnet nuget push MyPackage.1.0.0.nupkg -s https://pkgs.dev.azure.com/myorg/_packaging/myfeed/nuget/v3/index.json -k az\n\n# Push to GitHub Packages\ndotnet nuget push MyPackage.1.0.0.nupkg -s https://nuget.pkg.github.com/myorg/index.json -k YOUR_GITHUB_TOKEN\n```\n\n## Quality Checks\n\n### Pre-publish Checklist\n\nAlways run through this checklist before publishing:\n\n1. **Metadata Verification**\n   - Package ID is correct and follows naming conventions\n   - Version is appropriate (SemVer)\n   - Description is clear and informative\n   - Authors and copyright information is correct\n   - License expression is valid\n   - Project URL and repository URL are correct\n   - Tags are relevant and helpful for discoverability\n\n2. **Content Verification**\n   - README.md is included and renders correctly\n   - All images in README use approved domains\n   - XML documentation is generated and included\n   - No unnecessary files are included in the package\n\n3. **Symbol and Source Verification**\n   - Symbol package (`.snupkg`) is generated\n   - SourceLink is configured correctly\n   - Source debugging works as expected\n\n4. **Dependency Verification**\n   - Dependencies are minimal and necessary\n   - Version ranges are appropriate\n   - No conflicting dependencies\n\n5. **Functional Verification**\n   - Package installs successfully in a new project\n   - Basic functionality works as expected\n   - No runtime errors or exceptions\n\n### Automated Quality Checks\n\nImplement automated checks in your CI/CD pipeline.\n\n#### ✅ DO: Add package validation to CI\n\n```yaml\n# Example GitHub Actions workflow\nname: Package Validation\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Setup .NET\n      uses: actions/setup-dotnet@v3\n      with:\n        dotnet-version: 8.0.x\n    - name: Restore dependencies\n      run: dotnet restore\n    - name: Build\n      run: dotnet build --no-restore -c Release\n    - name: Test\n      run: dotnet test --no-build -c Release\n    - name: Pack\n      run: dotnet pack --no-build -c Release\n    - name: Validate Package\n      run: |\n        dotnet tool install -g NuGet.PackageExplorer.CLI\n        nuget-pe validate bin/Release/*.nupkg\n```\n\n## Additional Resources\n\n- [NuGet Documentation](mdc:https:/docs.microsoft.com/en-us/nuget)\n- [SPDX License List](mdc:https:/spdx.org/licenses)\n- [SourceLink Documentation](mdc:https:/github.com/dotnet/sourcelink)\n- [SemVer Specification](mdc:https:/semver.org)\n- [NuGet Package Explorer](mdc:https:/github.com/NuGetPackageExplorer/NuGetPackageExplorer) ",
    "sourceUrl": "https://github.com/Aaronontheweb/dotnet-cursor-rules/blob/master/nuget-packages/nuget-package-publishing.mdc",
    "version": "1.0.0",
    "metadata": {
      "originalPath": "nuget-packages/nuget-package-publishing.mdc",
      "sha": "1396bd28fb37706b6b90d666fe4e4f461a29d4c9"
    }
  }
]