name: Deploy Registry Application

on:
  push:
    branches:
      - main
    paths:
      - 'packages/registry/**'
      - 'packages/types/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: us-west-2
  NODE_VERSION: '20'

jobs:
  deploy:
    name: Deploy Registry to Beanstalk (${{ github.event.inputs.environment || 'dev' }})
    runs-on: ubuntu-latest

    # Prevent concurrent deployments to same environment
    concurrency:
      group: deploy-${{ github.event.inputs.environment || 'prod' }}
      cancel-in-progress: false

    defaults:
      run:
        working-directory: packages/registry

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set environment variables
        id: env
        run: |
          ENVIRONMENT="${{ github.event.inputs.environment || 'prod' }}"
          echo "ENVIRONMENT=$ENVIRONMENT" >> $GITHUB_OUTPUT

          # Set Beanstalk app/env names based on Pulumi outputs
          if [ "$ENVIRONMENT" = "prod" ]; then
            echo "EB_APP_NAME=prpm-prod" >> $GITHUB_OUTPUT
            echo "EB_ENV_NAME=prpm-prod-env" >> $GITHUB_OUTPUT
            echo "S3_BUCKET=prpm-prod-packages" >> $GITHUB_OUTPUT
          elif [ "$ENVIRONMENT" = "staging" ]; then
            echo "EB_APP_NAME=prpm-staging" >> $GITHUB_OUTPUT
            echo "EB_ENV_NAME=prpm-staging-env" >> $GITHUB_OUTPUT
            echo "S3_BUCKET=prpm-deployments-staging" >> $GITHUB_OUTPUT
          else
            echo "EB_APP_NAME=prpm-dev" >> $GITHUB_OUTPUT
            echo "EB_ENV_NAME=prpm-dev-env" >> $GITHUB_OUTPUT
            echo "S3_BUCKET=prpm-deployments-dev" >> $GITHUB_OUTPUT
          fi

      # CRITICAL: Check environment health before deploying
      - name: Check Beanstalk environment status
        id: check_env
        run: |
          echo "Checking environment: ${{ steps.env.outputs.EB_ENV_NAME }}"

          ENV_STATUS=$(aws elasticbeanstalk describe-environments \
            --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
            --query "Environments[0].Status" \
            --output text 2>/dev/null || echo "NotFound")

          ENV_HEALTH=$(aws elasticbeanstalk describe-environments \
            --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
            --query "Environments[0].Health" \
            --output text 2>/dev/null || echo "Unknown")

          echo "Environment Status: $ENV_STATUS"
          echo "Environment Health: $ENV_HEALTH"

          if [ "$ENV_STATUS" = "NotFound" ]; then
            echo "‚ö†Ô∏è  Environment does not exist. Please provision infrastructure first."
            exit 1
          fi

          if [ "$ENV_STATUS" != "Ready" ]; then
            echo "‚ùå Environment not ready. Status: $ENV_STATUS"
            echo "Please wait for environment to be Ready or check for issues."
            exit 1
          fi

          if [ "$ENV_HEALTH" = "Red" ]; then
            echo "‚ö†Ô∏è  WARNING: Environment health is Red"
            echo "Proceeding with caution. Monitor deployment closely."
          fi

          echo "‚úÖ Environment is ready for deployment"

      - name: Install dependencies
        working-directory: .
        run: |
          echo "Installing root dependencies..."
          npm ci --quiet

          echo "Installing types dependencies..."
          cd packages/types
          npm ci --quiet

          echo "Installing registry dependencies..."
          cd ../registry
          npm ci --quiet

      - name: Build types package
        working-directory: packages/types
        run: |
          echo "Building types package..."
          npm run build

          if [ ! -d "dist" ]; then
            echo "‚ùå Types build failed - dist directory not found"
            exit 1
          fi

          echo "‚úÖ Types built successfully"

      - name: Build application
        working-directory: packages/registry
        run: |
          echo "Building registry application..."
          npm run build

          if [ ! -d "dist" ]; then
            echo "‚ùå Build failed - dist directory not found"
            exit 1
          fi

          echo "‚úÖ Build completed successfully"

      - name: Prepare standalone package for deployment
        working-directory: packages/registry
        run: |
          echo "üì¶ Creating standalone package.json (removing workspace dependency)..."

          # Create temp directory for clean install
          mkdir -p /tmp/registry-deploy
          cd /tmp/registry-deploy

          # Copy original package.json
          cp $GITHUB_WORKSPACE/packages/registry/package.json .

          # Replace workspace dependency with local file path
          # This allows npm to install it as a regular package
          jq --arg workspace "$GITHUB_WORKSPACE" '.dependencies["@prpm/types"] = "file:\($workspace)/packages/types"' package.json > package.json.tmp
          mv package.json.tmp package.json

          echo "üìÑ Modified package.json dependencies:"
          jq '.dependencies | with_entries(select(.key | contains("prpm")))' package.json

          echo "‚úÖ Standalone package.json created"

      - name: Install production dependencies (clean context)
        run: |
          echo "üì¶ Installing ALL production dependencies in clean context..."
          cd /tmp/registry-deploy

          # Install without workspace resolution - treats @prpm/types as file dependency
          npm install --omit=dev --legacy-peer-deps

          echo "‚úÖ Production dependencies installed"
          echo "üìÅ node_modules size:"
          du -sh node_modules

          # Verify critical packages
          echo "üîç Checking for required packages..."
          for pkg in pg fastify @prpm/types; do
            if [ -d "node_modules/$pkg" ]; then
              echo "  ‚úÖ $pkg"
            else
              echo "  ‚ùå $pkg MISSING!"
              exit 1
            fi
          done

          # Verify @prpm/types has its dist
          if [ -d "node_modules/@prpm/types/dist" ]; then
            echo "‚úÖ @prpm/types properly installed with dist/"
          else
            echo "‚ùå @prpm/types incomplete"
            exit 1
          fi

      - name: Copy clean dependencies to registry
        working-directory: packages/registry
        run: |
          echo "üì¶ Copying clean node_modules to registry package..."

          # Remove workspace-linked node_modules
          rm -rf node_modules

          # Copy clean install from temp directory
          cp -r /tmp/registry-deploy/node_modules .

          echo "‚úÖ Dependencies copied"
          echo "üìÅ Final node_modules size:"
          du -sh node_modules

          # Final verification
          echo "üîç Final package check:"
          ls -la node_modules/@prpm/types/ | head -10

      - name: Create deployment package
        working-directory: packages/registry
        run: |
          VERSION_LABEL="v${{ github.run_number }}-$(echo ${{ github.sha }} | cut -c1-7)"
          echo "VERSION_LABEL=$VERSION_LABEL" >> $GITHUB_ENV

          echo "Creating deployment package: ${VERSION_LABEL}.zip"

          # Verify dist exists before packaging
          echo "üìÅ Checking dist directory before packaging:"
          if [ ! -d "dist" ]; then
            echo "‚ùå dist/ directory not found in $(pwd)"
            ls -la
            exit 1
          fi

          if [ ! -f "dist/index.js" ]; then
            echo "‚ùå dist/index.js not found"
            ls -la dist/
            exit 1
          fi

          echo "‚úÖ dist/ directory exists with index.js"
          echo "dist/ contents:"
          ls -lh dist/ | head -10

          # Include everything: dist, migrations, node_modules (with all deps)
          # EB will see node_modules exists and skip npm install
          zip -r ${VERSION_LABEL}.zip \
            dist/ \
            package.json \
            package-lock.json \
            .ebextensions/ \
            .platform/ \
            migrations/ \
            scripts/ \
            node_modules/ \
            Procfile \
            -x "*.git*" \
            -x "*.md" \
            -x "*.test.*" \
            -x "*.spec.*" \
            -x "*.ts" \
            -x "node_modules/.cache/*"

          # Verify package contents
          echo "üìÅ Verifying deployment package contents:"
          unzip -l ${VERSION_LABEL}.zip | grep -E "(node_modules/@prpm/types|package.json|dist/)" | head -15

          echo ""
          echo "üìÅ Checking for critical dist files:"
          if unzip -l ${VERSION_LABEL}.zip | grep -q "dist/index.js"; then
            echo "‚úÖ dist/index.js found in package"
          else
            echo "‚ùå dist/index.js NOT FOUND in package!"
            echo "Package contents:"
            unzip -l ${VERSION_LABEL}.zip | head -30
            exit 1
          fi

          if unzip -l ${VERSION_LABEL}.zip | grep -q "dist/migrations/run.js"; then
            echo "‚úÖ dist/migrations/run.js found in package"
          else
            echo "‚ùå dist/migrations/run.js NOT FOUND in package!"
            exit 1
          fi

          ls -lh ${VERSION_LABEL}.zip
          echo "‚úÖ Deployment package created with complete node_modules and dist/"

      - name: Upload to S3
        working-directory: packages/registry
        run: |
          S3_KEY="deployments/${VERSION_LABEL}.zip"
          echo "Uploading to s3://${{ steps.env.outputs.S3_BUCKET }}/${S3_KEY}"

          aws s3 cp ${VERSION_LABEL}.zip s3://${{ steps.env.outputs.S3_BUCKET }}/${S3_KEY} \
            --metadata "git-sha=${{ github.sha }},run-number=${{ github.run_number }},environment=${{ steps.env.outputs.ENVIRONMENT }}"

          echo "‚úÖ Uploaded to S3"

      - name: Create Beanstalk application version
        run: |
          echo "Creating application version: $VERSION_LABEL"

          aws elasticbeanstalk create-application-version \
            --application-name ${{ steps.env.outputs.EB_APP_NAME }} \
            --version-label $VERSION_LABEL \
            --source-bundle S3Bucket="${{ steps.env.outputs.S3_BUCKET }}",S3Key="deployments/${VERSION_LABEL}.zip" \
            --description "Deployed from GitHub Actions run ${{ github.run_number }} (SHA: ${{ github.sha }})" \
            --process

          echo "‚úÖ Application version created"

      - name: Get current environment configuration
        id: current_config
        run: |
          # Get current version for potential rollback
          CURRENT_VERSION=$(aws elasticbeanstalk describe-environments \
            --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
            --query "Environments[0].VersionLabel" \
            --output text)

          echo "CURRENT_VERSION=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Deploy to Beanstalk environment
        run: |
          echo "Deploying version $VERSION_LABEL to ${{ steps.env.outputs.EB_ENV_NAME }}"

          aws elasticbeanstalk update-environment \
            --application-name ${{ steps.env.outputs.EB_APP_NAME }} \
            --environment-name ${{ steps.env.outputs.EB_ENV_NAME }} \
            --version-label $VERSION_LABEL

          echo "‚úÖ Deployment initiated"

      # CRITICAL: Wait for deployment to complete with proper timeout
      - name: Wait for deployment completion
        timeout-minutes: 15
        run: |
          echo "‚è≥ Waiting for deployment to complete..."
          echo "This may take 5-10 minutes depending on deployment policy."

          RED_COUNT=0      # Track consecutive Red health checks
          RED_COUNT_PREV=0 # Track previous count for recovery messages

          for i in {1..90}; do
            STATUS=$(aws elasticbeanstalk describe-environments \
              --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
              --query "Environments[0].Status" \
              --output text)

            HEALTH=$(aws elasticbeanstalk describe-environments \
              --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
              --query "Environments[0].Health" \
              --output text)

            VERSION=$(aws elasticbeanstalk describe-environments \
              --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
              --query "Environments[0].VersionLabel" \
              --output text)

            echo "[$i/90] Status: $STATUS | Health: $HEALTH | Version: $VERSION"

            # Check if deployment completed successfully
            if [ "$STATUS" = "Ready" ] && [ "$VERSION" = "$VERSION_LABEL" ]; then
              if [ "$HEALTH" = "Green" ]; then
                echo "‚úÖ Deployment successful! Environment is healthy."
                exit 0
              elif [ "$HEALTH" = "Yellow" ]; then
                echo "‚ö†Ô∏è  Deployment complete but health is Yellow. Proceeding with verification."
                exit 0
              fi
            fi

            # Check for failure conditions
            if [ "$STATUS" = "Ready" ] && [ "$VERSION" != "$VERSION_LABEL" ] && [ $i -gt 10 ]; then
              echo "‚ùå Deployment failed - version did not update"
              echo "Current: $VERSION, Expected: $VERSION_LABEL"
              exit 1
            fi

            # Only fail on Red health if it persists for multiple checks
            if [ "$HEALTH" = "Red" ]; then
              RED_COUNT=$((RED_COUNT + 1))
              echo "‚ö†Ô∏è  Health is Red (consecutive: $RED_COUNT)"

              # Only fail if Red for 6+ consecutive checks (60+ seconds) AND we're past initial deployment phase
              # This accounts for rolling deployments where multiple instances cycle through
              if [ $RED_COUNT -ge 6 ] && [ $i -gt 12 ]; then
                echo "‚ùå Environment health has been Red for $RED_COUNT consecutive checks (60+ seconds)"

                # Get recent events
                echo "Recent events:"
                aws elasticbeanstalk describe-events \
                  --environment-name ${{ steps.env.outputs.EB_ENV_NAME }} \
                  --max-records 10 \
                  --query 'Events[*].[EventDate,Severity,Message]' \
                  --output table

                exit 1
              fi
            else
              # Reset counter if health improves
              RED_COUNT=0
              if [ $RED_COUNT_PREV -gt 0 ]; then
                echo "‚úÖ Health recovered from Red after $RED_COUNT_PREV checks"
                RED_COUNT_PREV=0
              fi
            fi
            RED_COUNT_PREV=$RED_COUNT

            sleep 10
          done

          echo "‚ùå Deployment timed out after 15 minutes"
          exit 1

      # CRITICAL: Verify health endpoint
      - name: Verify application health
        timeout-minutes: 10
        run: |
          echo "Verifying application health endpoint..."

          # Get the EB CNAME endpoint
          EB_URL=$(aws elasticbeanstalk describe-environments \
            --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
            --query "Environments[0].CNAME" \
            --output text)

          echo "Testing health endpoint at http://$EB_URL/health"

          # Wait longer for rolling deployment to complete
          echo "‚è≥ Waiting for rolling deployment to complete..."
          sleep 60

          for i in {1..15}; do
            if curl -f -s "http://$EB_URL/health" > /dev/null; then
              echo "‚úÖ Application is healthy!"

              # Test a key API endpoint to ensure full functionality
              if curl -f -s "http://$EB_URL/api/v1/packages?limit=1" > /dev/null; then
                echo "‚úÖ API endpoint working"
                exit 0
              else
                echo "‚ö†Ô∏è  Health passed but API endpoint not responding yet..."
                echo "Retrying in 30 seconds..."
              fi
            else
              echo "‚è≥ Attempt $i/15: Application not ready yet..."
            fi

            sleep 30
          done

          # If we get here, health checks failed
          echo "‚ö†Ô∏è  Health check failed after 15 attempts, but deployment may still be successful"
          echo "üîç Check the Elastic Beanstalk environment status manually"

          # Don't fail the deployment - just warn
          echo "‚ö†Ô∏è  Proceeding with caution. Monitor the environment."

          # Show recent logs for debugging
          echo ""
          echo "üìã Recent events:"
          aws elasticbeanstalk describe-events \
            --environment-name ${{ steps.env.outputs.EB_ENV_NAME }} \
            --max-records 10 \
            --query 'Events[*].[EventDate,Severity,Message]' \
            --output table

          # Don't rollback automatically - the deployment might be fine
          # Let the user check manually and rollback if needed

      - name: Get deployment summary
        if: success()
        run: |
          ENDPOINT=$(aws elasticbeanstalk describe-environments \
            --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
            --query "Environments[0].CNAME" \
            --output text)

          HEALTH=$(aws elasticbeanstalk describe-environments \
            --environment-names ${{ steps.env.outputs.EB_ENV_NAME }} \
            --query "Environments[0].Health" \
            --output text)

          echo "## üöÄ Deployment Successful"
          echo ""
          echo "**Environment:** ${{ steps.env.outputs.ENVIRONMENT }}"
          echo "**Version:** $VERSION_LABEL"
          echo "**Health:** $HEALTH"
          echo "**Endpoint:** http://${ENDPOINT}"
          echo ""
          echo "**Health Check:** http://${ENDPOINT}/health"
          echo "**API Docs:** http://${ENDPOINT}/docs"
          echo ""
          echo "**Deployed at:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "**Git SHA:** ${{ github.sha }}"
          echo "**Run Number:** ${{ github.run_number }}"

      - name: Cleanup old application versions
        if: success()
        run: |
          echo "Cleaning up old application versions (keeping last 10)..."

          # Get all versions sorted by date
          VERSIONS=$(aws elasticbeanstalk describe-application-versions \
            --application-name ${{ steps.env.outputs.EB_APP_NAME }} \
            --query 'ApplicationVersions | sort_by(@, &DateCreated) | [*].VersionLabel' \
            --output text)

          VERSION_COUNT=$(echo "$VERSIONS" | wc -w)

          if [ $VERSION_COUNT -gt 10 ]; then
            VERSIONS_TO_DELETE=$(echo "$VERSIONS" | tr ' ' '\n' | head -n -10)

            for VERSION in $VERSIONS_TO_DELETE; do
              # Don't delete if it's currently deployed in any environment
              IN_USE=$(aws elasticbeanstalk describe-environments \
                --application-name ${{ steps.env.outputs.EB_APP_NAME }} \
                --query "Environments[?VersionLabel=='$VERSION'].EnvironmentName" \
                --output text)

              if [ -z "$IN_USE" ]; then
                echo "Deleting old version: $VERSION"
                aws elasticbeanstalk delete-application-version \
                  --application-name ${{ steps.env.outputs.EB_APP_NAME }} \
                  --version-label $VERSION \
                  --delete-source-bundle
              else
                echo "Skipping $VERSION (in use by $IN_USE)"
              fi
            done
          fi

          echo "‚úÖ Cleanup complete"

      - name: Post deployment notification
        if: success()
        run: |
          echo "‚úÖ Deployment completed successfully!"
          echo "Environment: ${{ steps.env.outputs.ENVIRONMENT }}"
          echo "Version: $VERSION_LABEL"
          # Add Slack/Discord/email notification here if needed

      - name: Notify on failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed!"
          echo "Environment: ${{ steps.env.outputs.ENVIRONMENT }}"
          echo "Version: $VERSION_LABEL"

          # Get recent error events
          echo "Recent error events:"
          aws elasticbeanstalk describe-events \
            --environment-name ${{ steps.env.outputs.EB_ENV_NAME }} \
            --severity ERROR \
            --max-records 20 \
            --query 'Events[*].[EventDate,Message]' \
            --output table

          # Add Slack/Discord/PagerDuty notification here

      - name: Save deployment artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-${{ steps.env.outputs.ENVIRONMENT }}-${{ github.run_number }}
          path: packages/registry/${{ env.VERSION_LABEL }}.zip
          retention-days: 7
